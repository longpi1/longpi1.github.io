

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme="auto">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E5%AD%A6%E6%A0%A1.png">
  <link rel="icon" href="/img/%E5%AD%A6%E6%A0%A1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="lp">
  <meta name="keywords" content>
  
    <meta name="description" content="在Go中如何正确重试请求?">
<meta property="og:type" content="article">
<meta property="og:title" content="在Go中如何正确重试请求?">
<meta property="og:url" content="https://blog.longpi1.com/2022/12/29/%E5%9C%A8Go%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%87%8D%E8%AF%95%E8%AF%B7%E6%B1%82/index.html">
<meta property="og:site_name" content="lp&#39;s blog">
<meta property="og:description" content="在Go中如何正确重试请求?">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/EzEnMOIbkiamyxLyWLibjWmjllfdh8UkGesW9eOHKicNhKDtZUmibgVMetK3xDUyU56iccRJWicRNmfIgKwL7VvjV4fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2022-12-29T13:24:19.000Z">
<meta property="article:modified_time" content="2022-12-29T13:33:39.540Z">
<meta property="article:author" content="lp">
<meta property="article:tag" content="转载">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_png/EzEnMOIbkiamyxLyWLibjWmjllfdh8UkGesW9eOHKicNhKDtZUmibgVMetK3xDUyU56iccRJWicRNmfIgKwL7VvjV4fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">
  
  
  
  <title>在Go中如何正确重试请求? - lp&#39;s blog</title>

  <link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css">



  <link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link rel="stylesheet" href="/css/main.css">


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css">
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css">
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.longpi1.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":30,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"UvaCwj6C0pVj9XCWuMtLaBWJ-gzGzoHsz","app_key":"w2xUk9wycItSqrREmRMDYJHY","server_url":"https://uvacwj6c.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>lp&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                文章分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax="true" style="background: url('/img/bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="在Go中如何正确重试请求?"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-29 21:24" pubdate>
          2022年12月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>


    <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/longpi1"><img loading="lazy" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" srcset="/img/loading.gif" lazyload class="attachment-full size-full" alt="follow me on GitHub" data-recalc-dims="1"></a>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">在Go中如何正确重试请求?</h1>
            
            
              <div class="markdown-body">
              <meta name="referrer" content="no-referrer">
                
                <h1 id="在Go中如何正确重试请求"><a href="#在Go中如何正确重试请求" class="headerlink" title="在Go中如何正确重试请求"></a>在Go中如何正确重试请求</h1><blockquote>
<p>本文章转载自 luozhiyun很酷 的 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://mp.weixin.qq.com/s/NRbSCy-g7Utf7e6ql2rtYA">在Go中如何正确重试请求</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们平时在开发中肯定避不开的一个问题是如何在不可靠的网络服务中实现可靠的网络通信，其中 http 请求重试是经常用的技术。但是 Go 标准库 net&#x2F;http 实际上是没有重试这个功能的，所以本篇文章主要讲解如何在 Go 中实现请求重试。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般而言，对于网络通信失败的处理分为以下几步：</p>
<ol>
<li>感知错误。通过不同的错误码来识别不同的错误，在HTTP中status code可以用来识别不同类型的错误；</li>
<li>重试决策。这一步主要用来减少不必要的重试，比如HTTP的4xx的错误，通常4xx表示的是客户端的错误，这时候客户端不应该进行重试操作，或者在业务中自定义的一些错误也不应该被重试。根据这些规则的判断可以有效的减少不必要的重试次数，提升响应速度；</li>
<li>重试策略。重试策略就包含了重试间隔时间，重试次数等。如果次数不够，可能并不能有效的覆盖这个短时间故障的时间段，如果重试次数过多，或者重试间隔太小，又可能造成大量的资源(CPU、内存、线程、网络)浪费。这个我们下面再说；</li>
<li>对冲策略。对冲是指在不等待响应的情况主动发送单次调用的多个请求，然后取首个返回的回包。这个概念是 grpc 中的概念，我把它也借用过来；</li>
<li>熔断降级；如果重试之后还是不行，说明这个故障不是短时间的故障，而是长时间的故障。那么可以对服务进行熔断降级，后面的请求不再重试，这段时间做降级处理，减少没必要的请求，等服务端恢复了之后再进行请求，这方面的实现很多 go-zero 、 sentinel 、hystrix-go，也蛮有意思的；</li>
</ol>
<h2 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h2><p>重试策略可以分为很多种，一方面要考虑到本次请求时长过长而影响到的业务忍受度，另一方面要考虑到重试会对下游服务产生过多的请求而带来的影响，总之就是一个trade-off的问题。</p>
<p>所以对于重试算法，一般是在重试之间加一个 gap 时间，算法一般可以总结出以下几条规则：</p>
<ul>
<li>线性间隔（Linear Backoff）：每次重试间隔时间是固定的进行重试，如每1s重试一次；</li>
<li>线性间隔+随机时间（Linear Jitter Backoff）：有时候每次重试间隔时间一致可能会导致多个请求在同一时间请求，那么我们可以加入一个随机时间，在线性间隔时间的基础上波动一个百分比的时间；</li>
<li>指数间隔（Exponential Backoff）：每次间隔时间是2指数型的递增，如等 3s 9s 27s后重试；</li>
<li>指数间隔+随机时间（Exponential Jitter Backoff）：这个就和第二个类似了，在指数递增的基础上添加一个波动时间；</li>
</ul>
<p>上面有两种策略都加入了<strong>扰动（jitter）</strong>，目的是防止<strong>惊群问题 （Thundering Herd Problem）</strong>的发生。</p>
<blockquote>
<p>In computer science, the <strong>thundering herd problem</strong> occurs when a large number of processes or threads waiting for an event are awoken when that event occurs, but only one process is able to handle the event. When the processes wake up, they will each try to handle the event, but only one will win. All processes will compete for resources, possibly freezing the computer, until the herd is calmed down again</p>
</blockquote>
<p>所谓惊群问题当许多进程都在等待被同一事件唤醒的时候，当事件发生后最后只有一个进程能获得处理。其余进程又造成阻塞，这会造成上下文切换的浪费。所以加入一个随机时间来避免同一时间同时请求服务端还是很有必要的。</p>
<h2 id="使用-net-x2F-http-重试所带来的问题"><a href="#使用-net-x2F-http-重试所带来的问题" class="headerlink" title="使用 net&#x2F;http 重试所带来的问题"></a>使用 net&#x2F;http 重试所带来的问题</h2><p>重试这个操作其实对于 Go 来说其实还不能直接加一个 for 循环根据次数来进行，对于 Get 请求重试的时候没有请求体，可以直接进行重试，但是对于 Post 请求来说需要把请求体放到<code>Reader</code> 里面，如下：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">req, _ := http.NewRequest(<span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, strings.NewReader(<span class="hljs-string">&quot;hello&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>服务端收到请求之后就会从这个<code>Reader</code>中调用<code>Read()</code>函数去读取数据，通常情况当服务端去读取数据的时候，<code>offset</code>会随之改变，下一次再读的时候会从<code>offset</code>位置继续向后读取。所以如果直接重试，会出现读不到 <code>Reader</code>的情况。</p>
<p>我们可以先弄一个例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>   time.Sleep(time.Millisecond * <span class="hljs-number">20</span>)<br>   body, _ := ioutil.ReadAll(r.Body)  <br>   fmt.Printf(<span class="hljs-string">&quot;received body with length %v containing: %v\n&quot;</span>, <span class="hljs-built_in">len</span>(body), <span class="hljs-type">string</span>(body))<br>   w.WriteHeader(http.StatusOK)<br>  &#125;))<br>  http.ListenAndServe(<span class="hljs-string">&quot;:8090&quot;</span>, <span class="hljs-literal">nil</span>)<br> &#125;()<br> fmt.Print(<span class="hljs-string">&quot;Try with bare strings.Reader\n&quot;</span>) <br> retryDo(req)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retryDo</span><span class="hljs-params">()</span></span> &#123;<br> originalBody := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;abcdefghigklmnopqrst&quot;</span>)<br> reader := strings.NewReader(<span class="hljs-type">string</span>(originalBody))<br> req, _ := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>, reader)<br> client := http.Client&#123;<br>  Timeout: time.Millisecond * <span class="hljs-number">10</span>,<br> &#125;<br><br> <span class="hljs-keyword">for</span> &#123;<br>  _, err := client.Do(req)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;error sending the first time: %v\n&quot;</span>, err)<br>  &#125; <br>  time.Sleep(<span class="hljs-number">1000</span>)<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// output:</span><br><span class="hljs-type">error</span> sending the first time: Post <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>: context deadline exceeded (Client.Timeout exceeded while awaiting headers)<br><span class="hljs-type">error</span> sending the first time: Post <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>: http: ContentLength=<span class="hljs-number">20</span> with Body length <span class="hljs-number">0</span><br><span class="hljs-type">error</span> sending the first time: Post <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>: http: ContentLength=<span class="hljs-number">20</span> with Body length <span class="hljs-number">0</span><br>received body with length <span class="hljs-number">20</span> containing: abcdefghigklmnopqrst<br><span class="hljs-type">error</span> sending the first time: Post <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>: http: ContentLength=<span class="hljs-number">20</span> with Body length <span class="hljs-number">0</span><br>....<br></code></pre></td></tr></table></figure>

<p>在上面这个例子中，在客户端设值了 10ms 的超时时间。在服务端模拟请求处理超时情况，先sleep 20ms，然后再读请求数据，这样必然会超时。</p>
<p>当再次请求的时候，发现 client 请求的 Body 数据并不是我们预期的20个长度，而是 0，导致了 err。因此需要将Body这个<code>Reader </code>进行重置，如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resetBody</span><span class="hljs-params">(request *http.Request, originalBody []<span class="hljs-type">byte</span>)</span></span> &#123;<br> request.Body = io.NopCloser(bytes.NewBuffer(originalBody))<br> request.GetBody = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>  <span class="hljs-keyword">return</span> io.NopCloser(bytes.NewBuffer(originalBody)), <span class="hljs-literal">nil</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码中，我们使用 io.NopCloser 对请求的 Body 数据进行了重置，避免下次请求的时候出现非预期的异常。</p>
<p>那么相对于上面简陋的例子，还可以完善一下，加上我们上面说的 StatusCode 重试判断、重试策略、重试次数等等，可以写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retryDo</span><span class="hljs-params">(req *http.Request, maxRetries <span class="hljs-type">int</span>, timeout time.Duration,</span></span><br><span class="hljs-params"><span class="hljs-function"> backoffStrategy BackoffStrategy)</span></span> (*http.Response, <span class="hljs-type">error</span>) &#123;<br> <span class="hljs-keyword">var</span> (<br>  originalBody []<span class="hljs-type">byte</span><br>  err          <span class="hljs-type">error</span><br> )<br> <span class="hljs-keyword">if</span> req != <span class="hljs-literal">nil</span> &amp;&amp; req.Body != <span class="hljs-literal">nil</span> &#123;<br>  originalBody, err = copyBody(req.Body)<br>  resetBody(req, originalBody)<br> &#125;<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br> &#125;<br> AttemptLimit := maxRetries<br> <span class="hljs-keyword">if</span> AttemptLimit &lt;= <span class="hljs-number">0</span> &#123;<br>  AttemptLimit = <span class="hljs-number">1</span><br> &#125;<br><br> client := http.Client&#123;<br>  Timeout: timeout,<br> &#125;<br> <span class="hljs-keyword">var</span> resp *http.Response<br>  <span class="hljs-comment">//重试次数</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= AttemptLimit; i++ &#123;<br>  resp, err = client.Do(req)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;error sending the first time: %v\n&quot;</span>, err)<br>  &#125; <br>  <span class="hljs-comment">// 重试 500 以上的错误码</span><br>  <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; resp.StatusCode &lt; <span class="hljs-number">500</span> &#123;<br>   <span class="hljs-keyword">return</span> resp, err<br>  &#125;<br>  <span class="hljs-comment">// 如果正在重试，那么释放fd</span><br>  <span class="hljs-keyword">if</span> resp != <span class="hljs-literal">nil</span> &#123;<br>   resp.Body.Close()<br>  &#125;<br>  <span class="hljs-comment">// 重置body</span><br>  <span class="hljs-keyword">if</span> req.Body != <span class="hljs-literal">nil</span> &#123;<br>   resetBody(req, originalBody)<br>  &#125;<br>  time.Sleep(backoffStrategy(i) + <span class="hljs-number">1</span>*time.Microsecond)<br> &#125;<br> <span class="hljs-comment">// 到这里，说明重试也没用</span><br> <span class="hljs-keyword">return</span> resp, req.Context().Err()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyBody</span><span class="hljs-params">(src io.ReadCloser)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br> b, err := ioutil.ReadAll(src)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrReadingRequestBody<br> &#125;<br> src.Close()<br> <span class="hljs-keyword">return</span> b, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resetBody</span><span class="hljs-params">(request *http.Request, originalBody []<span class="hljs-type">byte</span>)</span></span> &#123;<br> request.Body = io.NopCloser(bytes.NewBuffer(originalBody))<br> request.GetBody = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>  <span class="hljs-keyword">return</span> io.NopCloser(bytes.NewBuffer(originalBody)), <span class="hljs-literal">nil</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对冲策略"><a href="#对冲策略" class="headerlink" title="对冲策略"></a>对冲策略</h2><p>上面讲的是重试的概念，那么有时候我们接口只是偶然会出问题，并且我们的下游服务并不在乎多请求几次，那么我们可以借用 grpc 里面的概念：<strong>对冲策略（Hedged requests）</strong>。</p>
<p><strong>对冲是指在不等待响应的情况主动发送单次调用的多个请求</strong>，然后取首个返回的回包。对冲和重试的区别点主要在：对冲在超过指定时间没有响应就会直接发起请求，而重试则必须要服务端响应后才会发起请求。所以对冲更像是比较激进的重试策略。</p>
<p>使用对冲的时候需要注意一点是，因为下游服务可能会做负载均衡策略，所以要求请求的下游服务一般是要求幂等的，能够在多次并发请求中是安全的，并且是符合预期的。</p>
<p>对冲请求一般是用来处理“长尾”请求的，关于”长尾“请求的概念可以看这篇文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000039978117">https://segmentfault.com/a/1190000039978117</a></p>
<h3 id="并发模式的处理"><a href="#并发模式的处理" class="headerlink" title="并发模式的处理"></a>并发模式的处理</h3><p>因为对冲重试加上了并发的概念，要用到 goroutine 来并发请求，所以我们可以把数据封装到 channel 里面来进行消息的异步处理。</p>
<p>并且由于是多个goroutine处理消息，我们需要在每个goroutine处理完毕，但是都失败的情况下返回err，不能直接由于channel等待卡住主流程，这一点十分重要。</p>
<p>但是由于在 Go 中是无法获取每个 goroutine 的执行结果的，我们又只关注正确处理结果，需要忽略错误，所以需要配合 WaitGroup 来实现流程控制，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> totalSentRequests := &amp;sync.WaitGroup&#123;&#125;<br> allRequestsBackCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br> multiplexCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span> &#123;<br>  result <span class="hljs-type">string</span><br>  retry  <span class="hljs-type">int</span><br> &#125;)<br> <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//所有请求完成之后会close掉allRequestsBackCh</span><br>  totalSentRequests.Wait()<br>  <span class="hljs-built_in">close</span>(allRequestsBackCh)<br> &#125;()<br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  totalSentRequests.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 标记已经执行完</span><br>   <span class="hljs-keyword">defer</span> totalSentRequests.Done()<br>   <span class="hljs-comment">// 模拟耗时操作</span><br>   time.Sleep(<span class="hljs-number">500</span> * time.Microsecond)<br>   <span class="hljs-comment">// 模拟处理成功</span><br>   <span class="hljs-keyword">if</span> random.Intn(<span class="hljs-number">500</span>)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>    multiplexCh &lt;- <span class="hljs-keyword">struct</span> &#123;<br>     result <span class="hljs-type">string</span><br>     retry  <span class="hljs-type">int</span><br>    &#125;&#123;<span class="hljs-string">&quot;finsh success&quot;</span>, i&#125;<br>   &#125;<br>   <span class="hljs-comment">// 处理失败不关心，当然，也可以加入一个错误的channel中进一步处理</span><br>  &#125;()<br> &#125;<br> <span class="hljs-keyword">select</span> &#123;<br> <span class="hljs-keyword">case</span> &lt;-multiplexCh:<br>  fmt.Println(<span class="hljs-string">&quot;finish success&quot;</span>)<br> <span class="hljs-keyword">case</span> &lt;-allRequestsBackCh:<br>  <span class="hljs-comment">// 到这里，说明全部的 goroutine 都执行完毕，但是都请求失败了</span><br>  fmt.Println(<span class="hljs-string">&quot;all req finish，but all fail&quot;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面这段代码看为了进行流程控制，多用了两个 channel ：totalSentRequests 、allRequestsBackCh，多用了一个 goroutine 异步关停 allRequestsBackCh，才实现的流程控制，实在太过于麻烦，有新的实现方案的同学不妨和我探讨一下。</p>
<p>除了上面的并发请求控制的问题，对于对冲重试来说，还需要注意的是，由于请求不是串行的，所以 http.Request 的上下文会变，所以每次请求前需要 clone 一次 context，保证每个不同请求的 context 是独立的。但是每次 clone 之后 <code>Reader </code>的<code>offset</code>位置又变了，所以我们还需要进行重新<code> reset</code>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;<br> req, _ := http.<span class="hljs-built_in">NewRequest</span>(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, strings.<span class="hljs-built_in">NewReader</span>(<span class="hljs-string">&quot;hello&quot;</span>))<br> req2 := req.<span class="hljs-built_in">Clone</span>(req.<span class="hljs-built_in">Context</span>())<br> contents, _ := io.<span class="hljs-built_in">ReadAll</span>(req.Body)<br> contents2, _ := io.<span class="hljs-built_in">ReadAll</span>(req2.Body)<br> fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;First read: %v\n&quot;</span>, <span class="hljs-built_in">string</span>(contents))<br> fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;Second read: %v\n&quot;</span>, <span class="hljs-built_in">string</span>(contents2))<br>&#125;<br><br>//output:<br>First read: hello<br>Second read: <br></code></pre></td></tr></table></figure>

<p>所以结合一下上面的例子，我们可以将对冲重试的代码变为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retryHedged</span><span class="hljs-params">(req *http.Request, maxRetries <span class="hljs-type">int</span>, timeout time.Duration,</span></span><br><span class="hljs-params"><span class="hljs-function"> backoffStrategy BackoffStrategy)</span></span> (*http.Response, <span class="hljs-type">error</span>) &#123;<br> <span class="hljs-keyword">var</span> (<br>  originalBody []<span class="hljs-type">byte</span><br>  err          <span class="hljs-type">error</span><br> )<br> <span class="hljs-keyword">if</span> req != <span class="hljs-literal">nil</span> &amp;&amp; req.Body != <span class="hljs-literal">nil</span> &#123;<br>  originalBody, err = copyBody(req.Body)<br> &#125;<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br> &#125;<br><br> AttemptLimit := maxRetries<br> <span class="hljs-keyword">if</span> AttemptLimit &lt;= <span class="hljs-number">0</span> &#123;<br>  AttemptLimit = <span class="hljs-number">1</span><br> &#125;<br><br> client := http.Client&#123;<br>  Timeout: timeout,<br> &#125;<br><br> <span class="hljs-comment">// 每次请求copy新的request</span><br> copyRequest := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (request *http.Request) &#123;<br>  request = req.Clone(req.Context())<br>  <span class="hljs-keyword">if</span> request.Body != <span class="hljs-literal">nil</span> &#123;<br>   resetBody(request, originalBody)<br>  &#125;<br>  <span class="hljs-keyword">return</span><br> &#125;<br><br> multiplexCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span> &#123;<br>  resp  *http.Response<br>  err   <span class="hljs-type">error</span><br>  retry <span class="hljs-type">int</span><br> &#125;)<br><br> totalSentRequests := &amp;sync.WaitGroup&#123;&#125;<br> allRequestsBackCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br> <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  totalSentRequests.Wait()<br>  <span class="hljs-built_in">close</span>(allRequestsBackCh)<br> &#125;()<br> <span class="hljs-keyword">var</span> resp *http.Response<br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= AttemptLimit; i++ &#123;<br>  totalSentRequests.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 标记已经执行完</span><br>   <span class="hljs-keyword">defer</span> totalSentRequests.Done()<br>   req = copyRequest()<br>   resp, err = client.Do(req)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;error sending the first time: %v\n&quot;</span>, err)<br>   &#125;<br>   <span class="hljs-comment">// 重试 500 以上的错误码</span><br>   <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; resp.StatusCode &lt; <span class="hljs-number">500</span> &#123;<br>    multiplexCh &lt;- <span class="hljs-keyword">struct</span> &#123;<br>     resp  *http.Response<br>     err   <span class="hljs-type">error</span><br>     retry <span class="hljs-type">int</span><br>    &#125;&#123;resp: resp, err: err, retry: i&#125;<br>    <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">// 如果正在重试，那么释放fd</span><br>   <span class="hljs-keyword">if</span> resp != <span class="hljs-literal">nil</span> &#123;<br>    resp.Body.Close()<br>   &#125;<br>   <span class="hljs-comment">// 重置body</span><br>   <span class="hljs-keyword">if</span> req.Body != <span class="hljs-literal">nil</span> &#123;<br>    resetBody(req, originalBody)<br>   &#125;<br>   time.Sleep(backoffStrategy(i) + <span class="hljs-number">1</span>*time.Microsecond)<br>  &#125;()<br> &#125;<br><br> <span class="hljs-keyword">select</span> &#123;<br> <span class="hljs-keyword">case</span> res := &lt;-multiplexCh:<br>  <span class="hljs-keyword">return</span> res.resp, res.err<br> <span class="hljs-keyword">case</span> &lt;-allRequestsBackCh:<br>  <span class="hljs-comment">// 到这里，说明全部的 goroutine 都执行完毕，但是都请求失败了</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;all req finish，but all fail&quot;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="熔断-amp-降级"><a href="#熔断-amp-降级" class="headerlink" title="熔断 &amp; 降级"></a>熔断 &amp; 降级</h2><p>因为在我们使用 http 调用的时候，调用的外部服务很多时候其实并不可靠，很有可能因为外部的服务问题导致自身服务接口调用等待，从而调用时间过长，产生大量的调用积压，慢慢耗尽服务资源，最终导致服务调用雪崩的发生，所以在服务中使用熔断降级是非常有必要的一件事。</p>
<p>其实熔断降级的概念总体上来说，实现都差不多。核心思想就是通过全局的计数器，用来统计调用次数、成功&#x2F;失败次数。通过统计的计数器来判断熔断器的开关，熔断器的状态由三种状态表示：closed、open、half open，下面借用了 sentinel 的图来表示三者的关系：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/EzEnMOIbkiamyxLyWLibjWmjllfdh8UkGesW9eOHKicNhKDtZUmibgVMetK3xDUyU56iccRJWicRNmfIgKwL7VvjV4fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>首先初始状态是<code>closed</code>，每次调用都会经过计数器统计总次数和成功&#x2F;失败次数，然后在达到一定阈值或条件之后熔断器会切换到 <code>open</code>状态，发起的请求会被拒绝。</p>
<p>熔断器规则中会配置一个熔断超时重试的时间，经过熔断超时重试时长后熔断器会将状态置为 <code>half-open</code> 状态。这个状态对于 sentinel 来说会发起定时探测，对于 go-zero 来说会允许通过一定比例的请求，不管是主动定时探测，还是被动通过的请求调用，只要请求的结果返回正常，那么就需要重置计数器恢复到 <code>closed</code> 状态。</p>
<p>一般而言会支持两种熔断策略：</p>
<ul>
<li><strong>错误比率</strong>：熔断时间窗口内的请求数阈值错误率大于错误率阈值，从而触发熔断。</li>
<li><strong>平均 RT（响应时间）</strong>：熔断时间窗口内的请求数阈值大于平均 RT 阈值，从而触发熔断。</li>
</ul>
<p>比如我们使用 hystrix-go 来处理我们的服务接口的熔断，可以结合我们上面说的重试从而进一步保障我们的服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">hystrix.ConfigureCommand(<span class="hljs-string">&quot;my_service&quot;</span>, hystrix.CommandConfig&#123; <br>        ErrorPercentThreshold:  <span class="hljs-number">30</span>,<br>    &#125;)<br>    _ = hystrix.Do(<span class="hljs-string">&quot;my_service&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123; <br>       req, _ := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;http://localhost:8090/&quot;</span>, strings.NewReader(<span class="hljs-string">&quot;test&quot;</span>))<br>        _, err := retryDo(req, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>*time.Millisecond, ExponentialBackoff)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;get error:%v&quot;</span>,err)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;handle  error:%v\n&quot;</span>, err)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;) <br></code></pre></td></tr></table></figure>

<p>上面这个例子中就利用 hystrix-go 设置了最大错误百分比等于30，超过这个阈值就会进行熔断。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从接口调用出发，探究了重试的几个要点，讲解了重试的几种策略；然后在实践环节中讲解了直接使用 <code>net/http</code>重试会有什么问题，对于对冲策略使用 channel 加上 waitgroup 来实现并发请求控制；最后使用 <code>hystrix-go</code> 来对故障服务进行熔断，防止请求堆积引起资源耗尽的问题。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/sethgrid/pester">https://github.com/sethgrid/pester</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.cn/post/6844904105354199047">https://juejin.cn/post/6844904105354199047</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/ma6174/blog/issues/11">https://github.com/ma6174/blog/issues/11</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/cn/blogs/architecture/exponential-backoff-and-jitter/">https://aws.amazon.com/cn/blogs/architecture/exponential-backoff-and-jitter/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6">https://medium.com/@trongdan_tran/circuit-breaker-and-retry-64830e71d0f6</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.lixueduan.com/post/grpc/09-retry/">https://www.lixueduan.com/post/grpc/09-retry/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Thundering_herd_problem">https://en.wikipedia.org/wiki/Thundering_herd_problem</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://go-zero.dev/cn/docs/blog/governance/breaker-algorithms/">https://go-zero.dev/cn/docs/blog/governance/breaker-algorithms/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://sre.google/sre-book/handling-overload/#eq2101">https://sre.google/sre-book/handling-overload/#eq2101</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://sentinelguard.io/zh-cn/docs/golang/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/golang/circuit-breaking.html</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000039978117">https://segmentfault.com/a/1190000039978117</a></p>

                
              </div>
            
            <hr>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/golang/" class="category-chain-item">golang</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%BD%AC%E8%BD%BD/">#转载</a>
      
        <a href="/tags/golang/">#golang</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>在Go中如何正确重试请求?</div>
      <div>https://blog.longpi1.com/2022/12/29/在Go中如何正确重试请求/</div>
    </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/31/Golang%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83/" title="Golang代码安全规范">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang代码安全规范</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/18/Golang%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" title="Golang接口的底层实现">
                        <span class="hidden-mobile">Golang接口的底层实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </article></div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"UvaCwj6C0pVj9XCWuMtLaBWJ-gzGzoHsz","appKey":"w2xUk9wycItSqrREmRMDYJHY","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>






  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div>lp的个人博客 | 记录成长的过程</div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    

    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script>
  <link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css">

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script>
<script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script>
<script src="/js/events.js"></script>
<script src="/js/plugins.js"></script>


  <script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script src="/js/img-lazyload.js"></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js"></script>

  <script src="/js/local-search.js"></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script src="/js/boot.js"></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
