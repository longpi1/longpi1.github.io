

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme="auto">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E5%AD%A6%E6%A0%A1.png">
  <link rel="icon" href="/img/%E5%AD%A6%E6%A0%A1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="lp">
  <meta name="keywords" content>
  
    <meta name="description" content="深入了解 Go 单元测试类型及项目测试实战">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 代码测试（下）：深入 Go 单元测试类型及项目测试实战">
<meta property="og:url" content="https://blog.longpi1.com/2022/11/30/Go%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5Go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="lp&#39;s blog">
<meta property="og:description" content="深入了解 Go 单元测试类型及项目测试实战">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/d8/93/d8ae5e99fe1d159e9b3ba1f815b24693.png?wh=540x374">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/e7/9c/e72102362e2ae3225e868f125654689c.jpg?wh=1920x1210">
<meta property="article:published_time" content="2022-11-30T12:24:56.000Z">
<meta property="article:modified_time" content="2022-11-30T12:49:23.579Z">
<meta property="article:author" content="lp">
<meta property="article:tag" content="原创">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/d8/93/d8ae5e99fe1d159e9b3ba1f815b24693.png?wh=540x374">
  
  
  
  <title>Go 代码测试（下）：深入 Go 单元测试类型及项目测试实战 - lp&#39;s blog</title>

  <link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css">



  <link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link rel="stylesheet" href="/css/main.css">


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css">
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css">
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.longpi1.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":30,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"UvaCwj6C0pVj9XCWuMtLaBWJ-gzGzoHsz","app_key":"w2xUk9wycItSqrREmRMDYJHY","server_url":"https://uvacwj6c.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>lp&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                文章分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax="true" style="background: url('/img/bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Go 代码测试（下）：深入 Go 单元测试类型及项目测试实战"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-30 20:24" pubdate>
          2022年11月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>


    <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/longpi1"><img loading="lazy" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" srcset="/img/loading.gif" lazyload class="attachment-full size-full" alt="follow me on GitHub" data-recalc-dims="1"></a>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Go 代码测试（下）：深入 Go 单元测试类型及项目测试实战</h1>
            
            
              <div class="markdown-body">
                
                 <meta name="referrer" content="no-referrer">
# Go 代码测试（下）：深入Go 单元测试类型及项目测试实战

<blockquote>
<p>本文章主要内容引用自：1.孔令飞，<a target="_blank" rel="external nofollow noopener noreferrer" href="https://time.geekbang.org/column/article/410205">Go 语言项目开发实战</a>  </p>
</blockquote>
<p>这一篇文章将主要介绍Go 语言中的其他测试类型：<strong>示例测试、TestMain函数、Mock测试、Fake测试</strong>等，并且介绍下IAM项目是如何编写和运行测试用例的。</p>
<h2 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h2><p>示例测试以 <code>Example</code> 开头，没有输入和返回参数，通常保存在 <code>example_test.go</code> 文件中。示例测试可能包含以 <code>Output:</code> 或者 <code>Unordered output:</code> 开头的注释，这些注释放在函数的结尾部分。 <code>Unordered output:</code> 开头的注释会忽略输出行的顺序。</p>
<p>执行 <code>go test</code> 命令时，会执行这些示例测试，并且go test会将示例测试输出到标准输出的内容，跟注释作对比（比较时将忽略行前后的空格）。如果相等，则示例测试通过测试；如果不相等，则示例测试不通过测试。下面是一个示例测试（位于example_test.go文件中）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleMax</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(Max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>    <span class="hljs-comment">// Output:</span><br>    <span class="hljs-comment">// 2</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行go test命令，测试 <code>ExampleMax</code> 示例测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -v -run=<span class="hljs-string">&#x27;Example.*&#x27;</span><br>=== RUN   ExampleMax<br>--- PASS: ExampleMax (0.00s)<br>PASS<br>ok      github.com/marmotedu/gopractise-demo/31/test    0.004s<br><br></code></pre></td></tr></table></figure>

<p>可以看到 <code>ExampleMax</code> 测试通过。这里测试通过是因为 <code>fmt.Println(Max(1, 2))</code> 向标准输出输出了 <code>2</code>，跟 <code>// Output:</code> 后面的 <code>2</code> 一致。</p>
<p>当示例测试不包含 <code>Output:</code> 或者 <code>Unordered output:</code> 注释时，执行 <code>go test</code> 只会编译这些函数，但不会执行这些函数。</p>
<h3 id="示例测试命名规范"><a href="#示例测试命名规范" class="headerlink" title="示例测试命名规范"></a>示例测试命名规范</h3><p>示例测试需要遵循一些命名规范，因为只有这样，Godoc才能将示例测试和包级别的标识符进行关联。例如，有以下示例测试（位于example_test.go文件中）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> stringutil_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/golang/example/stringutil&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleReverse</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(stringutil.Reverse(<span class="hljs-string">&quot;hello&quot;</span>))<br>    <span class="hljs-comment">// Output: olleh</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Godoc将在 <code>Reverse</code> 函数的文档旁边提供此示例，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/93/d8ae5e99fe1d159e9b3ba1f815b24693.png?wh=540x374" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>示例测试名以 <code>Example</code> 开头，后面可以不跟任何字符串，也可以跟函数名、类型名或者 <code>类型_方法名</code>，中间用下划线 <code>_</code> 连接，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Example</span><span class="hljs-params">()</span></span> &#123; ... &#125; <span class="hljs-comment">// 代表了整个包的示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleF</span><span class="hljs-params">()</span></span> &#123; ... &#125; <span class="hljs-comment">// 函数F的示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleT</span><span class="hljs-params">()</span></span> &#123; ... &#125; <span class="hljs-comment">// 类型T的示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleT_M</span><span class="hljs-params">()</span></span> &#123; ... &#125; <span class="hljs-comment">// 方法T_M的示例</span><br><br></code></pre></td></tr></table></figure>

<p>当某个函数&#x2F;类型&#x2F;方法有多个示例测试时，可以通过后缀来区分，后缀必须以小写字母开头，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleReverse</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleReverse_second</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleReverse_third</span><span class="hljs-params">()</span></span><br><br></code></pre></td></tr></table></figure>

<h3 id="大型示例"><a href="#大型示例" class="headerlink" title="大型示例"></a>大型示例</h3><p>有时候，我们需要编写一个大型的示例测试，这时候我们可以编写一个整文件的示例（whole file example），它有这几个特点：文件名以 <code>_test.go</code> 结尾；只包含一个示例测试，文件中没有单元测试函数和性能测试函数；至少包含一个包级别的声明；当展示这类示例测试时，godoc会直接展示整个文件。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s: %d&quot;</span>, p.Name, p.Age)<br>&#125;<br><br><span class="hljs-comment">// ByAge implements sort.Interface for []Person based on</span><br><span class="hljs-comment">// the Age field.</span><br><span class="hljs-keyword">type</span> ByAge []Person<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByAge)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(a) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByAge)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByAge)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i].Age &lt; a[j].Age &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Example</span><span class="hljs-params">()</span></span> &#123;<br>    people := []Person&#123;<br>        &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">31</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">42</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-number">17</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Jenny&quot;</span>, <span class="hljs-number">26</span>&#125;,<br>    &#125;<br><br>    fmt.Println(people)<br>    sort.Sort(ByAge(people))<br>    fmt.Println(people)<br><br>    <span class="hljs-comment">// Output:</span><br>    <span class="hljs-comment">// [Bob: 31 John: 42 Michael: 17 Jenny: 26]</span><br>    <span class="hljs-comment">// [Michael: 17 Jenny: 26 Bob: 31 John: 42]</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>一个包可以包含多个whole file example，一个示例一个文件，例如 <code>example_interface_test.go</code>、 <code>example_keys_test.go</code>、 <code>example_search_test.go</code> 等。</p>
<h2 id="TestMain函数"><a href="#TestMain函数" class="headerlink" title="TestMain函数"></a>TestMain函数</h2><p>有时候，我们在做测试的时候，可能会在测试之前做些准备工作，例如创建数据库连接等；在测试之后做些清理工作，例如关闭数据库连接、清理测试文件等。这时，我们可以在 <code>_test.go</code> 文件中添加 <code>TestMain</code> 函数，其入参为 <code>*testing.M</code>。</p>
<p><code>TestMain</code> 是一个特殊的函数（相当于main函数），测试用例在执行时，会先执行 <code>TestMain</code> 函数，然后可以在 <code>TestMain</code> 中调用 <code>m.Run()</code> 函数执行普通的测试函数。在 <code>m.Run()</code> 函数前面我们可以编写准备逻辑，在 <code>m.Run()</code> 后面我们可以编写清理逻辑。</p>
<p>我们在示例测试文件 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/gopractise-demo/blob/master/test/math_test.go">math_test.go</a> 中添加如下TestMain函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;do some setup&quot;</span>)<br>    m.Run()<br>    fmt.Println(<span class="hljs-string">&quot;do some cleanup&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行go test，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -v<br><span class="hljs-keyword">do</span> some setup<br>=== RUN   TestAbs<br>--- PASS: TestAbs (0.00s)<br>...<br>=== RUN   ExampleMax<br>--- PASS: ExampleMax (0.00s)<br>PASS<br><span class="hljs-keyword">do</span> some cleanup<br>ok  	github.com/marmotedu/gopractise-demo/31/test	0.006s<br><br></code></pre></td></tr></table></figure>

<p>在执行测试用例之前，打印了 <code>do some setup</code>，在测试用例运行完成之后，打印了 <code>do some cleanup</code>。</p>
<p>IAM项目的测试用例中，使用TestMain函数在执行测试用例前连接了一个fake数据库，代码如下（位于 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/user_test.go">internal&#x2F;apiserver&#x2F;service&#x2F;v1&#x2F;user_test.go</a> 文件中）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br>    fakeStore, _ := fake.NewFakeStore()<br>    store.SetClient(fakeStore)<br>    os.Exit(m.Run())<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>单元测试、性能测试、示例测试、TestMain函数是go test支持的测试类型。此外，为了测试在函数内使用了Go Interface的函数，我们还延伸出了Mock测试和Fake测试两种测试类型。</p>
<h2 id="Mock测试"><a href="#Mock测试" class="headerlink" title="Mock测试"></a>Mock测试</h2><p>一般来说，单元测试中是不允许有外部依赖的，那么也就是说，这些外部依赖都需要被模拟。在Go中，一般会借助各类Mock工具来模拟一些依赖。</p>
<p>GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其他的测试环境中。GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包用来完成对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件。下面，我来分别详细介绍下GoMock包和mockgen工具，以及它们的使用方法。</p>
<h3 id="安装GoMock"><a href="#安装GoMock" class="headerlink" title="安装GoMock"></a>安装GoMock</h3><p>要使用GoMock，首先需要安装GoMock包和mockgen工具，安装方法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go get github.com/golang/mock/gomock<br>$ go install github.com/golang/mock/mockgen<br><br></code></pre></td></tr></table></figure>

<p>下面，我通过一个 <strong>获取当前Golang最新版本的例子</strong>，来给你演示下如何使用GoMock。示例代码目录结构如下（目录下的代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/gopractise-demo/tree/master/gomock">gomock</a>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree .<br>.<br>├── go_version.go<br>├── main.go<br>└── spider<br>    └── spider.go<br><br></code></pre></td></tr></table></figure>

<p><code>spider.go</code> 文件中定义了一个 <code>Spider</code> 接口， <code>spider.go</code> 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> spider<br><br><span class="hljs-keyword">type</span> Spider <span class="hljs-keyword">interface</span> &#123;<br>    GetBody() <span class="hljs-type">string</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>Spider</code> 接口中的GetBody方法可以抓取 <code>https://golang.org</code> 首页的 <code>Build version</code> 字段，来获取Golang的最新版本。</p>
<p>我们在 <code>go_version.go</code> 文件中，调用 <code>Spider</code> 接口的 <code>GetBody</code> 方法， <code>go_version.go</code> 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gomock<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/marmotedu/gopractise-demo/gomock/spider&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGoVersion</span><span class="hljs-params">(s spider.Spider)</span></span> <span class="hljs-type">string</span> &#123;<br>    body := s.GetBody()<br>    <span class="hljs-keyword">return</span> body<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>GetGoVersion</code> 函数直接返回表示版本的字符串。正常情况下，我们会写出如下的单元测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetGoVersion</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    v := GetGoVersion(spider.CreateGoVersionSpider())<br>    <span class="hljs-keyword">if</span> v != <span class="hljs-string">&quot;go1.8.3&quot;</span> &#123;<br>        t.Error(<span class="hljs-string">&quot;Get wrong version %s&quot;</span>, v)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面的测试代码，依赖 <code>spider.CreateGoVersionSpider()</code> 返回一个实现了 <code>Spider</code> 接口的实例（爬虫）。但很多时候， <code>spider.CreateGoVersionSpider()</code> 爬虫可能还没有实现，或者在单元测试环境下不能运行（比如，在单元测试环境中连接数据库），这时候 <code>TestGetGoVersion</code> 测试用例就无法执行。</p>
<p>那么，如何才能在这种情况下运行 <code>TestGetGoVersion</code> 测试用例呢？这时候，我们就可以通过Mock工具，Mock一个爬虫实例。接下来我讲讲具体操作。</p>
<p>首先，用 GoMock 提供的mockgen工具，生成要 Mock 的接口的实现，我们在gomock目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mockgen -destination spider/mock/mock_spider.go -package spider github.com/marmotedu/gopractise-demo/gomock/spider Spider<br><br></code></pre></td></tr></table></figure>

<p>上面的命令会在 <code>spider/mock</code> 目录下生成 <code>mock_spider.go</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree .<br>.<br>├── go_version.go<br>├── go_version_test.go<br>├── go_version_test_traditional_method.go~<br>└── spider<br>    ├── mock<br>    │   └── mock_spider.go<br>    └── spider.go<br><br></code></pre></td></tr></table></figure>

<p><code>mock_spider.go</code> 文件中，定义了一些函数&#x2F;方法，可以支持我们编写 <code>TestGetGoVersion</code> 测试函数。这时候，我们的单元测试代码如下（见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/gopractise-demo/blob/master/gomock/go_version_test.go">go_version_test.go</a> 文件）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gomock<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;testing&quot;</span><br><br>	<span class="hljs-string">&quot;github.com/golang/mock/gomock&quot;</span><br><br>	spider <span class="hljs-string">&quot;github.com/marmotedu/gopractise-demo/gomock/spider/mock&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetGoVersion</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	ctrl := gomock.NewController(t)<br>	<span class="hljs-keyword">defer</span> ctrl.Finish()<br><br>	mockSpider := spider.NewMockSpider(ctrl)<br>	mockSpider.EXPECT().GetBody().Return(<span class="hljs-string">&quot;go1.8.3&quot;</span>)<br>	goVer := GetGoVersion(mockSpider)<br><br>	<span class="hljs-keyword">if</span> goVer != <span class="hljs-string">&quot;go1.8.3&quot;</span> &#123;<br>		t.Errorf(<span class="hljs-string">&quot;Get wrong version %s&quot;</span>, goVer)<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这一版本的 <code>TestGetGoVersion</code> 通过GoMock， Mock了一个 <code>Spider</code> 接口，而不用去实现一个 <code>Spider</code> 接口。这就大大降低了单元测试用例编写的复杂度。通过Mock，很多不能测试的函数也变得可测试了。</p>
<p>通过上面的测试用例，我们可以看到，GoMock 和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://time.geekbang.org/column/article/408529">上一讲</a> 介绍的testing单元测试框架可以紧密地结合起来工作。</p>
<h3 id="mockgen工具介绍"><a href="#mockgen工具介绍" class="headerlink" title="mockgen工具介绍"></a>mockgen工具介绍</h3><p>上面，我介绍了如何使用 GoMock 编写单元测试用例。其中，我们使用到了 <code>mockgen</code> 工具来生成 Mock代码， <code>mockgen</code> 工具提供了很多有用的功能，这里我来详细介绍下。</p>
<p><code>mockgen</code> 工具是 GoMock 提供的，用来Mock一个Go接口。它可以根据给定的接口，来自动生成Mock代码。这里，有两种模式可以生成Mock代码，分别是源码模式和反射模式。</p>
<ol>
<li>源码模式</li>
</ol>
<p>如果有接口文件，则可以通过以下命令来生成Mock代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mockgen -destination spider/mock/mock_spider.go -package spider -<span class="hljs-built_in">source</span> spider/spider.go<br><br></code></pre></td></tr></table></figure>

<p>上面的命令，Mock了 <code>spider/spider.go</code> 文件中定义的 <code>Spider</code> 接口，并将Mock代码保存在 <code>spider/mock/mock_spider.go</code> 文件中，文件的包名为 <code>spider</code>。</p>
<p>mockgen工具的参数说明见下表：</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/9c/e72102362e2ae3225e868f125654689c.jpg?wh=1920x1210" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>反射模式</li>
</ol>
<p>此外，mockgen工具还支持通过使用反射程序来生成 Mock 代码。它通过传递两个非标志参数，即导入路径和逗号分隔的接口列表来启用，其他参数和源码模式共用，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mockgen -destination spider/mock/mock_spider.go -package spider github.com/marmotedu/gopractise-demo/gomock/spider Spider<br><br></code></pre></td></tr></table></figure>

<h3 id="通过注释使用mockgen"><a href="#通过注释使用mockgen" class="headerlink" title="通过注释使用mockgen"></a>通过注释使用mockgen</h3><p>如果有多个文件，并且分散在不同的位置，那么我们要生成Mock文件的时候，需要对每个文件执行多次mockgen命令（这里假设包名不相同）。这种操作还是比较繁琐的，mockgen还提供了一种通过注释生成Mock文件的方式，此时需要借助 <code>go generate</code> 工具。</p>
<p>在接口文件的代码中，添加以下注释（具体代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/gopractise-demo/blob/master/gomock/spider/spider.go#L3">spider.go</a> 文件）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:generate mockgen -destination mock_spider.go -package spider github.com/cz-it/blog/blog/Go/testing/gomock/example/spider Spider</span><br><br></code></pre></td></tr></table></figure>

<p>这时候，我们只需要在 <code>gomock</code> 目录下，执行以下命令，就可以自动生成Mock代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go generate ./...<br><br></code></pre></td></tr></table></figure>

<h3 id="使用Mock代码编写单元测试用例"><a href="#使用Mock代码编写单元测试用例" class="headerlink" title="使用Mock代码编写单元测试用例"></a>使用Mock代码编写单元测试用例</h3><p>生成了Mock代码之后，我们就可以使用它们了。这里我们结合 <code>testing</code> 来编写一个使用了Mock代码的单元测试用例。</p>
<p><strong>首先，</strong> 需要在单元测试代码里创建一个Mock控制器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ctrl := gomock.NewController(t)<br><br></code></pre></td></tr></table></figure>

<p>将 <code>*testing.T</code> 传递给GoMock ，生成一个 <code>Controller</code> 对象，该对象控制了整个Mock的过程。在操作完后，还需要进行回收，所以一般会在 <code>NewController</code> 后面defer一个Finish，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> ctrl.Finish()<br><br></code></pre></td></tr></table></figure>

<p><strong>然后，</strong> 就可以调用Mock的对象了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockSpider := spider.NewMockSpider(ctrl)<br><br></code></pre></td></tr></table></figure>

<p>这里的 <code>spider</code> 是mockgen命令里面传递的包名，后面是 <code>NewMockXxxx</code> 格式的对象创建函数， <code>Xxx</code> 是接口名。这里，我们需要传递控制器对象进去，返回一个Mock实例。</p>
<p><strong>接着，</strong> 有了Mock实例，我们就可以调用其断言方法 <code>EXPECT()</code> 了。</p>
<p>gomock采用了链式调用法，通过 <code>.</code> 连接函数调用，可以像链条一样连接下去。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockSpider.EXPECT().GetBody().Return(<span class="hljs-string">&quot;go1.8.3&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>Mock一个接口的方法，我们需要Mock该方法的入参和返回值。我们可以通过参数匹配来Mock入参，通过Mock实例的 <code>Return</code> 方法来Mock返回值。下面，我们来分别看下如何指定入参和返回值。</p>
<p>先来看如何指定入参。如果函数有参数，我们可以使用参数匹配来指代函数的参数，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockSpider.EXPECT().GetBody(gomock.Any(), gomock.Eq(<span class="hljs-string">&quot;admin&quot;</span>)).Return(<span class="hljs-string">&quot;go1.8.3&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>gomock支持以下参数匹配：</p>
<ul>
<li>gomock.Any()，可以用来表示任意的入参。</li>
<li>gomock.Eq(value)，用来表示与 value 等价的值。</li>
<li>gomock.Not(value)，用来表示非 value 以外的值。</li>
<li>gomock.Nil()，用来表示 None 值。</li>
</ul>
<p>接下来，我们看如何指定返回值。</p>
<p><code>EXPECT()</code> 得到Mock的实例，然后调用Mock实例的方法，该方法返回第一个 <code>Call</code> 对象，然后可以对其进行条件约束，比如使用Mock实例的 <code>Return</code> 方法约束其返回值。 <code>Call</code> 对象还提供了以下方法来约束Mock实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> After(preReq *Call) *Call <span class="hljs-comment">// After声明调用在preReq完成后执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> AnyTimes() *Call <span class="hljs-comment">// 允许调用次数为 0 次或更多次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> Do(f <span class="hljs-keyword">interface</span>&#123;&#125;) *Call <span class="hljs-comment">// 声明在匹配时要运行的操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> MaxTimes(n <span class="hljs-type">int</span>) *Call <span class="hljs-comment">// 设置最大的调用次数为 n 次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> MinTimes(n <span class="hljs-type">int</span>) *Call <span class="hljs-comment">// 设置最小的调用次数为 n 次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> Return(rets ...<span class="hljs-keyword">interface</span>&#123;&#125;) *Call <span class="hljs-comment">//  // 声明模拟函数调用返回的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> SetArg(n <span class="hljs-type">int</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;) *Call <span class="hljs-comment">// 声明使用指针设置第 n 个参数的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Call)</span></span> Times(n <span class="hljs-type">int</span>) *Call <span class="hljs-comment">// 设置调用次数为 n 次</span><br><br></code></pre></td></tr></table></figure>

<p>上面列出了多个 <code>Call</code> 对象提供的约束方法，接下来我会介绍3个常用的约束方法：指定返回值、指定执行次数和指定执行顺序。</p>
<ol>
<li>指定返回值</li>
</ol>
<p>我们可以提供调用 <code>Call</code> 的 <code>Return</code> 函数，来指定接口的返回值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockSpider.EXPECT().GetBody().Return(<span class="hljs-string">&quot;go1.8.3&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<ol>
<li>指定执行次数</li>
</ol>
<p>有时候，我们需要指定函数执行多少次，例如：对于接受网络请求的函数，计算其执行了多少次。我们可以通过 <code>Call</code> 的 <code>Times</code> 函数来指定执行次数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockSpider.EXPECT().Recv().Return(<span class="hljs-literal">nil</span>).Times(<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure>

<p>上述代码，执行了三次Recv函数，这里gomock还支持其他的执行次数限制：</p>
<ul>
<li>AnyTimes()，表示执行0到多次。</li>
<li>MaxTimes(n int)，表示如果没有设置，最多执行n次。</li>
<li>MinTimes(n int)，表示如果没有设置，最少执行n次。</li>
</ul>
<ol>
<li>指定执行顺序</li>
</ol>
<p>有时候，我们还要指定执行顺序，比如要先执行 Init 操作，然后才能执行Recv操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">initCall := mockSpider.EXPECT().Init()<br>mockSpider.EXPECT().Recv().After(initCall)<br><br></code></pre></td></tr></table></figure>

<p>最后，我们可以使用 <code>go test</code> 来测试使用了Mock代码的单元测试代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -v<br>=== RUN   TestGetGoVersion<br>--- PASS: TestGetGoVersion (0.00s)<br>PASS<br>ok  	github.com/marmotedu/gopractise-demo/gomock	0.002s<br><br></code></pre></td></tr></table></figure>

<h2 id="Fake测试"><a href="#Fake测试" class="headerlink" title="Fake测试"></a>Fake测试</h2><p>在Go项目开发中，对于比较复杂的接口，我们还可以Fake一个接口实现，来进行测试。所谓Fake测试，其实就是针对接口实现一个假（fake）的实例。至于如何实现Fake实例，需要你根据业务自行实现。例如：IAM项目中iam-apiserver组件就实现了一个fake store，代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/tree/v1.0.8/internal/apiserver/store/fake">fake</a> 目录。接下来基于IAM项目测试实战部分介绍</p>
<h2 id="IAM项目测试实战"><a href="#IAM项目测试实战" class="headerlink" title="IAM项目测试实战"></a>IAM项目测试实战</h2><h3 id="IAM项目是如何运行测试用例的？"><a href="#IAM项目是如何运行测试用例的？" class="headerlink" title="IAM项目是如何运行测试用例的？"></a>IAM项目是如何运行测试用例的？</h3><p>首先，我们来看下IAM项目是如何执行测试用例的。</p>
<p>在IAM项目的源码根目录下，可以通过运行 <code>make test</code> 执行测试用例， <code>make test</code> 会执行 <code>iam/scripts/make-rules/golang.mk</code> 文件中的 <code>go.test</code> 伪目标，规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: go.test</span><br><span class="hljs-section">go.test: tools.verify.go-junit-report</span><br>  @echo <span class="hljs-string">&quot;===========&gt; Run unit test&quot;</span><br>  @set -o pipefail;<span class="hljs-variable">$(GO)</span> test -race -cover -coverprofile=<span class="hljs-variable">$(OUTPUT_DIR)</span>/coverage.out \\<br>    -timeout=10m -short -v `go list ./...|\<br>    egrep -v <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(SPACE)</span>,&#x27;|&#x27;,$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(EXCLUDE_TESTS)</span>)</span>)` 2&gt;&amp;1 | \\<br>    tee &gt;(go-junit-report --set-exit-code &gt;<span class="hljs-variable">$(OUTPUT_DIR)</span>/report.xml)<br>  @sed -i &#x27;/mock_.*.go/d&#x27; <span class="hljs-variable">$(OUTPUT_DIR)</span>/coverage.out <span class="hljs-comment"># remove mock_.*.go files from test coverage</span><br>  @<span class="hljs-variable">$(GO)</span> tool cover -html=<span class="hljs-variable">$(OUTPUT_DIR)</span>/coverage.out -o <span class="hljs-variable">$(OUTPUT_DIR)</span>/coverage.html<br><br></code></pre></td></tr></table></figure>

<p>在上述规则中，我们执行 <code>go test</code> 时设置了超时时间、竞态检查，开启了代码覆盖率检查，覆盖率测试数据保存在了 <code>coverage.out</code> 文件中。在Go项目开发中，并不是所有的包都需要单元测试，所以上面的命令还过滤掉了一些不需要测试的包，这些包配置在 <code>EXCLUDE_TESTS</code> 变量中：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">EXCLUDE_TESTS=github.com/marmotedu/iam/test github.com/marmotedu/iam/pkg/log github.com/marmotedu/iam/third_party github.com/marmotedu/iam/internal/pump/storage github.com/marmotedu/iam/internal/pump github.com/marmotedu/iam/internal/pkg/logger<br><br></code></pre></td></tr></table></figure>

<p>同时，也调用了 <code>go-junit-report</code> 将go test的结果转化成了xml格式的报告文件，该报告文件会被一些CI系统，例如Jenkins拿来解析并展示结果。上述代码也同时生成了coverage.html文件，该文件可以存放在制品库中，供我们后期分析查看。</p>
<p>这里需要注意，Mock的代码是不需要编写测试用例的，为了避免影响项目的单元测试覆盖率，需要将Mock代码的单元测试覆盖率数据从 <code>coverage.out</code> 文件中删除掉， <code>go.test</code> 规则通过以下命令删除这些无用的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;/mock_.*.go/d&#x27;</span> $(OUTPUT_DIR)/coverage.out <span class="hljs-comment"># remove mock_.*.go files from test coverage</span><br><br></code></pre></td></tr></table></figure>

<p>另外，还可以通过 <code>make cover</code> 来进行单元测试覆盖率测试， <code>make cover</code> 会执行 <code>iam/scripts/make-rules/golang.mk</code> 文件中的 <code>go.test.cover</code> 伪目标，规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: go.test.cover</span><br><span class="hljs-section">go.test.cover: go.test</span><br>  @<span class="hljs-variable">$(GO)</span> tool cover -func=<span class="hljs-variable">$(OUTPUT_DIR)</span>/coverage.out | \\<br>    awk -v target=<span class="hljs-variable">$(COVERAGE)</span> -f <span class="hljs-variable">$(ROOT_DIR)</span>/scripts/coverage.awk<br><br></code></pre></td></tr></table></figure>

<p>上述目标依赖 <code>go.test</code>，也就是说执行单元测试覆盖率目标之前，会先进行单元测试，然后使用单元测试产生的覆盖率数据 <code>coverage.out</code> 计算出总的单元测试覆盖率，这里是通过 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/scripts/coverage.awk">coverage.awk</a> 脚本来计算的。</p>
<p>如果单元测试覆盖率不达标，Makefile会报错并退出。可以通过Makefile的 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/master/scripts/make-rules/common.mk#L39-L41">COVERAGE</a> 变量来设置单元测试覆盖率阈值。</p>
<p>COVERAGE的默认值为60，我们也可以在命令行手动指定，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make cover COVERAGE=80<br><br></code></pre></td></tr></table></figure>

<p>为了确保项目的单元测试覆盖率达标，需要设置单元测试覆盖率质量红线。一般来说，这些红线很难靠开发者的自觉性去保障，所以好的方法是将质量红线加入到CICD流程中。</p>
<p>所以，在 <code>Makefile</code> 文件中，我将 <code>cover</code> 放在 <code>all</code> 目标的依赖中，并且位于build之前，也就是 <code>all: gen add-copyright format lint cover build</code>。这样每次当我们执行make时，会自动进行代码测试，并计算单元测试覆盖率，如果覆盖率不达标，则停止构建；如果达标，继续进入下一步的构建流程。</p>
<h3 id="IAM项目测试案例分享"><a href="#IAM项目测试案例分享" class="headerlink" title="IAM项目测试案例分享"></a>IAM项目测试案例分享</h3><ol>
<li>单元测试案例</li>
</ol>
<p>我们可以手动编写单元测试代码，也可以使用gotests工具生成单元测试代码。</p>
<p>先来看手动编写测试代码的案例。这里单元测试代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/pkg/log/log_test.go#L52-L62">Test_Option</a>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_Option</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    fs := pflag.NewFlagSet(<span class="hljs-string">&quot;test&quot;</span>, pflag.ExitOnError)<br>    opt := log.NewOptions()<br>    opt.AddFlags(fs)<br><br>    args := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;--log.level=debug&quot;</span>&#125;<br>    err := fs.Parse(args)<br>    assert.Nil(t, err)<br><br>    assert.Equal(t, <span class="hljs-string">&quot;debug&quot;</span>, opt.Level)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上述代码中，使用了 <code>github.com/stretchr/testify/assert</code> 包来对比结果。</p>
<p>再来看使用gotests工具生成单元测试代码的案例（Table-Driven 的测试模式）。出于效率上的考虑，IAM项目的单元测试用例，基本都是使用gotests工具生成测试用例模板代码，并基于这些模板代码填充测试Case的。代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/service_test.go">service_test.go</a> 文件。</p>
<ol>
<li>性能测试案例</li>
</ol>
<p>IAM项目的性能测试用例，见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/user_test.go#L27-L41">BenchmarkListUser</a> 测试函数。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkListUser</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>	opts := metav1.ListOptions&#123;<br>		Offset: pointer.ToInt64(<span class="hljs-number">0</span>),<br>		Limit:  pointer.ToInt64(<span class="hljs-number">50</span>),<br>	&#125;<br>	storeIns, _ := fake.GetFakeFactoryOr()<br>	u := &amp;userService&#123;<br>		store: storeIns,<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>		_, _ = u.List(context.TODO(), opts)<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li>示例测试案例</li>
</ol>
<p>IAM项目的示例测试用例见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/errors/blob/v1.0.2/example_test.go">example_test.go</a> 文件。 <code>example_test.go</code> 中的一个示例测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleNew</span><span class="hljs-params">()</span></span> &#123;<br>	err := New(<span class="hljs-string">&quot;whoops&quot;</span>)<br>	fmt.Println(err)<br><br>	<span class="hljs-comment">// Output: whoops</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li>TestMain测试案例</li>
</ol>
<p>IAM项目的TestMain测试案例，见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/user_test.go">user_test.go</a> 文件中的 <code>TestMain</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br>    _, _ = fake.GetFakeFactoryOr()<br>    os.Exit(m.Run())<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>TestMain</code> 函数初始化了fake Factory，然后调用 <code>m.Run</code> 执行测试用例。</p>
<ol>
<li>Mock测试案例</li>
</ol>
<p>Mock代码见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/mock_service.go">internal&#x2F;apiserver&#x2F;service&#x2F;v1&#x2F;mock_service.go</a>，使用Mock的测试用例见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/controller/v1/user/create_test.go">internal&#x2F;apiserver&#x2F;controller&#x2F;v1&#x2F;user&#x2F;create_test.go</a> 文件。因为代码比较多，这里建议你打开链接，查看测试用例的具体实现。</p>
<p>我们可以在IAM项目的根目录下执行以下命令，来自动生成所有的Mock文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go generate ./...<br><br></code></pre></td></tr></table></figure>

<ol>
<li>Fake测试案例</li>
</ol>
<p>fake store代码实现位于 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/tree/v1.0.8/internal/apiserver/store/fake">internal&#x2F;apiserver&#x2F;store&#x2F;fake</a> 目录下。fake store的使用方式，见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/service/v1/user_test.go">user_test.go</a> 文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span> &#123;<br>    _, _ = fake.GetFakeFactoryOr()<br>    os.Exit(m.Run())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkListUser</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    opts := metav1.ListOptions&#123;<br>        Offset: pointer.ToInt64(<span class="hljs-number">0</span>),<br>        Limit:  pointer.ToInt64(<span class="hljs-number">50</span>),<br>    &#125;<br>    storeIns, _ := fake.GetFakeFactoryOr()<br>    u := &amp;userService&#123;<br>        store: storeIns,<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        _, _ = u.List(context.TODO(), opts)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上述代码通过 <code>TestMain</code> 初始化fake实例（ <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/marmotedu/iam/blob/v1.0.8/internal/apiserver/store/store.go#L12-L17">store.Factory</a> 接口类型）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFakeFactoryOr</span><span class="hljs-params">()</span></span> (store.Factory, <span class="hljs-type">error</span>) &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fakeFactory = &amp;datastore&#123;<br>            users:    FakeUsers(ResourceCount),<br>            secrets:  FakeSecrets(ResourceCount),<br>            policies: FakePolicies(ResourceCount),<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> fakeFactory == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to get mysql store fatory, mysqlFactory: %+v&quot;</span>, fakeFactory)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fakeFactory, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>GetFakeFactoryOr</code> 函数，创建了一些fake users、secrets、policies，并保存在了 <code>fakeFactory</code> 变量中，供后面的测试用例使用，例如BenchmarkListUser、Test_newUsers等。</p>
<h2 id="其他测试工具-x2F-包"><a href="#其他测试工具-x2F-包" class="headerlink" title="其他测试工具&#x2F;包"></a>其他测试工具&#x2F;包</h2><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/stretchr/testify">Testify框架</a>：Testify是Go test的预判工具，它能让你的测试代码变得更优雅和高效，测试结果也变得更详细。</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/smartystreets/goconvey">GoConvey框架</a>：GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。</li>
</ul>
<h3 id="Mock工具"><a href="#Mock工具" class="headerlink" title="Mock工具"></a>Mock工具</h3><p>这篇文章介绍了Go官方提供的Mock框架GoMock，不过还有一些其他的优秀Mock工具可供我们使用。这些Mock工具分别用在不同的Mock场景中</p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a>：可以用来模拟数据库连接。数据库是项目中比较常见的依赖，在遇到数据库依赖时都可以用它。</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jarcoal/httpmock">httpmock</a>：可以用来Mock HTTP请求。</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/bouk/monkey">bouk&#x2F;monkey</a>：猴子补丁，能够通过替换函数指针的方式来修改任意函数的实现。如果golang&#x2F;mock、sqlmock和httpmock这几种方法都不能满足我们的需求，我们可以尝试用猴子补丁的方式来Mock依赖。可以这么说，猴子补丁提供了单元测试 Mock 依赖的最终解决方案。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇文章介绍了除单元测试和性能测试之外的另一些测试方法。</p>
<p>除了示例测试和TestMain函数，我还详细介绍了Mock测试，也就是如何使用GoMock来测试一些在单元测试环境下不好实现的接口。绝大部分情况下，可以使用GoMock来Mock接口，但是对于一些业务逻辑比较复杂的接口，我们可以通过Fake一个接口实现，来对代码进行测试，这也称为Fake测试。</p>
<p>除此之外，我们还可以使用其他一些测试框架，例如Testify框架和GoConvey框架。在Go代码测试中，我们最常使用的是Go官方提供的Mock框架GoMock，但仍然有其他优秀的Mock工具，可供我们在不同场景下使用，例如sqlmock、httpmock、bouk&#x2F;monkey等。</p>

                
              </div>
            
            <hr>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/golang/" class="category-chain-item">golang</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a>
      
        <a href="/tags/golang/">#golang</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Go 代码测试（下）：深入 Go 单元测试类型及项目测试实战</div>
      <div>https://blog.longpi1.com/2022/11/30/Go代码测试（下）：深入Go单元测试类型及项目测试实战/</div>
    </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/30/Go%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99Go%E8%AF%AD%E8%A8%80%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%9F/" title="Go 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？">
                        <span class="hidden-mobile">Go 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </article></div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"UvaCwj6C0pVj9XCWuMtLaBWJ-gzGzoHsz","appKey":"w2xUk9wycItSqrREmRMDYJHY","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>






  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div>lp的个人博客 | 记录成长的过程</div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    

    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script>
  <link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css">

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script>
<script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script>
<script src="/js/events.js"></script>
<script src="/js/plugins.js"></script>


  <script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script src="/js/img-lazyload.js"></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js"></script>

  <script src="/js/local-search.js"></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script src="/js/boot.js"></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
