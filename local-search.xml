<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang内存分配和垃圾回收</title>
    <link href="/2022/08/27/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/08/27/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang内存管理和垃圾回收"><a href="#Golang内存管理和垃圾回收" class="headerlink" title="Golang内存管理和垃圾回收"></a>Golang内存管理和垃圾回收</h1><p>现代高级编程语言管理内存的方式分自动和手动两种。手动管理内存的典型代表是C和C++，编写代码过程中需要主动申请或者释放内存；而PHP、Java 和Go等语言使用自动的内存管理系统，由内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。今天腾讯后台开发工程师汪汇向大家分享 Golang 垃圾回收算法。（当然，Rust 是另一种）</p><p>从Go v1.12版本开始，Go使用了<strong>非分代的、并发的、基于三色标记清除的垃圾回收器</strong>。相关标记清除算法可以参考C&#x2F;C++，而Go是一种静态类型的编译型语言。因此，Go不需要VM，Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime)，可以处理诸如垃圾收集(GC)、调度和并发之类的语言功能。首先让我们看一下Go内部的内存管理是什么样子的。</p><h2 id="一、-Golang内存管理"><a href="#一、-Golang内存管理" class="headerlink" title="一、 Golang内存管理"></a><strong>一、 Golang内存管理</strong></h2><p>这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。</p><ul><li>G: Goroutine 执行的上下文环境。</li><li>M: 操作系统线程。</li><li>P: Processer。进程调度的关键，调度器，也可以认为约等于CPU。</li></ul><p>一个 Goroutine 的运行需要G+P+M三部分结合起来。</p><p><img src="https://s2.loli.net/2022/08/27/7LdYiPGBaJrCpgf.jpg" alt="内存管理.jpg"></p><p> 图源：《Golang—内存管理(内存分配)》</p><p>(<a href="http://t.zoukankan.com/zpcoding-p-13259943.html">http://t.zoukankan.com/zpcoding-p-13259943.html</a>)</p><h3 id="（一）TCMalloc"><a href="#（一）TCMalloc" class="headerlink" title="（一）TCMalloc"></a><strong>（一）TCMalloc</strong></h3><p>Go将内存划分和分组为页（Page），这和Java的内存结构完全不同，没有分代内存，这样的原因是Go的内存分配器采用了TCMalloc的<strong>设计思想</strong>：</p><h4 id="1-Page"><a href="#1-Page" class="headerlink" title="1.Page"></a><strong>1.Page</strong></h4><p>与TCMalloc中的Page相同，x64下1个Page的大小是8KB。上图的最下方，1个浅蓝色的长方形代表1个Page。</p><h4 id="2-Span"><a href="#2-Span" class="headerlink" title="2.Span"></a><strong>2.Span</strong></h4><p>与TCMalloc中的Span相同，Span是内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。</p><h4 id="3-mcache"><a href="#3-mcache" class="headerlink" title="3.mcache"></a><strong>3.mcache</strong></h4><p>mcache是提供给P（逻辑处理器）的高速缓存，用于存储小对象（对象大小&lt;&#x3D; 32Kb）。尽管这类似于线程堆栈，但它是堆的一部分，用于动态数据。所有类大小的mcache包含scan和noscan类型mspan。Goroutine可以从mcache没有任何锁的情况下获取内存，因为一次P只能有一个锁G。因此，这更有效。mcache从mcentral需要时请求新的span。</p><h4 id="4-mcentral"><a href="#4-mcentral" class="headerlink" title="4.mcentral"></a><strong>4.mcentral</strong></h4><p>mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。每个mcentral包含两个mspanList：</p><ul><li>empty：双向span链表，包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时，它将被移至non-empty span链表。</li><li>non-empty：有空闲对象的span双向链表。当从mcentral请求新的span，mcentral将从该链表中获取span并将其移入empty span链表。</li></ul><h4 id="5-mheap"><a href="#5-mheap" class="headerlink" title="5.mheap"></a><strong>5.mheap</strong></h4><p>mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，也是垃圾回收的重点区域，把从OS申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。</p><h4 id="6-栈"><a href="#6-栈" class="headerlink" title="6.栈"></a><strong>6.栈</strong></h4><p>这是栈存储区，每个Goroutine（G）有一个栈。在这里存储了静态数据，包括函数栈帧，静态结构，原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事。</p><h3 id="（二）内存分配"><a href="#（二）内存分配" class="headerlink" title="（二）内存分配"></a><strong>（二）内存分配</strong></h3><p>Go 中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。</p><p><strong>核心思想</strong>：把内存分为多级管理，降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型，减少分配产生的内存碎片。</p><ul><li>*<em>*微小对象(Tiny)（size&lt;16B*</em>*<em>）*</em>*</li></ul><p>使用mcache的微小分配器分配小于16个字节的对象，并且在单个16字节块上可完成多个微小分配。</p><ul><li><em><strong>*小对象（尺寸16B〜32KB）*</strong></em></li></ul><p>大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache的对应的mspan size class上。</p><ul><li><em><strong>*大对象（大小&gt;32KB）*</strong></em></li></ul><p>大于32 KB的对象直接分配在mheap的相应大小类上(size class)。</p><ul><li>如果mheap为空或没有足够大的页面满足分配请求，则它将从操作系统中分配一组新的页（至少1MB）。</li><li>如果对应的大小规格在mcache中没有可用的块，则向mcentral申请。</li><li>如果mcentral中没有可用的块，则向mheap申请，并根据BestFit 算法找到最合适的mspan。如果申请到的mspan超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表。</li><li>如果mheap中没有可用span，则向操作系统申请一系列新的页（最小 1MB）。Go 会在操作系统分配超大的页（称作arena）。分配一大批页会减少和操作系统通信的成本。</li></ul><h3 id="（三）内存回收"><a href="#（三）内存回收" class="headerlink" title="（三）内存回收"></a><strong>（三）内存回收</strong></h3><p>go内存会分成堆区（Heap）和栈区（Stack）两个部分，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁。如果只申请和分配内存，内存终将枯竭。Go使用垃圾回收收集不再使用的span，把span释放交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配。<strong>因此，Go堆是Go垃圾收集器管理的主要区域</strong>。</p><h2 id="二、常见的GC算法"><a href="#二、常见的GC算法" class="headerlink" title="二、常见的GC算法"></a>二、常见的GC算法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。</p><ul><li>优点：简单直接，回收速度快</li><li>缺点：需要额外的空间存放计数，无法处理循环引用的情况；</li></ul><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/mark_clean.png" alt="mark_clean"></p><ul><li>优点：简单直接，速度快，适合可回收对象不多的场景</li><li>缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配；</li></ul><h3 id="复制法"><a href="#复制法" class="headerlink" title="复制法"></a>复制法</h3><p>复制法将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/copy_method.png" alt="copy_method"></p><ul><li>优点：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；</li><li>缺点：有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；</li></ul><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/mark_tidy.png" alt="mark_tidy"></p><ul><li>优点：解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用；</li><li>缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；</li></ul><h3 id="分代式"><a href="#分代式" class="headerlink" title="分代式"></a>分代式</h3><p>将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p><h3 id="Golang的垃圾回收（GC）算法"><a href="#Golang的垃圾回收（GC）算法" class="headerlink" title="Golang的垃圾回收（GC）算法"></a>Golang的垃圾回收（GC）算法</h3><p>Golang的垃圾回收（GC）算法使用的是无无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：</p><ul><li>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于<code>tcmalloc</code>，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于<code>tcmalloc</code>的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。</li><li>分代<code>GC</code>依赖分代假设，即<code>GC</code>将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。</li><li>Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代<code>GC</code>回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当<code>goroutine</code>死亡后栈也会被直接回收，不需要<code>GC</code>的参与，进而分代假设并没有带来直接优势。</li><li>Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。</li></ul><h2 id="三、三色可达性分析"><a href="#三、三色可达性分析" class="headerlink" title="三、三色可达性分析"></a><strong>三、三色可达性分析</strong></h2><p>为了解决标记清除算法带来的STW问题，Go和Java都会实现三色可达性分析标记算法的变种以缩短STW的时间。三色可达性分析标记算法按“是否被访问过”将程序中的对象分成白色、黑色和灰色：</p><ul><li><strong>白色对象 — 对象尚未被垃圾收集器访问过，在可达性分析刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍然是白色的对象，即代表不可达。</strong></li><li><strong>黑色对象 — 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过，黑色的对象代表已经被扫描过而且是安全存活的，如果有其他对象只想黑色对象无需再扫描一遍，黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</strong></li><li><strong>灰色对象 — 表示对象已经被垃圾收集器访问过，但是这个对象上至少存在一个引用还没有被扫描过，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。</strong></li></ul><p>三色可达性分析算法大致的流程是（初始状态所有对象都是白色）：</p><p><strong>1.从GC Roots开始枚举，它们所有的直接引用变为灰色（移入灰色集合），GC Roots变为黑色。</strong></p><p><strong>2.从灰色集合中取出一个灰色对象进行分析：</strong></p><ul><li><strong>将这个对象所有的直接引用变为灰色，放入灰色集合中；</strong></li><li><strong>将这个对象变为黑色。</strong></li></ul><p><strong>3.重复步骤2，一直重复直到灰色集合为空。</strong></p><p><strong>4.分析完成，仍然是白色的对象就是GC Roots不可达的对象，可以作为垃圾被清理。</strong></p><p>具体例子如下图所示，经过三色可达性分析，最后白色H为不可达的对象，是需要垃圾回收的对象。</p><p>三色标记清除算法本身是不可以并发或者增量执行的，<strong>它需要STW</strong>，<strong>而如果并发执行，用户程序可能在标记执行的过程中修改对象的指针。</strong></p><h3 id="没有STW的异常情况一般会有2种："><a href="#没有STW的异常情况一般会有2种：" class="headerlink" title="没有STW的异常情况一般会有2种："></a><strong>没有STW的异常情况一般会有2种：</strong></h3><p>1.一种是把原本应该垃圾回收的死亡对象错误的标记为存活。虽然这不好，但是不会导致严重后果，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以，比如上图所示的三色标记过程中，用户程序取消了从B对象到E对象的引用，但是因为B到E已经被标记完成不会继续执行步骤2，所以E对象最终会被错误的标记成黑色，不会被回收，这个D就是浮动垃圾，会在下次垃圾收集中清理。</p><p>2.一种是把原本存活的对象错误的标记为已死亡，导致“对象消失”，这在内存管理中是非常严重的错误。比如上图所示的三色标记过程中，用户程序建立了从B对象到H对象的引用(例如<strong>B.next &#x3D;H</strong>)，接着执行<strong>D.next&#x3D;nil</strong>，但是因为B到H中不存在灰色对象，因此在这之间不会继续执行三色并发标记中的步骤2，D到H之间的链接被断开，所以H对象最终会被标记成白色，会被垃圾收集器错误地回收。我们将这种错误称为<strong>悬挂指针</strong>，即指针没有指向特定类型的合法对象，影响了内存的安全性。</p><h3 id="没有STW的三色标记法情况下-—-悬挂指针"><a href="#没有STW的三色标记法情况下-—-悬挂指针" class="headerlink" title="没有STW的三色标记法情况下  — 悬挂指针"></a>没有STW的三色标记法情况下  — 悬挂指针</h3><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？<br>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>1.我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_1.png" alt="no_STW_1"></p><p>2.现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_2.png" alt="no_STW_2"></p><ol start="3"><li>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</li></ol><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_3.png" alt="no_STW_3"></p><p>4.然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。<img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_4.png" alt="no_STW_4"></p><p>5.那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_5.png" alt="no_STW_5"><br>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p><strong>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</strong></p><ul><li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**<br>如果当以上两个条件同时满足时，就会出现对象丢失现象!</li></ul><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="四、屏障技术"><a href="#四、屏障技术" class="headerlink" title="四、屏障技术"></a><strong>四、屏障技术</strong></h2><p>为了解决上述的“对象消失”的现象，Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>因此为了我们要解决并发扫描时的对象消失问题，保证垃圾收集算法的正确性，只需破坏这两个条件的任意一个即可，<strong>屏障技术</strong>就是在并发或者增量标记过程中保证<strong>三色不变性</strong>的重要技术。</p><p>内存屏障技术是一种屏障指令，它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性</p><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“ 弱三色不变式”。</p><h4 id="1-“强-弱”-三色不变式"><a href="#1-“强-弱”-三色不变式" class="headerlink" title="(1) “强-弱” 三色不变式"></a>(1) “强-弱” 三色不变式</h4><ul><li>强三色不变式</li></ul><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>弱三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><ul><li>弱三色不变式</li></ul><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们<strong>“插入屏障”, “删除屏障”</strong>。</p><p><strong>插入屏障：</strong></p><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p><strong>删除屏障：</strong></p><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p><h3 id="（一）插入写屏障"><a href="#（一）插入写屏障" class="headerlink" title="（一）插入写屏障"></a><strong>（一）插入写屏障</strong></h3><p>Dijkstra在1978年提出了插入写屏障，也被叫做增量更新，通过如下所示的写屏障，破坏上述第一个条件（赋值器插入了一条或多条从黑色对象到白色对象的新引用）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) <br>     shade(ptr)  <span class="hljs-regexp">//</span>先将新下游对象 ptr 标记为灰色<br>     *slot = ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>说明：<br>添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; <br> <span class="hljs-regexp">//</span>step <span class="hljs-number">1</span><br> 标记灰色(新下游对象ptr) <br> <br> <span class="hljs-regexp">//</span>step <span class="hljs-number">2</span><br> 当前下游对象slot = 新下游对象ptr <br>&#125;<br><br><span class="hljs-regexp">//</span>场景：<br>A.添加下游对象(nil, B) <span class="hljs-regexp">//</span>A 之前没有下游， 新添加一个下游对象B， B被标记为灰色<br>A.添加下游对象(C, B) <span class="hljs-regexp">//</span>A 将下游对象C 更换为B， B被标记为灰色<br></code></pre></td></tr></table></figure><p>上述伪代码非常好理解，当黑色对象（slot）插入新的指向白色对象（ptr）的引用关系时，就尝试使用shade函数将这个新插入的引用（ptr）标记为灰色。</p><p><img src="https://s2.loli.net/2022/08/27/UoewBdHDpjbL2SP.png" alt="640 (1).png"></p><p>假设我们上图的例子并发可达性分析中使用插入写屏障：</p><p>1.GC 将根对象Root2指向的B对象标记成黑色并将B对象指向的对象D标记成灰色；</p><p>2.用户程序修改指针，<strong>B.next&#x3D;H</strong>这时触发写屏障将H对象标记成灰色；</p><p>3.用户程序修改指针<strong>D.next&#x3D;null</strong>；</p><p>4.GC依次遍历程序中的H和D将它们分别标记成黑色。</p><h3 id="关于栈没有写屏障的原因"><a href="#关于栈没有写屏障的原因" class="headerlink" title="关于栈没有写屏障的原因"></a>关于栈没有写屏障的原因</h3><p> 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p><p><strong>由于栈上的对象在垃圾回收中被认为是根对象，并没有写屏障，那么导致黑色的栈可能指向白色的堆对象，例如上图1中Root2指向H，且删除了由D指向H的引用，由于没有写屏障，那么H将会被删除。为了保障内存安全，Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之前做出权衡。</strong></p><p>​接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>​但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p>​最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h3 id="（二）删除写屏障"><a href="#（二）删除写屏障" class="headerlink" title="（二）删除写屏障"></a><strong>（二）删除写屏障</strong></h3><p>Yuasa在1990年的论文Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达。起始时STW扫描所有的goroutine栈，保证所有堆上在用的对象都处于灰色保护下，所以也被称作快照垃圾收集（Snapshot GC），这是破坏了“对象消失”的第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 黑色赋值器 Yuasa 屏障<br><span class="hljs-keyword">func</span> YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123;<br>    shade(*slot) 先将*slot标记为灰色<br>    *slot = ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>说明：<br>添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;<br>  <span class="hljs-regexp">//</span>step <span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;<br>          标记灰色(当前下游对象slot)     <span class="hljs-regexp">//</span>slot为被删除对象， 标记为灰色<br>  &#125;  <br>  <span class="hljs-regexp">//</span>step <span class="hljs-number">2</span><br>  当前下游对象slot = 新下游对象ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>场景<br>A.添加下游对象(B, nil)   <span class="hljs-regexp">//</span>A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)<br>A.添加下游对象(B, C)     <span class="hljs-regexp">//</span>A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)<br></code></pre></td></tr></table></figure><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p>但是这样也会导致一个问题，由于会将<strong>有存活可能的对象都标记成灰色</strong>，因此最后可能会导致应该回收的对象未被回收，这个对象只有在下一个循环才会被回收，比如下图的D对象。</p><p><img src="https://s2.loli.net/2022/08/27/JvYdRCk4QPyqrLO.png" alt="640.png"></p><p><strong>由于原始快照的原因，起始也是执行STW，删除写屏障不适用于栈特别大的场景，栈越大，STW扫描时间越长。</strong></p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_1.png" alt="delete_barrier_1"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_2.png" alt="delete_barrier_2"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_3.png" alt="delete_barrier_3"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_4.png" alt="delete_barrier_4"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_5.png" alt="delete_barrier_5"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_6.png" alt="delete_barrier_6"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_7.png" alt="delete_barrier_7"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><p><img src="C:\Users\longp\AppData\Roaming\Typora\typora-user-images\image-20220821132611515.png" alt="image-20220821132611515"></p><h3 id="（三）混合写屏障"><a href="#（三）混合写屏障" class="headerlink" title="（三）混合写屏障"></a><strong>（三）混合写屏障</strong></h3><p>在 Go 语言 v1.7版本之前，运行时会使用Dijkstra插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个Goroutine的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在v1.8结合上述2种写屏障构成了混合写屏障，实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描。</p><p>Go 语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">writePointer</span><span class="hljs-params">(slot, ptr)</span></span>:<br>    <span class="hljs-built_in">shade</span>(*slot)<br>    <span class="hljs-keyword">if</span> current stack is grey:<br>        <span class="hljs-built_in">shade</span>(ptr)<br>    *slot = ptr<br></code></pre></td></tr></table></figure><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。总结来说主要有这几点：</p><ul><li>GC开始将栈上的对象全部扫描并标记为黑色；</li><li>GC期间，任何在栈上创建的新对象，均为黑色；</li><li>被删除的堆对象标记为灰色；</li><li>被添加的堆对象标记为灰色。</li></ul><p><strong>插入写屏障和删除写屏障的短板：</strong></p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li></ul><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><hr><h4 id="1-混合写屏障规则"><a href="#1-混合写屏障规则" class="headerlink" title="(1) 混合写屏障规则"></a>(1) 混合写屏障规则</h4><p><code>具体操作</code>:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p><code>满足</code>: 变形的<strong>弱三色不变式</strong>.</p><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;<br>  <span class="hljs-comment">//1 </span><br>标记灰色(当前下游对象slot)    <span class="hljs-comment">//只要当前下游对象被移走，就标记灰色</span><br>  <br>  <span class="hljs-comment">//2 </span><br>  标记灰色(新下游对象ptr)<br>  <br>  <span class="hljs-comment">//3</span><br>  当前下游对象slot = 新下游对象ptr<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><h4 id="2-混合写屏障的具体场景分析"><a href="#2-混合写屏障的具体场景分析" class="headerlink" title="(2) 混合写屏障的具体场景分析"></a>(2) 混合写屏障的具体场景分析</h4><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><h5 id="GC开始：扫描栈区，将可达对象全部标记为黑"><a href="#GC开始：扫描栈区，将可达对象全部标记为黑" class="headerlink" title="GC开始：扫描栈区，将可达对象全部标记为黑"></a>GC开始：扫描栈区，将可达对象全部标记为黑</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><h5 id="场景一：-对象被一个堆对象删除引用，成为栈对象的下游"><a href="#场景一：-对象被一个堆对象删除引用，成为栈对象的下游" class="headerlink" title="场景一： 对象被一个堆对象删除引用，成为栈对象的下游"></a>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span><br>栈对象<span class="hljs-number">1</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；  <span class="hljs-comment">//将堆对象7 挂在 栈对象1 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；    <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景二：-对象被一个栈对象删除引用，成为另一个栈对象的下游"><a href="#场景二：-对象被一个栈对象删除引用，成为另一个栈对象的下游" class="headerlink" title="场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游"></a>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span> 栈对象<span class="hljs-number">9</span>；<br>对象<span class="hljs-number">8</span>-&gt;对象<span class="hljs-number">3</span> = 对象<span class="hljs-number">3</span>；      <span class="hljs-comment">//将栈对象3 挂在 栈对象9 下游</span><br>对象<span class="hljs-number">2</span>-&gt;对象<span class="hljs-number">3</span> = null；      <span class="hljs-comment">//对象2 删除引用 对象3</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"><a href="#场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"></a>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"><a href="#场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"></a>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>​Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><h2 id="五、GC演进过程"><a href="#五、GC演进过程" class="headerlink" title="五、GC演进过程"></a><strong>五、GC演进过程</strong></h2><p>v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；</p><p>v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段；</p><p>v1.3 — 运行时<strong>基于只有指针类型的值包含指针</strong>的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集；将unsafe.Pointer类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；</p><p>v1.5 — 实现了基于<strong>三色标记清扫的并发</strong>垃圾收集器：</p><ul><li>大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下；</li><li>计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；</li></ul><p>v1.6 — 实现了去中心化的垃圾收集协调器：</p><ul><li>基于显式的状态机使得任意Goroutine都能触发垃圾收集的状态迁移；</li><li>使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的CPU占用;</li></ul><p>v1.7 — 通过<strong>并行栈收缩</strong>将垃圾收集的时间缩短至2ms以内；</p><p>v1.8 — 使用<strong>混合写屏障</strong>将垃圾收集的时间缩短至0.5ms以内；</p><p>v1.9 — 彻底移除暂停程序的重新扫描栈的过程；</p><p>v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标；</p><p>v1.12 — 使用<strong>新的标记终止算法</strong>简化垃圾收集器的几个阶段；</p><p>v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题；</p><p>v1.14 — 使用全新的页分配器<strong>优化内存分配的速度</strong>；</p><p>v1.15 — 改进编译器和运行时内部的CL 226367，它使编译器可以将更多的x86寄存器用于垃圾收集器的写屏障调用；</p><p>v1.16 — Go runtime默认使用MADV_DONTNEED更积极的将不用的内存释放给OS。</p><h2 id="六、GC过程"><a href="#六、GC过程" class="headerlink" title="六、GC过程"></a><strong>六、GC过程</strong></h2><p>Golang GC 相关的代码在<strong>runtime&#x2F;mgc.go</strong>文件下，可以看见GC总共分为4个阶段(翻译自Golang v1.16版本源码)：</p><p><strong>1.sweep termination（清理终止）</strong></p><ul><li><p>暂停程序，触发STW。所有的P（处理器）都会进入safe-point（安全点）；</p></li><li><p>清理未被清理的 span 。如果当前垃圾收集是强制触发的，需要处理还未被清理的内存管理单元；</p></li></ul><p><strong>2.the mark phase（标记阶段）</strong></p><ul><li>将<strong>GC状态gcphase从_GCoff改成_GCmark</strong>、开启写屏障、启用协助线程（mutator assists）、将根对象入队；</li><li>恢复程序执行，标记进程（mark workers）和协助程序会开始并发标记内存中的对象，写屏障会覆盖的重写指针和新指针（标记成灰色），而所有新创建的对象都会被直接标记成黑色；</li><li>GC执行根节点的标记，这包括扫描所有的栈、全局对象以及不在堆中的运行时数据结构。扫描goroutine栈会导致goroutine停止，并对栈上找到的所有指针加置灰，然后继续执行goroutine；</li><li>GC遍历灰色对象队列，会将灰色对象变成黑色，并将该指针指向的对象置灰；</li><li>由于GC工作分布在本地缓存中，GC会使用分布式终止算法（distributed termination algorithm）来检测何时不再有根标记作业或灰色对象，如果没有了GC会转为mark termination（标记终止）。</li></ul><p><strong>3. mark termination（标记终止）</strong></p><ul><li>STW；</li><li>将GC状态gcphase切换至_GCmarktermination，关闭gc工作线程和协助程序；</li><li>执行housekeeping，例如刷新mcaches。</li></ul><p><strong>4. the sweep phase（清理阶段）</strong></p><ul><li>将GC状态gcphase切换至_GCoff来准备清理阶段，初始化清理阶段并关闭写屏障；</li><li>恢复用户程序，从现在开始，所有新创建的对象会标记成白色；如果有必要，在使用前分配清理spans；</li><li>后台并发清理所有的内存管理类单元。</li></ul><p><strong>GC过程代码示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcfinished</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>  p := <span class="hljs-number">1</span><br>  runtime.SetFinalizer(&amp;p, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;gc finished&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> &amp;p<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span></span> &#123;<br>  _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-type">int</span>((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)*<span class="hljs-number">0.25</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  f, _ := os.Create(<span class="hljs-string">&quot;trace.out&quot;</span>)<br>  <span class="hljs-keyword">defer</span> f.Close()<br>  trace.Start(f)<br>  <span class="hljs-keyword">defer</span> trace.Stop()<br>  gcfinished()<br>  <span class="hljs-comment">// 当完成 GC 时停止分配</span><br>  <span class="hljs-keyword">for</span> n := <span class="hljs-number">1</span>; n &lt; <span class="hljs-number">50</span>; n++ &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;#allocate: &quot;</span>, n)<br>    allocate()<br>  &#125;<br>  <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;terminate&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">hewittwang@HEWITTWANG-MB0 rtx % <span class="hljs-attr">GODEBUG=</span><span class="hljs-attr">gctrace=</span><span class="hljs-number">1</span> go run new1.go  <br>gc <span class="hljs-number">1</span> @<span class="hljs-number">0.015s</span> <span class="hljs-number">0</span>%: <span class="hljs-number">0.015</span>+<span class="hljs-number">0.36</span>+<span class="hljs-number">0.043</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span>, <span class="hljs-number">0.18</span>+<span class="hljs-number">0.55</span>/<span class="hljs-number">0.64</span>/<span class="hljs-number">0.13</span>+<span class="hljs-number">0.52</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span>, <span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB, <span class="hljs-number">5</span> MB goal, <span class="hljs-number">12</span> P<br>gc <span class="hljs-number">2</span> @<span class="hljs-number">0.024s</span> <span class="hljs-number">1</span>%: <span class="hljs-number">0.045</span>+<span class="hljs-number">0.19</span>+<span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span>, <span class="hljs-number">0.54</span>+<span class="hljs-number">0.37</span>/<span class="hljs-number">0.31</span>/<span class="hljs-number">0.041</span>+<span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span>, <span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB, <span class="hljs-number">5</span> MB goal, <span class="hljs-number">12</span> P<br>....<br></code></pre></td></tr></table></figure><p>栈分析</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">gc <span class="hljs-number">2</span>      : 第一个GC周期<br>@<span class="hljs-number">0.024s</span>   : 从程序开始运行到第一次GC时间为<span class="hljs-number">0.024</span> 秒<br><span class="hljs-number">1</span>%        : 此次GC过程中CPU 占用率<br><br>wall clock<br><span class="hljs-number">0.045</span>+<span class="hljs-number">0.19</span>+<span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span><br><span class="hljs-number">0.045</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: STW</span>，Marking <span class="hljs-literal">Start</span>, 开启写屏障<br><span class="hljs-number">0.19</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: Marking</span>阶段<br><span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: STW</span>，Marking终止，关闭写屏障<br><br>CPU time<br><span class="hljs-number">0.54</span>+<span class="hljs-number">0.37</span>/<span class="hljs-number">0.31</span>/<span class="hljs-number">0.041</span>+<span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span><br><span class="hljs-number">0.54</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: STW</span>，Marking <span class="hljs-literal">Start</span><br><span class="hljs-number">0.37</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: 辅助标记时间</span><br><span class="hljs-title">0</span>.<span class="hljs-number">31</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: 并发标记时间</span><br><span class="hljs-title">0</span>.<span class="hljs-number">041</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: GC</span> 空闲时间<br><span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: Mark</span> 终止时间<br><br><span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB， <span class="hljs-number">5</span> MB goal<br><span class="hljs-number">4</span> MB      ：标记开始时，堆大小实际值<br><span class="hljs-number">4</span> MB      ：标记结束时，堆大小实际值<br><span class="hljs-number">0</span> MB      ：标记结束时，标记为存活对象大小<br><span class="hljs-number">5</span> MB      ：标记结束时，堆大小预测值<br><br><span class="hljs-number">12</span> P      ：本次GC过程中使用的goroutine 数量<br></code></pre></td></tr></table></figure><h2 id="七、GC触发条件"><a href="#七、GC触发条件" class="headerlink" title="七、GC触发条件"></a><strong>七、GC触发条件</strong></h2><p>运行时会通过runtime.gcTrigger.test方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件（即满足_GCoff阶段的退出条件）时——允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//mgc.go 文件 runtime.gcTrigger.test</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t gcTrigger)</span></span> test() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">//测试是否满足触发垃圾手机的基本条件</span><br>    <span class="hljs-keyword">if</span> !memstats.enablegc || panicking != <span class="hljs-number">0</span> || gcphase != _GCoff &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">switch</span> t.kind &#123;<br>      <span class="hljs-keyword">case</span> gcTriggerHeap:    <span class="hljs-comment">//堆内存的分配达到达控制器计算的触发堆大小</span><br>         <span class="hljs-comment">// Non-atomic access to gcController.heapLive for performance. If</span><br>         <span class="hljs-comment">// we are going to trigger on this, this thread just</span><br>         <span class="hljs-comment">// atomically wrote gcController.heapLive anyway and we&#x27;ll see our</span><br>         <span class="hljs-comment">// own write.</span><br>         <span class="hljs-keyword">return</span> gcController.heapLive &gt;= gcController.trigger<br>      <span class="hljs-keyword">case</span> gcTriggerTime:      <span class="hljs-comment">//如果一定时间内没有触发，就会触发新的循环，该出发条件由 `runtime.forcegcperiod`变量控制，默认为 2 分钟；</span><br>         <span class="hljs-keyword">if</span> gcController.gcPercent &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>         lastgc := <span class="hljs-type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))<br>         <span class="hljs-keyword">return</span> lastgc != <span class="hljs-number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod<br>      <span class="hljs-keyword">case</span> gcTriggerCycle:      <span class="hljs-comment">//如果当前没有开启垃圾收集，则触发新的循环；</span><br>         <span class="hljs-comment">// t.n &gt; work.cycles, but accounting for wraparound.</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-type">int32</span>(t.n-work.cycles) &gt; <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;<br></code></pre></td></tr></table></figure><p>用于开启垃圾回收的方法为runtime.gcStart，因此所有调用该函数的地方都是触发GC的代码：</p><ul><li>runtime.mallocgc申请内存时根据堆大小触发GC</li><li>runtime.GC用户程序手动触发GC</li><li>runtime.forcegchelper后台运行定时检查触发GC</li></ul><p><strong>（一）申请内存触发runtime.mallocgc</strong></p><p>Go运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的GC。</p><p>1.当前线程的内存管理单元中不存在空闲空间时，创建微对象(noscan &amp;&amp;size&lt;maxTinySize)和小对象需要调用 runtime.mcache.nextFree从中心缓存或者页堆中获取新的管理单元，这时如果span满了就会导致返回的shouldhelpgc&#x3D;true，就可能触发垃圾收集；</p><p>2.当用户程序申请分配32KB以上的大对象时，一定会构建 runtime.gcTrigger结构体尝试触发垃圾收集。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>, typ *_type, needzero <span class="hljs-type">bool</span>)</span></span> unsafe.Pointer &#123;<br>    省略代码 ...<br>    shouldhelpgc := <span class="hljs-literal">false</span>  <br>  dataSize := size<br>  c := getMCache()       <span class="hljs-comment">//尝试获取mCache。如果没启动或者没有P,返回nil；</span><br> <br>    省略代码 ...<br>    <span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;  <br>       <span class="hljs-keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123; <span class="hljs-comment">// 微对象分配</span><br>  省略代码 ...<br>          v := nextFreeFast(span)<br>          <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>             v, span, shouldhelpgc = c.nextFree(tinySpanClass)<br>          &#125;<br>      省略代码 ...<br>      &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//小对象分配</span><br>         省略代码 ...<br>          <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>             v, span, shouldhelpgc = c.nextFree(spc)<br>          &#125;<br>        省略代码 ...<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       shouldhelpgc = <span class="hljs-literal">true</span><br>       省略代码 ...<br>    &#125;<br>  省略代码 ...<br>    <span class="hljs-keyword">if</span> shouldhelpgc &#123;      <span class="hljs-comment">//是否应该触发gc</span><br>      <span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;   <span class="hljs-comment">//如果满足gc触发条件就调用gcStart()</span><br>          gcStart(t)<br>      &#125;<br>    &#125;<br>  省略代码 ...<br>    <span class="hljs-keyword">return</span> x<br> &#125;<br></code></pre></td></tr></table></figure><p>这个时候调用t.test()执行的是gcTriggerHeap情况，只需要判断gcController.heapLive &gt;&#x3D; gcController.trigger的真假就可以了。 heapLive表示垃圾收集中存活对象字节数，trigger表示触发标记的堆内存大小的；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。</p><p>1.heapLive — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；</p><p>2.trigger — 在标记终止阶段调用runtime.gcSetTriggerRatio更新触发下一次垃圾收集的堆大小，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集CPU利用率确定触发垃圾收集的时机。</p><p><strong>（二）手动触发runtime.GC</strong></p><p>用户程序会通过runtime.GC函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过STW暂停整个程序：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> GC() &#123;<br>    <span class="hljs-regexp">//</span>在正式开始垃圾收集前，运行时需要通过runtime.gcWaitOnMark等待上一个循环的标记终止、标记和清除终止阶段完成；<br>    n := atomic.Load(&amp;work.cycles)<br>    gcWaitOnMark(n)<br> <br>  <span class="hljs-regexp">//</span>调用 `runtime.gcStart` 触发新一轮的垃圾收集<br>    gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="hljs-number">1</span>&#125;)<br> <br>    <span class="hljs-regexp">//</span>`runtime.gcWaitOnMark` 等待该轮垃圾收集的标记终止阶段正常结束；<br>    gcWaitOnMark(n + <span class="hljs-number">1</span>)<br> <br>    <span class="hljs-regexp">//</span> 持续调用 `runtime.sweepone` 清理全部待处理的内存管理单元并等待所有的清理工作完成<br>    <span class="hljs-keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="hljs-number">1</span> &amp;&amp; sweepone() != ^uintptr(<span class="hljs-number">0</span>) &#123;<br>        sweep.nbgsweep++<br>        Gosched()  <span class="hljs-regexp">//</span>等待期间会调用 `runtime.Gosched` 让出处理器<br>    &#125;<br> <br>    <span class="hljs-regexp">//</span><br>    <span class="hljs-keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="hljs-number">1</span> &amp;&amp; !isSweepDone() &#123;<br>        Gosched()<br>    &#125;<br> <br>    <span class="hljs-regexp">//</span> 完成本轮垃圾收集的清理工作后，通过 `runtime.mProf_PostSweep` 将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态<br>    mp := acquirem()<br>    cycle := atomic.Load(&amp;work.cycles)<br>    <span class="hljs-keyword">if</span> cycle == n+<span class="hljs-number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="hljs-number">2</span>) &#123;   <span class="hljs-regexp">//</span>仅限于没有启动其他标记终止过程<br>        mProf_PostSweep()<br>    &#125;<br>    releasem(mp)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（三）后台运行定时检查触发runtime.forcegchelper</strong></p><p>运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的Goroutine，该Goroutine调用runtime.gcStart尝试启动新一轮的垃圾收集：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// start forcegc helper goroutine</span><br>func <span class="hljs-built_in">init</span>() &#123;<br>   go <span class="hljs-built_in">forcegchelper</span>()<br>&#125;<br> <br>func <span class="hljs-built_in">forcegchelper</span>() &#123;<br>   forcegc<span class="hljs-selector-class">.g</span> = <span class="hljs-built_in">getg</span>()<br>   <span class="hljs-built_in">lockInit</span>(&amp;forcegc<span class="hljs-selector-class">.lock</span>, lockRankForcegc)<br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-built_in">lock</span>(&amp;forcegc.lock)<br>      <span class="hljs-keyword">if</span> forcegc<span class="hljs-selector-class">.idle</span> != <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-built_in">throw</span>(<span class="hljs-string">&quot;forcegc: phase error&quot;</span>)<br>      &#125;<br>      atomic<span class="hljs-selector-class">.Store</span>(&amp;forcegc<span class="hljs-selector-class">.idle</span>, <span class="hljs-number">1</span>)<br>      <br>     <span class="hljs-comment">//该 Goroutine 会在循环中调用runtime.goparkunlock主动陷入休眠等待其他 Goroutine 的唤醒</span><br>      <span class="hljs-built_in">goparkunlock</span>(&amp;forcegc<span class="hljs-selector-class">.lock</span>, waitReasonForceGCIdle, traceEvGoBlock, <span class="hljs-number">1</span>)<br>       <br>      <span class="hljs-keyword">if</span> debug<span class="hljs-selector-class">.gctrace</span> &gt; <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;GC forced&quot;</span>)<br>      &#125;<br>      <span class="hljs-comment">// Time-triggered, fully concurrent.</span><br>      <span class="hljs-built_in">gcStart</span>(gcTrigger&#123;kind: gcTriggerTime, now: <span class="hljs-built_in">nanotime</span>()&#125;)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参考文献</strong></p><p>  1.《Go语言设计与实现》</p><p>(<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</a>)</p><p>  2.《一个专家眼中的Go与Java垃圾回收算法大对比》</p><p>(<a href="https://blog.csdn.net/u011277123/article/details/53991572">https://blog.csdn.net/u011277123/article/details/53991572</a>)</p><p>  3.《Go语言问题集》</p><p>(<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.19.GC-GC.md">https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.19.GC-GC.md</a>)</p><p>   4.《CMS垃圾收集器》</p><p>(<a href="https://juejin.cn/post/6844903782107578382">https://juejin.cn/post/6844903782107578382</a>)</p><p>  5.《Golang v 1.16版本源码》</p><p>(<a href="https://github.com/golang/go">https://github.com/golang/go</a>)</p><p>  6.《Golang—内存管理(内存分配)》</p><p>(<a href="http://t.zoukankan.com/zpcoding-p-13259943.html">http://t.zoukankan.com/zpcoding-p-13259943.html</a>)</p><p>   7.《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》—机械工业出版社</p><ol start="8"><li><a href="https://mp.weixin.qq.com/s/iAy9ReQhnmCYUFvwYroGPA">《腾讯妹子图解Golang内存分配和垃圾回收》</a></li><li><a href="https://www.yuque.com/aceld/golang/zhzanb">《Golang修养之路》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 网络基础</title>
    <link href="/2022/08/27/Kubernetes-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/08/27/Kubernetes-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-网络模型基础"><a href="#Kubernetes-网络模型基础" class="headerlink" title="Kubernetes 网络模型基础"></a>Kubernetes 网络模型基础</h1><p>github对应地址：<a href="https://github.com/longpi1/Reading-notes/blob/main/kuberneters/%E7%BD%91%E7%BB%9C/Kubernetes%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.md">https://github.com/longpi1/Reading-notes/blob/main/kuberneters/%E7%BD%91%E7%BB%9C/Kubernetes%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.md</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。</p><p><img src="https://s2.loli.net/2022/08/27/OlUZo4yNiTAPgmC.png" alt="网络模型.png"></p><p>网络是非常复杂的，拥有许多概念，对于不熟悉这个领域的用户来说，这可能会有一定的难度，这里面有很多概念需要理解，并且还需要把这些概念整合起来形成一个连贯的整体，比如网络命名空间、虚拟接口、IP 转发、NAT 等概念。</p><p>Kubernetes 中对任何网络实现都规定了以下的一些要求：</p><ul><li>所有 Pod 都可以在不使用 NAT 的情况下与所有其他 Pod 进行通信</li><li>所有节点都可以在没有 NAT 的情况下与所有 Pod 进行通信</li><li>Pod 自己的 IP 与其他 Pod 看到的 IP 是相同的</li></ul><p>鉴于这些限制，我们需要解决几个不同的网络问题：</p><ol><li>容器到容器的网络</li><li>Pod 到 Pod 的网络</li><li>Pod 到 Service 的网络</li><li>互联网到 Service 的网络</li></ol><p>接下来我们将来讨论这些问题及其解决方案。</p><h2 id="容器到容器网络"><a href="#容器到容器网络" class="headerlink" title="容器到容器网络"></a>容器到容器网络</h2><p>通常情况下我们将虚拟机中的网络通信视为直接与以太网设备进行交互，如图1所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgCV9T9zxQ7pfMHEiauW3V6z9TiaUIrm4TfdVibb5hNJMJO7OticAOK1v6Ng/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                <strong>图1.网络设备的理想视图</strong></p><p>实际的情况肯定比这要复杂，在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间提供了一个具有自己的路由、防火墙规则和网络设备的逻辑网络栈，从本质上讲，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。</p><p>Linux 用户可以使用 <code>ip</code> 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的网络命名空间。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$<span class="hljs-built_in"> ip </span>netns <span class="hljs-built_in">add</span> ns1 <br></code></pre></td></tr></table></figure><p>命名空间创建后，会在 <code>/var/run/netns</code> 下面为其创建一个挂载点，即使没有附加任何进程，命名空间也是可以保留的。</p><p>你可以通过列出 <code>/var/run/netns</code> 下的所有挂载点或使用 <code>ip</code> 命令来列出可用的命名空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/run/netns</span><br>ns1<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns</span><br>ns1<br></code></pre></td></tr></table></figure><p>默认情况下，Linux 将为每个进程分配到 root network namespace，以提供访问外部的能力，如图2所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgoTjJmceqShbEoZ6ibwMOA1VZOV2yYQmN6z9BovoSiafExusQt9dpyu0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                <strong>图2.root network namespace</strong></p><p>对于 Docker 而言，一个 Pod 会被构建成一组共享网络命名空间的 Docker 容器，Pod 中的容器都有相同的 IP 地址和端口空间，它们都是通过分配给 Pod 的网络命名空间来分配的，并且可以通过 localhost 访问彼此，因为它们位于同一个命名空间中。这是使用 Docker 作为 Pod 容器来实现的，它持有网络命名空间，而应用容器则通过 Docker 的 <code>-net=container:sandbox-container</code> 功能加入到该命名空间中，图3显示了每个 Pod 如何由共享网络命名空间内的多个 Docker 容器（<code>ctr*</code>）组成的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgx14N89bgPKjXwqTDV2ia9FbbLyLP2fGEvBrMUT5U4ibvq87nySmZ1xTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                               <strong>图3.每个 Pod 的网络命名空间</strong></p><p>此外 Pod 中的容器还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个容器的文件系统中。</p><h2 id="Pod-到-Pod-网络"><a href="#Pod-到-Pod-网络" class="headerlink" title="Pod 到 Pod 网络"></a>Pod 到 Pod 网络</h2><p>在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，每个 Pod 都使用该 IP 地址与其他 Pod 进行通信。接下来我们将来了解 Kubernetes 如何使用真实的 IP 来实现 Pod 与 Pod 之间的通信的。我们先来讨论同一节点上的 Pod 通信的方式。</p><p>从 Pod 的角度来看，它存在于自己的网络命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的时候，命名空间可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 <code>veth</code> 对进行连接，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的的一侧分配给 root network namespace，将另一侧分配给 Pod 的网络命名空间。每个 veth 对就像一根网线，连接两侧并允许流量在它们之间流动。这种设置可以复制到节点上的任意数量的 Pod。图4显示了连接虚拟机上每个 Pod 的 root network namespace 的 veth 对。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgiav7goAhdM2Fg40BpBNia6OmnP1yZJ0O2aD9ajK98r46EfkGxIfMYJzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                  <strong>图4.Pod 的 veth 对</strong></p><p>现在 Pod 都有自己的网络命名空间，这样它们就有自己的网络设备和 IP 地址，并且它们连接到节点的 root 命名空间，现在我们希望 Pod 能够通过 root 命名空间进行通信，那么我们将要使用一个网络 <em>bridge（网桥）</em>来实现。</p><p>Linux bridge 是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC 地址学习等。因此我们可以把 veth pair 等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。bridge 的工作方式是通过检查通过它的数据包目的地，并决定是否将数据包传递给连接到网桥的其他网段，从而在源和目的地之间维护一个转发表。bridge 通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。</p><p>Bridges 实现了 ARP 协议来发现与指定 IP 地址关联的链路层 MAC 地址。当 bridge 接收到数据帧的时候，bridge 将该帧广播给所有连接的设备（原始发送者除外），响应该帧的设备被存储在一个查找表中，未来具有相同 IP 地址的通信使用查找表来发现正确的 MAC 地址来转发数据包。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgaC5x2L2NGESEDibAC2J9Y4cSics1zvr3vlQEubR88po8icKdIZnzVDGag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                          <strong>图5.使用桥接连接命名空间</strong></p><h3 id="同节点-Pod-通信"><a href="#同节点-Pod-通信" class="headerlink" title="同节点 Pod 通信"></a>同节点 Pod 通信</h3><p>网络命名空间将每个 Pod 隔离到自己的网络堆栈中，虚拟以太网设备将每个命名空间连接到根命名空间，以及一个将命名空间连接在一起的网桥，这样我们就准备好在同一节点上的 Pod 之间发送流量了，如下图6所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgbMZZruJE0xAuacLiaia0y3HtN4ic5QJWsCEEpHgfoWsQMboak31eaeXOg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                   <strong>图6.同节点上的Pod间的数据包移动</strong></p><p>这上图中，pod1 向自己的网络设备 <code>eth0</code> 发送了一个数据包，对于 pod1 来说，<code>eth0</code> 通过虚拟网络设备连接到 root netns 的 <code>veth0(1)</code>，网桥 <code>cbr0</code> 被配置为与 <code>veth0</code> 一端相连，一旦数据包到达网桥，网桥就会使用 ARP 协议将数据包发送到 <code>veth1(3)</code>。当数据包到达虚拟设备 <code>veth1</code> 时，它被直接转发到 pod2 的命名空间内的 <code>eth0(4)</code> 设备。这整个过程中，每个 Pod 仅与 <code>localhost</code> 上的 <code>eth0</code> 进行通信，流量就会被路由到正确的 Pod。</p><p>Kubernetes 的网络模型决定了 Pod 必须可以通过其 IP 地址跨节点访问，也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 是可见的，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式是相同的。接下来我们来看看不同节点上的 Pod 之间的流量路由问题。</p><h3 id="跨节点-Pod-通信"><a href="#跨节点-Pod-通信" class="headerlink" title="跨节点 Pod 通信"></a>跨节点 Pod 通信</h3><p>在研究了如何在同一节点上的 Pod 之间路由数据包之后，接下来我们来看下不同节点上的 Pod 之间的通信。Kubernetes 网络模型要求 Pod 的 IP 是可以通过网络访问的，但它并没有规定必须如何来实现。</p><p>通常集群中的每个节点都分配有一个 <code>CIDR</code>，用来指定该节点上运行的 Pod 可用的 IP 地址。一旦以 <code>CIDR</code> 为目的地的流量到达节点，节点就会将流量转发到正确的 Pod。图7展示了两个节点之间的网络通信，假设网络可以将 <code>CIDR</code> 中的流量转发到正确的节点。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgvHLovL3sZSEtEia3tKWIDCS43V6PLN4kxIjdLnMugfW32fl4ZfHmwSg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                   <strong>图7.不同节点上的Pod间通信</strong></p><p>上图一样和图6相同的地方开始请求，但是这次目标 Pod（绿色标注）与源 Pod（蓝色标注）位于不同的节点上。数据包首先通过 pod1 的网络设备发送，该设备与 root netns（1）中的虚拟网络设备配对，最终数据包到达 root netns 的网桥（2）上。</p><p>这个时候网桥上的 ARP 会失败，因为与网桥相连的没有正确的数据包 MAC 地址。一旦失败，网桥会将数据包发送到默认路由上 - root netns 的 <code>eth0</code> 设备，此时就会路由离开节点，进入网络（3）。我们现在假设网络可以根据分配给节点的 <code>CIDR</code> 将数据包路由到正确的节点（4）。数据包进入目标节点的 root netns（VM2 上的 eth0），这那里它通过网桥路由到正确的虚拟设备（5）。最后，路由通过位于 pod4 的命名空间（6）中的虚拟设备 <code>eth0</code> 来完成。一般来说，每个节点都知道如何将数据包传递给其内部运行的 Pod，一旦数据包到达目标节点，数据包的流动方式与同一节点上的 Pod 间通信方式一样。</p><p>我们这里没有介绍如何配置网络来将 Pod IPs 的流量路由到负责这些 IP 的正确节点，这和特定的网络有关系，比如 AWS 就维护了一个 Kubernetes 容器网络插件，该插件允许在 AWS 的 VPC 环境中使用 [容器网络接口（<code>CNI</code>）插件]（<a href="https://github.com/aws/amazon-vpc-cni-k8s%EF%BC%89%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%8A%82%E7%82%B9%E5%88%B0%E8%8A%82%E7%82%B9%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%82">https://github.com/aws/amazon-vpc-cni-k8s）来进行节点到节点的网络通信。</a></p><p>在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内 —— ENI 无需额外操作即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但你可以创建多个 ENI 并将它们部署到 EC2 实例上。Kubernetes 的 AWS CNI 插件会为节点上的每个 Pod 创建一个新的 ENI，因为 VPC 中的 ENI 已经连接到了现有 AWS 基础设施中，这使得每个 Pod 的 IP 地址可以在 VPC 内自然寻址。当 CNI 插件被部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口，并为这些实例分配 IP 地址，从而为每个节点形成了一个 <code>CIDR</code> 块。当部署 Pod 时，有一个小的二进制文件会作为 DaemonSet 部署到 Kubernetes 集群中，从节点本地的 <code>kubelet</code> 进程接收任何添加 Pod 到网络的请求，这个二进制文件会从节点的可用 ENI 池中挑选一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟网络设备和网桥将其分配给 Pod，和在同一节点内容的 Pod 通信一样，有了这个，Pod 的流量就可以跨集群内的节点进行通信了。</p><h2 id="Pod-到-Service"><a href="#Pod-到-Service" class="headerlink" title="Pod 到 Service"></a>Pod 到 Service</h2><p>上面我们已经介绍了如何在 Pod 和它们相关的 IP 地址之间的通信。但是 Pod 的 IP 地址并不是固定不变的，会随着应用的扩缩容、应用崩溃或节点重启而出现或消失，这些都可能导致 Pod IP 地址发生变化，Kubernetes 中可以通过 <em>Service</em> 对象来解决这个问题。</p><p>Kubernetes Service 管理一组 Pod，允许你跟踪一组随时间动态变化的 Pod IP 地址，Service 作为对 Pod 的抽象，为一组 Pod 分配一个虚拟的 VIP 地址，任何发往 Service VIP 的流量都会被路由到与其关联的一组 Pod。这就允许与 Service 相关的 Pod 集可以随时变更 - 客户端只需要知道 Service VIP 即可。</p><p>创建 Service 时候，会创建一个新的虚拟 IP（也称为 clusterIP），这集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与 Service 关联的一组 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内的负载均衡器，将流量分配到 Service 相关联的健康 Pod 上。接下来让我们仔细看看它是如何工作的。</p><h3 id="netfilter-与-iptables"><a href="#netfilter-与-iptables" class="headerlink" title="netfilter 与 iptables"></a>netfilter 与 iptables</h3><p>为了在集群中执行负载均衡，Kubernetes 会依赖于 Linux 内置的网络框架 - <code>netfilter</code>。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作，Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。</p><p><code>iptables</code> 是一个用户空间程序，它提供了一个基于 table 的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器会 watch kube-apiserver 的变更，当对 Service 或 Pod 的变化更新了 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会被自动更新，以便正确地将指向 Service 的流量路由到支持 Pod。iptables 规则会监听发往 Service VIP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的 VIP 更改为所选的 Pod IP。当 Pod 启动或关闭时，iptables 规则集也会更新以反映集群的变化状态。换句话说，iptables 已经在节点上做了负载均衡，以将指向 Service VIP 的流量路由到实际的 Pod 的 IP 上。</p><p>在返回路径上，IP 地址来自目标 Pod，在这种情况下，iptables 再次重写 IP 头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>Kubernetes 新版本已经提供了另外一个用于集群负载均衡的选项：IPVS， IPVS 也是构建在 netfilter 之上的，并作为 Linux 内核的一部分实现了传输层的负载均衡。IPVS 被合并到了 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载均衡器，IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务作为虚拟服务出现在一个 IP 地址上。这使得 IPVS 非常适合 Kubernetes 服务。</p><p>这部署 kube-proxy 时，可以指定使用 iptables 或 IPVS 来实现集群内的负载均衡。IPVS 专为负载均衡而设计，并使用更高效的数据结构（哈希表），与 iptables  相比允许更大的规模。在使用 IPVS 模式的 Service 时，会发生三件事：在 Node 节点上创建一个虚拟 IPVS 接口，将 Service 的 VIP 地址绑定到虚拟 IPVS 接口，并为每个 Service VIP 地址创建 IPVS 服务器。</p><h3 id="Pod-到-Service-通信"><a href="#Pod-到-Service-通信" class="headerlink" title="Pod 到 Service 通信"></a>Pod 到 Service 通信</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgO80nIibbUc6npiblqjuW8RAqlU6MhtBDUSRCwf4D1K81Wc9jdzwhnr8w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                     <strong>图8. Pod 与 Service 之间通信</strong></p><p>当这 Pod 和 Service 之间路由一个数据包时，流量和以前开始的方式一样，数据包首先通过连接到 Pod 的网络命名空间（1）的 <code>eth0</code> 离开 Pod，。然后它通过虚拟网络设备到达网桥（2）。网桥上运行的 ARP 是不知道 Service 地址的，所以它通过默认路由 <code>eth0</code>（3）将数据包传输出去。到这里会有一些不同的地方了，在 <code>eth0</code> 接收之前，该数据包会被 iptables 过滤，在收到数据包后，iptables 使用 kube-proxy 在节点上安装的规则来响应 Service 或 Pod 事件，将数据包的目的地从 Service VIP 改写为特定的 Pod IP（4）。该数据包现在就要到达 pod4 了，而不是 Service 的 VIP，iptables 利用内核的 <code>conntrack</code> 工具来记录选择的 Pod，以便将来的流量会被路由到相同的 Pod。从本质上讲，iptables 直接从节点上完成了集群内的负载均衡，然后流量流向 Pod，剩下的就和前面的 Pod 到 Pod 通信一样的了（5）。</p><h3 id="Service-到-Pod-通信"><a href="#Service-到-Pod-通信" class="headerlink" title="Service 到 Pod 通信"></a>Service 到 Pod 通信</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgtV3KndqR2yoKUjoRlicMAwVOAnRzQn1lzibNE7ndyQpNHQ3UoeF0toiag/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                              <strong>图9.在 Service 和 Pod 之间通信</strong></p><p>相应的回包的时候，收到该数据包的 Pod 将响应，将源 IP 标记为自己的 IP，将目标 IP 标记为最初发送数据包的 Pod(1)。进入节点后，数据包流经 iptables，它使用 <code>conntrack</code> 记住它之前所做的选择，并将数据包的源重写为 Service 的 VIP 而不是现在 Pod 的 IP(2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟网络设备 (3)，然后流向我们之前看到的 Pod 的虚拟网络设备 (4)。</p><h2 id="外网到-Service-通信"><a href="#外网到-Service-通信" class="headerlink" title="外网到 Service 通信"></a>外网到 Service 通信</h2><p>到这里我们已经了解了 Kubernetes 集群内的流量是如何路由的，但是更多的时候我们需要将服务暴露到外部去。这个时候会涉及到两个主要的问题：</p><ul><li>将流量从 Kubernetes 服务路由到互联网上去</li><li>将流量从互联网传到你的 Kubernetes 服务</li></ul><p>接下来我们就来讨论这些问题。</p><h3 id="出流量"><a href="#出流量" class="headerlink" title="出流量"></a>出流量</h3><p>从节点到公共 Internet 的路由流量也是和特定的网络有关系的，这取决于你的网络如何配置来发布流量的。这里我们以 AWS VPC 为例来进行说明。</p><p>在 AWS 中，Kubernetes 集群在 VPC 中运行，每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问服务，你可以在 VPC 上附加一个外网网关。外网网关有两个用途：在你的 VPC 路由表中为可路由到外网的流量提供目标，以及为已分配公共 IP 地址的实例执行网络地址转换 (NAT)。NAT 转换负责将集群节点的内部 IP 地址更改为公网中可用的外部 IP 地址。</p><p>有了外网网关，VM 就可以自由地将流量路由到外网。不过有一个小问题，Pod 有自己的 IP 地址，与运行 Pod 的节点 IP 地址不同，并且外网网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道哪些 Pod 在哪些 VM 上运行 —— 网关不支持容器。让我们看看 Kubernetes 是如何使用 iptables 来解决这个问题的。</p><p>在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的网络设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，外网网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是<strong>让 iptables 执行源 NAT</strong> —— 更改数据包源，使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达外网网关 (5) 了。外网网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为公网IP。最后，数据包将到达互联网上 (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 的修改都会被取消，这样系统的每一层都会接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgGaUDVlu2VesbE999GjqtA1WthWLBRF47ZDQ6XttQMqkjq9fc1YE3kg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                       <strong>图10.从Pod到互联网通信</strong></p><h3 id="入流量"><a href="#入流量" class="headerlink" title="入流量"></a>入流量</h3><p>让流量进入你的集群是一个非常难以解决的问题。同样这也和特定的网络环境有关系，但是一般来说入流量可以分为两种解决方案：</p><ul><li>Service LoadBalancer</li><li>Ingress 控制器</li></ul><p><strong>LoadBalancer</strong></p><p>当你创建一个 Kubernetes Service时，你可以选择指定一个 LoadBalancer 来使用它。LoadBalancer 有为你提供服务的云供应商负责创建负载均衡器，创建服务后，它将暴露负载均衡器的 IP 地址。终端用户可以直接通过该 IP 地址与你的服务进行通信。</p><p><strong>LoadBalancer 到 Service</strong></p><p>在部署了 Service 后，你使用的云提供商将会为你创建一个新的 LoadBalancer（1）。因为 LoadBalancer 不支持容器，所以一旦流量到达 LoadBalancer，它就会分布在集群的各个节点上（2）。每个节点上的 iptables 规则会将来自 LoadBalancer 的传入流量路由到正确的 Pod 上（3）。从 Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有 LoadBalancer 的 IP 地址。正如我们之前看到的，iptables 和 conntrack 被用来在返回路径上正确重写 IP 地址。</p><p>下图展示的就是托管 Pod 的三个节点前面的负载均衡器。传入流量（1）指向 Service 的 LoadBalancer，一旦 LoadBalancer 接收到数据包（2），它就会随机选择一个节点。我们这里的示例中，我们选择了没有运行 Pod 的节点 VM2（3）。在这里，运行在节点上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载均衡规则，将数据包转发到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod（4）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgjicHYRZia3uYzyTenTbsnsCcUaKZYt1PeIj69MYh8uNic3oziaicIZeFKmQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                      <strong>图11.外网访问 Service</strong></p><p><strong>Ingress 控制器</strong></p><p>在七层网络上 Ingress 在 HTTP&#x2F;HTTPS 协议范围内运行，并建立在 Service 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 类型的 Service，如果你将 Service 设置成 NodePort 类型，Kubernetes master 将从你指定的范围内分配一个端口，并且每个节点都会将该端口代理到你的 Service，也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到 Service。</p><p>将节点的端口暴露在外网，可以使用一个 Ingress 对象，Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes Service。根据控制器的实现方式，Ingress 的使用方式会有所不同。HTTP 负载均衡器，和四层网络负载均衡器一样，只了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。</p><p>在 AWS 环境中，ALB Ingress 控制器使用 AWS 的七层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件，它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgdr38KkXPhd9AKtGnrYhn2SxGDKy0fbjFWIrfrgzXaXCzjicEIjrWzRg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                   <strong>图12.Ingress 控制器</strong></p><p>创建后，(1) Ingress Controller 会 watch 来自 Kubernetes APIServer 的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的 TargetGroup一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes Service 创建 TargetGroup。(4) Listener 是一个 ALB 进程，它使用你配置的协议和端口检查连接请求。Listener 由 Ingress 控制器为你的 Ingress 资源中描述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建 TargetGroup 规则。这可以保证到特定路径的流量被路由到正确的 Kubernetes 服务上 (5)。</p><p><strong>Ingress 到 Service</strong></p><p>流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（可以根据路径将流量路由到 Service）Ingress 和节点之间的初始连接是通过节点上为每个服务暴露的端口。</p><p>部署 Service 后，你使用的云提供商将为你创建一个新的 Ingress 负载均衡器 (1)。因为负载均衡器不支持容器，一旦流量到达负载均衡器，它就会通过为你的服务端口分布在组成集群 (2) 的整个节点中。每个节点上的 iptables 规则会将来自负载均衡器的传入流量路由到正确的 Pod (3)。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgB6f7ZsmsiamnMF10mxPp1NvlmMw5sHGfqAQ0MKnkYTxlMKpjkI6Gctg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                               <strong>图13.从 Ingress 到 Service</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Kubernetes 网络模型以及如何实现常见网络任务。网络知识点既广泛又很深，所以我们这里不可能涵盖所有的内容，但是你可以以本文为起点，然后去深入了解你感兴趣的主题。</p><blockquote><p>原文链接：<a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model">https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服内推</title>
    <link href="/2022/08/27/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%86%85%E6%8E%A8/"/>
    <url>/2022/08/27/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%86%85%E6%8E%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果-简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。"><a href="#帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果-简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。" class="headerlink" title="帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果 - 简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。"></a>帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果 - 简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。</h3><h3 id="招聘网址-https-app-mokahr-com-recommendation-apply-sangfor-5369-recommendCode-NTAEMbl-jobs-isCampusJob-1-amp-commitment-E5-85-A8-E8-81-8C"><a href="#招聘网址-https-app-mokahr-com-recommendation-apply-sangfor-5369-recommendCode-NTAEMbl-jobs-isCampusJob-1-amp-commitment-E5-85-A8-E8-81-8C" class="headerlink" title="招聘网址:   https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C"></a>招聘网址:   <a href="https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C">https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C</a></h3><h3 id="内推码：NTAEMbl-投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！"><a href="#内推码：NTAEMbl-投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！" class="headerlink" title="内推码：NTAEMbl   投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！"></a>内推码：NTAEMbl   投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！</h3><p><img src="https://s2.loli.net/2022/08/27/aR4mNMEGDWwsHfT.jpg" alt="a3a7bad9b480bd23d69abd81723f366.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>内推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
