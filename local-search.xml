<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>raft论文翻译</title>
    <link href="/2022/10/01/%E2%80%9Craft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%9C/"/>
    <url>/2022/10/01/%E2%80%9Craft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找一种易于理解的一致性算法（扩展版）"><a href="#寻找一种易于理解的一致性算法（扩展版）" class="headerlink" title="寻找一种易于理解的一致性算法（扩展版）"></a>寻找一种易于理解的一致性算法（扩展版）</h1><ul><li><a href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E7%A7%8D%E6%98%93%E4%BA%8E%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E6%89%A9%E5%B1%95%E7%89%88">寻找一种易于理解的一致性算法（扩展版）</a><ul><li><a href="#%E6%91%98%E8%A6%81">摘要</a></li><li><a href="#1-%E4%BB%8B%E7%BB%8D">1 介绍</a></li><li><a href="#2-%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA">2 复制状态机</a></li><li><a href="#3-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98">3 Paxos 算法的问题</a></li><li><a href="#4-%E4%B8%BA%E4%BA%86%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1">4 为了可理解性的设计</a></li><li><a href="#5-raft-%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95">5 Raft 一致性算法</a><ul><li><a href="#51-raft-%E5%9F%BA%E7%A1%80">5.1 Raft 基础</a></li><li><a href="#52-%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE">5.2 领导人选举</a></li><li><a href="#53-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6">5.3 日志复制</a></li><li><a href="#54-%E5%AE%89%E5%85%A8%E6%80%A7">5.4 安全性</a><ul><li><a href="#541-%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6">5.4.1 选举限制</a></li><li><a href="#542-%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E5%86%85%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE">5.4.2 提交之前任期内的日志条目</a></li><li><a href="#543-%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BA%E8%AF%81">5.4.3 安全性论证</a></li></ul></li><li><a href="#55-%E8%B7%9F%E9%9A%8F%E8%80%85%E5%92%8C%E5%80%99%E9%80%89%E4%BA%BA%E5%B4%A9%E6%BA%83">5.5 跟随者和候选人崩溃</a></li><li><a href="#56-%E6%97%B6%E9%97%B4%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7">5.6 时间和可用性</a></li></ul></li><li><a href="#6-%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96">6 集群成员变化</a></li><li><a href="#7-%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9">7 日志压缩</a></li><li><a href="#8-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92">8 客户端交互</a></li><li><a href="#9-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AF%84%E4%BC%B0">9 算法实现和评估</a><ul><li><a href="#91-%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7">9.1 可理解性</a></li><li><a href="#92-%E6%AD%A3%E7%A1%AE%E6%80%A7">9.2 正确性</a></li><li><a href="#93-%E6%80%A7%E8%83%BD">9.3 性能</a></li></ul></li><li><a href="#10-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C">10 相关工作</a></li><li><a href="#11-%E7%BB%93%E8%AE%BA">11 结论</a></li><li><a href="#12-%E6%84%9F%E8%B0%A2">12 感谢</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos 算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。</p><p>但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。因此工业界和学术界都对 Paxos 算法感到十分头疼。</p><p>努力研究过 Paxos 算法之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。与 Paxos 不同，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且比 Paxos 算法更容易学习。此外，我们希望该算法方便系统构建者的直觉的发展。重要的不仅仅是算法能够工作，更重要的是能够很清楚地知道它为什么能工作。</p><p>Raft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。</p><p>Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：</p><ul><li><strong>强领导人</strong>：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li><li><strong>领导选举</strong>：Raft 算法使用一个随机计时器来选举领导人。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li><li><strong>成员关系调整</strong>：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li></ul><p>我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全特性已经被正式定义和证明；它的效率和其他算法比起来也不相上下。</p><p>接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。</p><h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2 复制状态机"></a>2 复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图1.png" alt="图 1 "></p><blockquote><p>图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p></blockquote><p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><p>一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成了一个高可靠的状态机。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。</li><li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。</li><li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li></ul><h2 id="3-Paxos-算法的问题"><a href="#3-Paxos-算法的问题" class="headerlink" title="3 Paxos 算法的问题"></a>3 Paxos 算法的问题</h2><p>在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。</p><p>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。</p><p>我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。</p><p>Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。</p><p>而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立地选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。</p><p>因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：</p><blockquote><p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。</p></blockquote><p>由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft 算法就是这次实验的结果。</p><h2 id="4-为了可理解性的设计"><a href="#4-为了可理解性的设计" class="headerlink" title="4 为了可理解性的设计"></a>4 为了可理解性的设计</h2><p>设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p><p>在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？</p><p>我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：我们尽可能地将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和成员变更几个部分。</p><p>我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化来简化 Raft 中领导人选举算法。</p><h2 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h2><p>Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。</p><p>Raft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p><p>通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p><ul><li><strong>领导选举</strong>：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2）</li><li><strong>日志复制</strong>：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。</li><li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到选举机制（5.2 节）上的一个额外限制。</li></ul><p>在展示一致性算法之后，这一章节会讨论一些可用性的问题和计时在系统中的作用。</p><p><strong>状态</strong>：</p><p>所有服务器上的持久性状态<br>(在响应 RPC 请求之前，已经更新到了稳定的存储设备)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><p>所有服务器上的易失性状态</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知已提交的最高的日志条目的索引（初始值为0，单调递增）</td></tr><tr><td>lastApplied</td><td>已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p>领导人（服务器）上的易失性状态<br>(选举后已经重新初始化)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）</td></tr><tr><td>matchIndex[]</td><td>对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p><strong>追加条目（AppendEntries）RPC</strong>：</p><p>由领导人调用，用于日志条目的复制，同时也被当做心跳使用</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期</td></tr><tr><td>leaderId</td><td>领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人）</td></tr><tr><td>prevLogIndex</td><td>紧邻新日志条目之前的那个日志条目的索引</td></tr><tr><td>prevLogTerm</td><td>紧邻新日志条目之前的那个日志条目的任期</td></tr><tr><td>entries[]</td><td>需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）</td></tr><tr><td>leaderCommit</td><td>领导人的已知已提交的最高的日志条目的索引</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期，对于领导人而言 它会更新自己的任期</td></tr><tr><td>success</td><td>如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true</td></tr></tbody></table><p>接收者的实现：</p><ol><li>返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节）</li><li>返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上<br>（译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）（5.3 节）</li><li>如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目 （5.3 节）</li><li>追加日志中尚未存在的任何新条目</li><li>如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（<code>leaderCommit &gt; commitIndex</code>），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值</li></ol><p><strong>请求投票（RequestVote）RPC</strong>：</p><p>由候选人负责调用用来征集选票（5.2 节）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 ID</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为真</td></tr></tbody></table><p>接收者实现：</p><ol><li>如果<code>term &lt; currentTerm</code>返回 false （5.2 节）</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</li></ol><p><strong>所有服务器需遵守的规则</strong>：</p><p>所有服务器：</p><ul><li>如果<code>commitIndex &gt; lastApplied</code>，则 lastApplied 递增，并将<code>log[lastApplied]</code>应用到状态机中（5.3 节）</li><li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，则令 <code>currentTerm = T</code>，并切换为跟随者状态（5.1 节）</li></ul><p>跟随者（5.2 节）：</p><ul><li>响应来自候选人和领导人的请求</li><li>如果在超过选举超时时间的情况之前没有收到<strong>当前领导人</strong>（即该领导人的任期需与这个跟随者的当前任期相同）的心跳&#x2F;附加日志，或者是给某个候选人投了票，就自己变成候选人</li></ul><p>候选人（5.2 节）：</p><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者</li><li>如果选举过程超时，则再次发起一轮选举</li></ul><p>领导人：</p><ul><li>一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节）</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</li><li>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（<code>lastLogIndex ≥ nextIndex</code>），则发送从 nextIndex 开始的所有日志条目：<ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则 nextIndex 递减并重试</li></ul></li><li>假设存在 N 满足<code>N &gt; commitIndex</code>，使得大多数的 <code>matchIndex[i] ≥ N</code>以及<code>log[N].term == currentTerm</code> 成立，则令 <code>commitIndex = N</code>（5.3 和 5.4 节）</li></ul><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图2.png" alt="图 2"></p><blockquote><p>图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。</p></blockquote><table><thead><tr><th>特性</th><th>解释</th></tr></thead><tbody><tr><td>选举安全特性</td><td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td></tr><tr><td>领导人只附加原则</td><td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td></tr><tr><td>日志匹配原则</td><td>如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致（5.3 节）</td></tr><tr><td>领导人完全特性</td><td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td></tr><tr><td>状态机安全特性</td><td>如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用不同的日志条目（5.4.3 节）</td></tr></tbody></table><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图3.png" alt="图 3 "></p><blockquote><p>图 3：Raft 在任何时候都保证以上的各个特性。</p></blockquote><h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图4.png" alt="图 4 "></p><blockquote><p>图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。</p></blockquote><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图5.png" alt="图 5"></p><blockquote><p>图 5：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p></blockquote><p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导人。</p><p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，任期使得服务器可以检测一些过期的信息：比如过期的领导人。每个节点存储一个当前任期号，这一编号在整个时期内单调递增。每当服务器之间通信的时候都会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的任期号到较大的任期号值。如果一个候选人或者领导人发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p><h3 id="5-2-领导人选举"><a href="#5-2-领导人选举" class="headerlink" title="5.2 领导人选举"></a>5.2 领导人选举</h3><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的 RPCs。领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries） RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导人，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。</p><p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p><p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p><p>领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。</p><h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图6.png" alt="图 6"></p><blockquote><p>图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。</p></blockquote><p>日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。</p><p>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p><p>我们设计了 Raft 的日志机制来维护不同服务器日志之间的高层次的一致性。这么做不仅简化了系统的行为也使其更具有可预测性，同时它也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些特性共同组成了图 3 中的<strong>日志匹配特性（Log Matching Property）</strong>：</p><ul><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。</li></ul><p>第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目前紧挨着的条目的索引位置和任期号包含在日志内。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。</p><p>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同。跟随者可能会丢失一些在新的领导人中存在的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图7.png" alt="图 7"></p><blockquote><p>图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p></blockquote><p>在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。</p><p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 <strong>nextIndex</strong>，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p><blockquote><p>如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。</p></blockquote><p>通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。</p><p>日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。</p><h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p><p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于<strong>领导人完整特性（Leader Completeness Property）</strong> 的简要证明，并且说明该特性是如何引导复制状态机做出正确行为的。</p><h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图8.png" alt="图 8"></p><blockquote><p>图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p></blockquote><p>为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p><h4 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h4><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图9.png" alt="图 9"></p><blockquote><p>图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p></blockquote><ol><li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li><li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。</li><li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</li><li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li><li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li><li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</li><li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。</li><li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。</li><li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。</li></ol><p>通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><h3 id="5-5-跟随者和候选人崩溃"><a href="#5-5-跟随者和候选人崩溃" class="headerlink" title="5.5 跟随者和候选人崩溃"></a>5.5 跟随者和候选人崩溃</h3><p>到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p><h3 id="5-6-时间和可用性"><a href="#5-6-时间和可用性" class="headerlink" title="5.6 时间和可用性"></a>5.6 时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p><blockquote><p>广播时间（broadcastTime）  &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt;  平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p><h2 id="6-集群成员变化"><a href="#6-集群成员变化" class="headerlink" title="6 集群成员变化"></a>6 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。</p><p>为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人在同一个任期里同时被选举成功。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图10.png" alt="图 10"></p><blockquote><p>图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p></blockquote><p>为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致（<em>joint consensus</em>)；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为领导人。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li></ul><p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用  C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。</p><p>一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，如果不经过另一个配置的允许都不能单独做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图11.png" alt="图 11"></p><blockquote><p>图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和  C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在  C-new 和 C-old 可以同时做出决定的时间点。</p></blockquote><p>在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新之前使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。</p><p>第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p><p>第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。</p><p>为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。确切地说，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。</p><h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7 日志压缩"></a>7 日志压缩</h2><p>Raft 的日志在正常操作中不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p><p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p><p>增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图12.png" alt="图 12"></p><blockquote><p>图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</p></blockquote><p>图 12 展示了 Raft 中快照的基础思想。每个服务器独立地创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong>最后被包含索引</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong>最后被包含的任期</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p><p>尽管通常服务器都是独立地创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。</p><p><strong>安装快照 RPC</strong>：</p><p>由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 ID，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>从偏移量开始的快照分块的原始字节</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>接收者实现</strong>：</p><ol><li>如果<code>term &lt; currentTerm</code>就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图13.png" alt="图 13 "></p><blockquote><p>图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。</p></blockquote><p>在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种  RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。</p><p>这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。</p><p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p><p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p><p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p><h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8 客户端交互"></a>8 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p><p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可能执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为响应客户端请求的领导人可能在他不知道的时候已经被新的领导人取代了。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p><h2 id="9-算法实现和评估"><a href="#9-算法实现和评估" class="headerlink" title="9 算法实现和评估"></a>9 算法实现和评估</h2><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p><p>这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p><h3 id="9-1-可理解性"><a href="#9-1-可理解性" class="headerlink" title="9.1 可理解性"></a>9.1 可理解性</h3><p>为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。</p><p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些  Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p><table><thead><tr><th>关心</th><th>缓和偏见采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr><td>相同的讲课质量</td><td>两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。</td><td>视频</td></tr><tr><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评价量规（rubric）</td></tr></tbody></table><blockquote><p>表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。</p></blockquote><p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图14.png" alt="图 14"></p><blockquote><p>图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。</p></blockquote><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。</p><p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图15.png" alt="图 15"></p><blockquote><p>图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。</p></blockquote><p>关于 Raft 用户学习有一个更加详细的讨论。</p><h3 id="9-2-正确性"><a href="#9-2-正确性" class="headerlink" title="9.2 正确性"></a>9.2 正确性</h3><p>在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。</p><h3 id="9-3-性能"><a href="#9-3-性能" class="headerlink" title="9.3 性能"></a>9.3 性能</h3><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？</p><p><img src="D:\桌面\项目\开源项目\Reading-note\kuberneters\ETCD\images\raft-图16.png" alt="图 16"></p><blockquote><p>图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。</p></blockquote><p>为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p><p>图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p><p>图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。</p><h2 id="10-相关工作"><a href="#10-相关工作" class="headerlink" title="10 相关工作"></a>10 相关工作</h2><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p><ul><li>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰。</li><li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。</li><li>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>Paxos 可以应用的性能优化。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p><p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 种不同的消息类型，相对的，Raft 只有 4 种消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p><p>Raft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p><p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。</p><h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11 结论"></a>11 结论</h2><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p><p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p><h2 id="12-感谢"><a href="#12-感谢" class="headerlink" title="12 感谢"></a>12 感谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利 CS 294-91 课程、斯坦福 CS 240 课程的学生。Scott Klemmer 帮我们设计了用户调查，Nelson Ray 建议我们进行统计学的分析。在用户调查时使用的关于 Paxos 的幻灯片很大一部分是从 Lorenzo Alvisi 的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 Ezra Hoch，他们找到了 Raft 中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括 Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，Arjun Gopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，Aleksandar Kracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，David Ramos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，Deian Stefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，Matei Zaharia 以及 24 位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 Eddie Kohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft 带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale 系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由 STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA 支持，在国家科学基金会的 0963859 号批准，并且获得了来自 Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。Diego Ongaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>raft</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装载</tag>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”01.ETCD基础架构“</title>
    <link href="/2022/10/01/%E2%80%9D01-ETCD%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E2%80%9C/"/>
    <url>/2022/10/01/%E2%80%9D01-ETCD%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E2%80%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01.etcd基础架构</title>
    <link href="/2022/10/01/ETCD%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/10/01/ETCD%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="ETCD基础架构"><a href="#ETCD基础架构" class="headerlink" title="ETCD基础架构"></a>ETCD基础架构</h1><p>下面是一张 etcd 的简要基础架构图，我们先从宏观上了解一下 etcd 都有哪些功能模块。</p><p><img src="https://static001.geekbang.org/resource/image/34/84/34486534722d2748d8cd1172bfe63084.png?wh=1920*1240" alt="img"></p><p>可以看到，按照分层模型，etcd 可分为 Client 层、API 网络层、Raft 算法层、逻辑层和存储层。这些层的功能如下：</p><ul><li><strong>Client 层</strong>：Client 层包括 client v2 和 v3 两个大版本 API 客户端库，提供了简洁易用的 API，同时支持负载均衡、节点间故障自动转移，可极大降低业务使用 etcd 复杂度，提升开发效率、服务可用性。</li><li><strong>API 网络层</strong>：API 网络层主要包括 client 访问 server 和 server 节点之间的通信协议。一方面，client 访问 etcd server 的 API 分为 v2 和 v3 两个大版本。v2 API 使用 HTTP&#x2F;1.x 协议，v3 API 使用 gRPC 协议。同时 v3 通过 etcd grpc-gateway 组件也支持 HTTP&#x2F;1.x 协议，便于各种语言的服务调用。另一方面，server 之间通信协议，是指节点间通过 Raft 算法实现数据复制和 Leader 选举等功能时使用的 HTTP 协议。</li><li><strong>Raft 算法层</strong>：Raft 算法层实现了 Leader 选举、日志复制、ReadIndex 等核心算法特性，用于保障 etcd 多个节点间的数据一致性、提升服务可用性等，是 etcd 的基石和亮点。</li><li><strong>功能逻辑层</strong>：etcd 核心特性实现层，如典型的 KVServer 模块、MVCC 模块、Auth 鉴权模块、Lease 租约模块、Compactor 压缩模块等，其中 MVCC 模块主要由 treeIndex 模块和 boltdb 模块组成。</li><li><strong>存储</strong>层：存储层包含预写日志 (WAL) 模块、快照 (Snapshot) 模块、boltdb 模块。其中 WAL 可保障 etcd crash 后数据不丢失，boltdb 则保存了集群元数据和用户写入的数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式的六种实现方式</title>
    <link href="/2022/09/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BD%A2%E5%BC%8F/"/>
    <url>/2022/09/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>﻿&gt; 最近重新学习了一下单例模式，写博客总结一下，有错误或者另外的方法欢迎指出</p><h1 id="单例模式的六种常见形式"><a href="#单例模式的六种常见形式" class="headerlink" title="单例模式的六种常见形式"></a>单例模式的六种常见形式</h1><h2 id="一、饿汉式：直接创建对象，无线程安全问题"><a href="#一、饿汉式：直接创建对象，无线程安全问题" class="headerlink" title="一、饿汉式：直接创建对象，无线程安全问题"></a>一、饿汉式：直接创建对象，无线程安全问题</h2><p><strong>1.1直接实例化饿汉式（简洁直观）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><br><span class="hljs-comment">//1.1直接实例化饿汉式（简洁直观）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">直接创建实例对象</span><br><span class="hljs-comment">构造器私有化</span><br><span class="hljs-comment">自行创建，用静态变量保存</span><br><span class="hljs-comment">final用来强调单例，可以不加</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HungrySingleton1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  HungrySingleton1  INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HungrySingleton1</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HungrySingleton1</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>1.2枚举式（最简洁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.2枚举式（最简洁）</span><br><span class="hljs-comment">只声明一个，表示限定为单例</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">HungrySingleton2</span>&#123;<br>        INSTANCE<br>    &#125;<br><br><br><br></code></pre></td></tr></table></figure><p><strong>1.3静态代码块饿汉式（适合复杂饿汉式）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 1.3静态代码块饿汉式（适合复杂饿汉式）</span><br><span class="hljs-comment">* 通过静态代码块创建实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HungrySingleton3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> HungrySingleton3   INSTANCE;<br>    <span class="hljs-keyword">static</span> &#123;<br>        INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HungrySingleton3</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">HungrySingleton3</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二、懒汉式：延迟创建对象"><a href="#二、懒汉式：延迟创建对象" class="headerlink" title="二、懒汉式：延迟创建对象"></a>二、懒汉式：延迟创建对象</h2><p><strong>2.1线程不安全（适用于单线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *2.1线程不安全（适用于单线程）</span><br><span class="hljs-comment"> * 构造器私有化</span><br><span class="hljs-comment"> * 用静态变量修饰</span><br><span class="hljs-comment"> * 提供静态变量方法获取对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lazySingleton1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> lazySingleton1 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">lazySingleton1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lazySingleton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">lazySingleton1</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.2线程安全（适用于多线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *2.2线程安全（适用于多线程）</span><br><span class="hljs-comment"> * 构造器私有化</span><br><span class="hljs-comment"> * 用静态变量修饰</span><br><span class="hljs-comment"> * 提供静态变量方法获取对象</span><br><span class="hljs-comment"> * 使用synchronized锁住对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lazySingleton2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> lazySingleton2 instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">lazySingleton2</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lazySingleton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lazySingleton2.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">lazySingleton2</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><strong>2.3静态内部类（适用于多线程）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lp.singleton;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *2.3静态内部类（适用于多线程）</span><br><span class="hljs-comment"> * 构造器私有化</span><br><span class="hljs-comment"> * 用静态变量修饰</span><br><span class="hljs-comment"> *在静态内部类被加载和初始化时，才创建INSTANCE实例对象</span><br><span class="hljs-comment"> * 静态内部类单独加载和初始化，不会随着外部类的加载和初始化而初始化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lazySingleton3</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">lazySingleton3</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> lazySingleton3   INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">lazySingleton3</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> lazySingleton3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Inner.INSTANCE;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring框架的总结（三、Spring AOP）</title>
    <link href="/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%E3%80%81Spring-AOP%EF%BC%89/"/>
    <url>/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%E3%80%81Spring-AOP%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>﻿# 关于Spring框架的总结（三、Spring AOP）</p><h2 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3.Spring AOP"></a>3.Spring AOP</h2><blockquote><p>Spring AOP<br>3.1.Spring AOP的基本概念<br>3.2.动态代理<br>3.3.AOP的常见术语<br>3.4.基于XML配置开发<br>3.5.基于注解开发</p></blockquote><h2 id="3-1-Spring-AOP的基本概念"><a href="#3-1-Spring-AOP的基本概念" class="headerlink" title="3.1.Spring AOP的基本概念"></a>3.1.Spring AOP的基本概念</h2><p><font color=red>AOP (Aspect- Oriented Programming) 即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</font color=red>它与OOP (Object-OtientedProgramming,面向对象编程)相辅相成， 提供了与OOP不同的抽象软件结构的视角。在OOP中，以类作为程序的基本单元，而AOP中的基本单元是Aspect (切面)。利用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性，同时提高了开发的效率。</p><p>简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p><h2 id="3-2-动态代理"><a href="#3-2-动态代理" class="headerlink" title="3.2.动态代理"></a>3.2.动态代理</h2><p><strong>动态代理常用的有两种方式</strong><br><strong>（1）、JDK动态代理（基于接口的动态代理）</strong><br>1.创建接口以及实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IActor</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 基本演出</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> money</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 危险演出</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> money</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dangerAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 一个演员</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IActor</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;拿到钱，开始基本的表演：&quot;</span>+money);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dangerAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;拿到钱，开始危险的表演：&quot;</span>+money);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//一个剧组找演员：</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Actor</span>();<span class="hljs-comment">//直接</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 代理：</span><br><span class="hljs-comment">* 间接。</span><br><span class="hljs-comment">* 获取代理对象：</span><br><span class="hljs-comment">* 要求：</span><br><span class="hljs-comment">* 被代理类最少实现一个接口</span><br><span class="hljs-comment">* 创建的方式</span><br><span class="hljs-comment">* Proxy.newProxyInstance(三个参数)</span><br><span class="hljs-comment">* 参数含义：</span><br><span class="hljs-comment">* ClassLoader：和被代理对象使用相同的类加载器。</span><br><span class="hljs-comment">* Interfaces：和被代理对象具有相同的行为。实现相同的接口。</span><br><span class="hljs-comment">* InvocationHandler：如何代理。</span><br><span class="hljs-comment">* 策略模式：使用场景是：</span><br><span class="hljs-comment">* 数据有了，目的明确。</span><br><span class="hljs-comment">* 如何达成目标，就是策略。</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">IActor</span> <span class="hljs-variable">proxyActor</span> <span class="hljs-operator">=</span> (IActor) Proxy.newProxyInstance(<br>actor.getClass().getClassLoader(), <br>actor.getClass().getInterfaces(), <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行被代理对象的任何方法，都会经过该方法。</span><br><span class="hljs-comment">* 此方法有拦截的功能。</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 参数：</span><br><span class="hljs-comment">* proxy：代理对象的引用。不一定每次都用得到</span><br><span class="hljs-comment">* method：当前执行的方法对象</span><br><span class="hljs-comment">* args：执行方法所需的参数</span><br><span class="hljs-comment">* 返回值：</span><br><span class="hljs-comment">* 当前执行方法的返回值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <br><span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> method.getName();<br><span class="hljs-type">Float</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> (Float) args[<span class="hljs-number">0</span>];<br><span class="hljs-type">Object</span> <span class="hljs-variable">rtValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//每个经纪公司对不同演出收费不一样，此处开始判断</span><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;basicAct&quot;</span>.equals(name))&#123;<br><span class="hljs-comment">//基本演出，没有 2000 不演</span><br><span class="hljs-keyword">if</span>(money &gt; <span class="hljs-number">2000</span>)&#123;<br><span class="hljs-comment">//看上去剧组是给了 8000，实际到演员手里只有 4000</span><br><span class="hljs-comment">//这就是我们没有修改原来 basicAct 方法源码，对方法进行了增强</span><br>rtValue = method.invoke(actor, money/<span class="hljs-number">2</span>);<br>&#125; &#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;dangerAct&quot;</span>.equals(name))&#123;<br><span class="hljs-comment">//危险演出,没有 5000 不演</span><br><span class="hljs-keyword">if</span>(money &gt; <span class="hljs-number">5000</span>)&#123;<br><span class="hljs-comment">//看上去剧组是给了 50000，实际到演员手里只有 25000</span><br><span class="hljs-comment">//这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强</span><br>rtValue = method.invoke(actor, money/<span class="hljs-number">2</span>);<br>&#125; &#125;<br><span class="hljs-keyword">return</span> rtValue;<br>&#125;<br>&#125;);<br><span class="hljs-comment">//没有经纪公司的时候，直接找演员。</span><br><span class="hljs-comment">// actor.basicAct(1000f);</span><br><span class="hljs-comment">// actor.dangerAct(5000f);</span><br><span class="hljs-comment">//剧组无法直接联系演员，而是由经纪公司找的演员</span><br>proxyActor.basicAct(<span class="hljs-number">8000f</span>);<br>proxyActor.dangerAct(<span class="hljs-number">50000f</span>);<br>&#125; &#125;<br></code></pre></td></tr></table></figure><p><strong>（2）、CGLIB动态代理（基于子类的动态代理）</strong><br>1.创建目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span>&#123;<span class="hljs-comment">//目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;拿到钱，开始基本的表演：&quot;</span>+money);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dangerAct</span><span class="hljs-params">(<span class="hljs-type">float</span> money)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;拿到钱，开始危险的表演：&quot;</span>+money);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 基于子类的动态代理</span><br><span class="hljs-comment">* 要求：</span><br><span class="hljs-comment">* 被代理对象不能是最终类</span><br><span class="hljs-comment">* 用到的类：</span><br><span class="hljs-comment">* Enhancer</span><br><span class="hljs-comment">* 用到的方法：</span><br><span class="hljs-comment">* create(Class, Callback)</span><br><span class="hljs-comment">* 方法的参数：</span><br><span class="hljs-comment">* Class：被代理对象的字节码</span><br><span class="hljs-comment">* Callback：如何代理</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">Actor</span> <span class="hljs-variable">actor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Actor</span>();<br><span class="hljs-type">Actor</span> <span class="hljs-variable">cglibActor</span> <span class="hljs-operator">=</span> (Actor) Enhancer.create(actor.getClass(),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何</span><br><span class="hljs-comment">方法进行增强。</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 参数：</span><br><span class="hljs-comment">* 前三个和基于接口的动态代理是一样的。</span><br><span class="hljs-comment">* MethodProxy：当前执行方法的代理对象。</span><br><span class="hljs-comment">* 返回值：</span><br><span class="hljs-comment">* 当前执行方法的返回值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, </span><br><span class="hljs-params">MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> method.getName();<br><span class="hljs-type">Float</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> (Float) args[<span class="hljs-number">0</span>];<br><span class="hljs-type">Object</span> <span class="hljs-variable">rtValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;basicAct&quot;</span>.equals(name))&#123;<br><span class="hljs-comment">//基本演出</span><br><span class="hljs-keyword">if</span>(money &gt; <span class="hljs-number">2000</span>)&#123;<br>rtValue = method.invoke(actor, money/<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;dangerAct&quot;</span>.equals(name))&#123;<br><span class="hljs-comment">//危险演出</span><br><span class="hljs-keyword">if</span>(money &gt; <span class="hljs-number">5000</span>)&#123;<br>rtValue = method.invoke(actor, money/<span class="hljs-number">2</span>);<br>&#125; &#125;<br><span class="hljs-keyword">return</span> rtValue;<br>&#125;<br>&#125;);<br>cglibActor.basicAct(<span class="hljs-number">10000</span>);<br>cglibActor.dangerAct(<span class="hljs-number">100000</span>);<br>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-AOP的常见术语"><a href="#3-3-AOP的常见术语" class="headerlink" title="3.3.AOP的常见术语"></a>3.3.AOP的常见术语</h2><p>➊<strong>切面</strong></p><p>切面(Aspect) 是指封装横切到系统功能(例如事务处理)的类。</p><p>❷<strong>连接点</strong></p><p>连接点(Joinpoint)是指程序运行中的一些时间点， 例如方法的调用或异常的抛出。</p><p>❸<strong>切入点</strong></p><p>切入点(Poineu)是指需要处理的连接点。在Spring AOP中，所有的方法执行都是连接点，而切入点是一个描述信息， 它修饰的是连接点。</p><p>❹<strong>通知</strong></p><p>通知(Advice) 是由切面添加到特定的连接点(满足切入点规则)的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。</p><p>❺<strong>引入</strong></p><p>引入( Introduction)允许在现有的实现类中添加自定义的方法和属性。</p><p>❻<strong>目标对象</strong></p><p>目标对象(Target Object)是指所有被通知的对象。如果AOP框架使用运行时代理的方式(动态的AOP)来实现切面，那么通知对象总是一个代理对象。</p><p>❼<strong>代理</strong></p><p>代理(Proxy) 是通知应用到目标对象之后被动态创建的对象。</p><p>❽<strong>织人</strong></p><p>织入( Weaving)是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP 织入有3种方式:编译期织入，需要有特殊的Java 编译器;类装载期织入，需要有特殊的类装载器:动态代理织入，在运行期为目标类添加通知生成子类的方式。Spring AOP框架默认采用动态代理织入，而AspectJ (基于Java语言的AOP框架)</p><p><strong><a herf="https://blog.csdn.net/qq_42009262/article/details/105013992">Spring通知类型介绍</strong></p><p>根据Spring中通知在目标类方法的链接点位置，可以分为6种类型：</p><p><strong>（1）环绕通知：</strong></p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.aopalliance.itercept.MethodInterceptor</td><td align="right">在目标方法执行前和执行后实施增强。可以用于日志记录、事务处理等功能。</td></tr></tbody></table><p><strong>（2）前置通知：</strong></p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.springframework.aop.MethodBeforeAdvice</td><td align="right">在目标方法执行前实施增强。可以用于权限管理等功能。</td></tr></tbody></table><p><strong>（3）后置返回通知</strong>：</p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.springframework.aop.AfterReturningAdvice</td><td align="right">在目标方法成功执行后实施增强。可以用于关闭流、删除临时文件等功能。</td></tr></tbody></table><p><strong>（4）后置（最终）通知：</strong></p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.springframework.aop.AfterAdvice</td><td align="right">在目标方法执行后实施增强。与后置返回通知不同的是，不管是否发生异常都要执行该通知，可应用于释放资源。</td></tr></tbody></table><p><strong>（5）异常通知：</strong></p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.springframework.aop.ThrowsAdvice</td><td align="right">在方法抛出异常后实施增强。可以用于异常处理、记录日志等功能。</td></tr></tbody></table><p><strong>（6）引入通知：</strong></p><table><thead><tr><th align="center">实现接口</th><th align="right">功能描述</th></tr></thead><tbody><tr><td align="center">org.springframework.aop.IntroductInterceptor</td><td align="right">在目标类中添加一些新的方法和属性。可以用于修改目标类（增强类）。</td></tr></tbody></table><h2 id="3-4-基于XML配置开发"><a href="#3-4-基于XML配置开发" class="headerlink" title="3.4.基于XML配置开发"></a>3.4.基于XML配置开发</h2><p><strong>1.把通知类用 bean 标签配置起来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 配置通知 --&gt;<br> &lt;bean id=<span class="hljs-string">&quot;txManager&quot;</span> class=<span class="hljs-string">&quot;com.itheima.utils.TransactionManager&quot;</span>&gt; <br>&lt;property name=<span class="hljs-string">&quot;dbAssit&quot;</span> ref=<span class="hljs-string">&quot;dbAssit&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><strong>2.使用 aop:config 声明 aop 配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">作用：用于声明开始 aop 的配置<br>&lt;aop:config&gt;<br>&lt;!-- 配置的代码都写在此处 --&gt;<br>&lt;/aop:config&gt;<br></code></pre></td></tr></table></figure><p><strong>3.使用 aop:aspect 配置切面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">aop:aspect:<br>作用：<br>用于配置切面。<br>属性：<br>id：给切面提供一个唯一标识。<br>ref：引用配置好的通知类 bean 的 id。<br> &lt;aop:aspect id=<span class="hljs-string">&quot;txAdvice&quot;</span> ref=<span class="hljs-string">&quot;txManager&quot;</span>&gt;<br>&lt;!--配置通知的类型要写在此处--&gt;<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p><strong>4.使用 aop:pointcut 配置切入点表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">aop:pointcut：<br>作用：<br>用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。<br>属性：<br>expression：用于定义切入点表达式。<br>id：用于给切入点表达式提供一个唯一标识<br>&lt;aop:pointcut id=<span class="hljs-string">&quot;pt1&quot;</span> expression=<span class="hljs-string">&quot;execution(</span><br><span class="hljs-string">execution:匹配方法的执行(常用)</span><br><span class="hljs-string">execution(表达式)</span><br><span class="hljs-string">表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><strong>5.使用 aop:xxx 配置对应的通知类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">aop:before<br>作用：<br>用于配置前置通知。指定增强的方法在切入点方法之前执行<br>属性：<br>method:用于指定通知类中的增强方法名称<br>ponitcut-ref：用于指定切入点的表达式的引用<br>poinitcut：用于指定切入点表达式<br>执行时间点：<br>切入点方法执行之前执行<br>&lt;aop:before method=<span class="hljs-string">&quot;beginTransaction&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt1&quot;</span>/&gt;<br>aop:after-returning<br>作用：<br>用于配置后置通知<br>属性：<br>method：指定通知中方法的名称。<br>pointct：定义切入点表达式<br>pointcut-ref：指定切入点表达式的引用<br>执行时间点：<br>切入点方法正常执行之后。它和异常通知只能有一个执行<br>&lt;aop:after-returning method=<span class="hljs-string">&quot;commit&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt1&quot;</span>/&gt;<br>aop:after-throwing<br>作用：<br>用于配置异常通知<br>属性：<br>method：指定通知中方法的名称。<br>pointct：定义切入点表达式<br>pointcut-ref：指定切入点表达式的引用<br>执行时间点：<br>切入点方法执行产生异常后执行。它和后置通知只能执行一个<br>&lt;aop:after-throwing method=<span class="hljs-string">&quot;rollback&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt1&quot;</span>/&gt;<br>aop:after<br>作用：<br>用于配置最终通知<br>属性：<br>method：指定通知中方法的名称。<br>pointct：定义切入点表达式<br>pointcut-ref：指定切入点表达式的引用<br>执行时间点：<br>无论切入点方法执行时是否有异常，它都会在其后面执行。<br>&lt;aop:after method=<span class="hljs-string">&quot;release&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt1&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="3-5-基于注解开发"><a href="#3-5-基于注解开发" class="headerlink" title="3.5.基于注解开发"></a>3.5.基于注解开发</h2><p><strong>1.配置类的编写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages=&quot;包名&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.通知类的编写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;txManager&quot;)</span><br><span class="hljs-meta">@Aspect</span><span class="hljs-comment">//表明当前类是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><span class="hljs-comment">//定义一个 DBAssit</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DBAssit dbAssit ;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>3.在增强的方法上使用注解配置通知</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span><br>作用：<br>把当前方法看成是前置通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用。<br><span class="hljs-comment">//开启事务</span><br><span class="hljs-meta">@Before(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginTransaction</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; <br>&#125;<br><span class="hljs-meta">@AfterReturning</span><br>作用：<br>把当前方法看成是后置通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用<br><span class="hljs-comment">//提交事务</span><br><span class="hljs-meta">@AfterReturning(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().commit();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; &#125;<br><span class="hljs-meta">@AfterThrowing</span><br>作用：<br>把当前方法看成是异常通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用<br><span class="hljs-comment">//回滚事务</span><br><span class="hljs-meta">@AfterThrowing(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.getCurrentConnection().rollback();<br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>e.printStackTrace();<br>&#125; &#125;<br><span class="hljs-meta">@After</span><br>作用：<br>把当前方法看成是最终通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用<br><span class="hljs-comment">//释放资源</span><br><span class="hljs-meta">@After(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>dbAssit.releaseConnection();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br> &#125;<br> <span class="hljs-meta">@Around</span><br>作用：<br>把当前方法看成是环绕通知。<br>属性：<br>value：用于指定切入点表达式，还可以指定切入点表达式的引用。<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 环绕通知</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> pjp</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Pointcut</span><br>作用：<br>指定切入点表达式<br>属性：<br>value：指定表达式的内容<br><span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt1</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta">@Around(&quot;pt1()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transactionAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> &#123;<br><span class="hljs-comment">//定义返回值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">rtValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//获取方法执行所需的参数</span><br>Object[] args = pjp.getArgs();<br><span class="hljs-comment">//前置通知：开启事务</span><br>beginTransaction();<br><span class="hljs-comment">//执行方法</span><br>rtValue = pjp.proceed(args);<br><span class="hljs-comment">//后置通知：提交事务</span><br>commit();<br>&#125;<span class="hljs-keyword">catch</span>(Throwable e) &#123;<br><span class="hljs-comment">//异常通知：回滚事务</span><br>rollback();<br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//最终通知：释放资源</span><br>release();<br>&#125;<br><span class="hljs-keyword">return</span> rtValue;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>参考文献：[1] 陈恒，楼偶俊，张立杰.Java EE框架整和开发入门到实践[M].清华大学出版社，2018-：.39-45</strong><br><strong>案例来自于黑马程序员Spring教学</strong></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring框架的总结(二、Spring IoC)</title>
    <link href="/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%E3%80%81Spring-IoC/"/>
    <url>/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%E3%80%81Spring-IoC/</url>
    
    <content type="html"><![CDATA[<p>﻿# 关于Spring框架的总结（二、Spring IoC）</p><h2 id="2-Spring-IoC"><a href="#2-Spring-IoC" class="headerlink" title="2.Spring IoC"></a>2.Spring IoC</h2><blockquote><p>Spring IoC<br>2.1.Spring IoC的基本概念<br>2.2.Spring IoC容器<br>2.3.Spring IoC中的bean标签<br>2.4.依赖注入</p></blockquote><h2 id="2-1-Spring-IoC的基本概念"><a href="#2-1-Spring-IoC的基本概念" class="headerlink" title="2.1.Spring IoC的基本概念"></a><strong>2.1.Spring IoC的基本概念</strong></h2><p>控制反转(Inversion of Control, IoC)是一个比较抽象的概念，是Spring框架的核心，用来消减计算机程序的精合问题。<font color=red>对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</font >依赖注入(Dpendency Injection,DI)是IOC的另一种说法，只是换了种角度来描述相同的概念，下面举一个例子来解释IOC和DI。</p><p>当人们需要一件东西时， 第一反应就是找东西， 例如想吃面包。在没有面包店和有面包店两种情况下，您会怎么做?在没有面包店时，最直观的做法可能是您按照自己的口味制作面包，也就是一个面包需要主动制作。然而时至今日，各种网店、实体店盛行，已经没有必要自己制作面包。想吃面包了，去网店或实体店把自己的口味告诉店家，一会就可以吃到面包了。注意，您并没有制作面包，而是由店家制作，但是完全符合您的口味。</p><p>上面只是列举了一个非常简单的例子，但包含了控制反转的思想，即把制作面包等主动权交给店家。下面通过面向对象编程思想继续探讨这两个概念<p>当某个Java对象(调用者，例如您)需要调用另一个Java 对象(被调用者，即被依赖对象，例如面包)时，在传统编程模式下，调用者通常会采用“new被调用者”的代码方式来创建对象(例如您自已制作面包)。这种方式会增加调用者与被调用者之间的耦合性，不利于后期代码的升级与维护。</p><p><font color=red>当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器(例如面包店)来创建。Spring容器会负责控制程序之间的关系(例如面包店负责控制您与面包的关系)，而不是由调用者的程序代码直接控制。这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。</p><p>从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入它所依赖的实例，这就是Spring的依赖注入。</p><p>综上所述，控制反转是种通过描述 (在 Spring中可以是XML或注解)并通过第三方去产生或获取特定对象的方式。在Spring中实现控制反转的是loC容器，其实现方法是依赖注入。</p><h2 id="2-2-Spring-IoC容器"><a href="#2-2-Spring-IoC容器" class="headerlink" title="2.2.Spring IoC容器"></a><strong>2.2.Spring IoC容器</strong></h2><p><strong>1.Spring IoC容器设计主要是基于BeanFactoty和ApplicationContext两个接口。下图为spring工厂的类结构体</strong><br><img src="https://img-blog.csdnimg.cn/20200712110712194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA5MjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>BeanFactory 是 Spring 容器中的顶层接口，ApplicationContext 是它的子接口。</p><p><strong>2.BeanFactory 和 ApplicationContext 的区别</strong><br>BeanFactory 和 ApplicationContext 的区别：<br>创建对象的时间点不一样：</p><ul><li>（1.）BeanFactory：什么使用什么时候创建对象。</li><li>（2.）ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。</li></ul><p><strong>3.ApplicationContext 接口的实现类</strong></p><ul><li>3.1ClassPathXmlApplicationContext：从类的根路径(src根目录)寻找指定的XML配置文件 ，最常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化Spring容器ApplicationContext ，加载配置文件</span><br>ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXMLApplicationContext</span>（“ApplicationContext.xml”）<br></code></pre></td></tr></table></figure><ul><li>3.2FileSystemXmlApplicationContext：从磁盘的绝对路径中寻找指定的XML配置文件，配置文件可以在磁盘的任意位置（限制比较大，如果换了设备或者文件xml配置位置改变将找不到配置文件，不推荐）。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化Spring容器ApplicationContext ，加载配置文件</span><br>ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>（“D:\文件位置\src\ApplicationContext.xml”）<br></code></pre></td></tr></table></figure><ul><li>3.3AnnotationConfigApplicationContext:使用注解配置容器对象时，需要使用此类来创建 spring 容器。用来读取注解。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化Spring容器ApplicationContext ，加载配置文件</span><br>ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>（“注解配置类.class”）<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-3-Spring-IoC中的bean标签"><a href="#2-3-Spring-IoC中的bean标签" class="headerlink" title="2.3.Spring IoC中的bean标签"></a><strong>2.3.Spring IoC中的bean标签</strong></h2><p><strong>1.<code>&lt;bean&gt;</code>元素的常用属性及其子元素</strong></p><table><thead><tr><th>属性或子元素名称</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称</td></tr><tr><td>class</td><td>Bean的具体实现类，使用类的名</td></tr><tr><td>scope</td><td>指定Bean实例的作用域，具体属性值及含义</td></tr><tr><td><code>&lt;constructor-arg&gt;</code></td><td><code>&lt;bean&gt;</code>元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值</td></tr><tr><td><code>&lt;property&gt;</code></td><td><code>&lt;bean&gt;</code>元素的子元素，用于设置一个属性。该元素的name属性指定Bean实例中相应的属性名称，value 属性指定Bean的属性值，ref 属性指定属性对BeanFactory中其他Bean的引用关系</td></tr><tr><td><code>&lt;list&gt;</code></td><td><code>&lt;property&gt;</code>元素的子元素，用于封装List 或数组类型的依赖注入</td></tr><tr><td><code>&lt;map&gt;</code></td><td><code>&lt;property&gt;</code>元素的子元素，用于封装Map类型的依赖注入</td></tr><tr><td><code>&lt;set&gt;</code></td><td><code>&lt;property&gt;</code>元素的子元素，用于封装Set类型的依赖注入</td></tr><tr><td><code>&lt;entry&gt;</code></td><td><code>&lt;map&gt;</code>元素的子元素，用于设置一个键值对</td></tr></tbody></table><p><strong>2.bean 的作用范围和生命周期</strong><br>scope：指定对象的作用范围。</p><ul><li><font color=red>singleton :默认值，单例的.</li><li><font color=red> prototype :多例的.</li><li>request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</li><li>session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</li><li>global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么<br>globalSession 相当于 session.</li></ul><p><font color=red>单例对象：scope&#x3D;”singleton”</font><br>一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>生命周期：</p><ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。</li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ul><p><font color=red>多例对象：scope&#x3D;”prototype”</font><br>每次访问对象时，都会重新创建对象实例。<br>生命周期：</p><ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。</li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul><p><strong>3.bean的实例化</strong></p><ul><li><p>第一种方式：使用默认无参构造函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;类名&quot;</span> class=<span class="hljs-string">&quot;类位置&quot;</span>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 模拟一个静态工厂，创建业务层实现类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFactory</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IAccountService <span class="hljs-title function_">createAccountService</span><span class="hljs-params">()</span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountServiceImpl</span>();<br>&#125; &#125;<br>&lt;!-- 此种方式是:使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器<br>id 属性：指定 bean 的 id，用于从容器中获取<br>class 属性：指定静态工厂的全限定类名<br>factory-method 属性：指定生产对象的静态方法<br>--&gt;<br> &lt;bean id=<span class="hljs-string">&quot;accountService&quot;</span>   class=<span class="hljs-string">&quot;com.itheima.factory.StaticFactory&quot;</span>   <br>  factory-method=<span class="hljs-string">&quot;createAccountService&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure></li><li><p>第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 模拟一个实例工厂，创建业务层实现类</span><br><span class="hljs-comment">* 此工厂创建对象，必须现有工厂实例对象，再调用方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceFactory</span> &#123;<br><span class="hljs-keyword">public</span> IAccountService <span class="hljs-title function_">createAccountService</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountServiceImpl</span>();<br>&#125; &#125;<br>&lt;!-- 此种方式是：<br>先把工厂的创建交给 spring 来管理。<br>然后在使用工厂的 bean 来调用里面的方法<br>factory-bean 属性：用于指定实例工厂 bean 的 id。<br>factory-method 属性：用于指定实例工厂中创建对象的方法。<br>--&gt;<br> &lt;bean id=<span class="hljs-string">&quot;instancFactory&quot;</span> class=<span class="hljs-string">&quot;com.itheima.factory.InstanceFactory&quot;</span>&gt;&lt;/bean&gt;<br>  &lt;bean id=<span class="hljs-string">&quot;accountService&quot;</span>  factory-bean=<span class="hljs-string">&quot;instancFactory&quot;</span><br> factory-method=<span class="hljs-string">&quot;createAccountService&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-4-依赖注入"><a href="#2-4-依赖注入" class="headerlink" title="2.4.依赖注入"></a><strong>2.4.依赖注入</strong></h2><p><strong>在Spring中实现IoC容器的方法是依赖注入，依赖注入的作用是在使用Spring框架创建对象时动态地将其所依赖的对象(例如属性值)注入Bean组件中。Spring框架的依赖注入通常有两种实现方式，一种是使用构造方法注入，另一种是使用属性的setter方法注入。</strong></p><p><strong>1.使用构造方法注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 使用构造函数的方式，给 service 中的属性传值<br>要求：<br>类中需要提供一个对应参数列表的构造函数。<br>涉及的标签：<br>constructor-arg<br>属性：<br>index:指定参数在构造函数参数列表的索引位置<br>type:指定参数在构造函数中的数据类型<br>name:指定参数在构造函数中的名称 用这个找给谁赋值<br>=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============<br>value:它能赋的值是基本数据类型和 String 类型<br>ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean<br>--&gt; <br>&lt;bean id=<span class="hljs-string">&quot;类&quot;</span> class=<span class="hljs-string">&quot;类的位置&quot;</span>&gt; <br>&lt;constructor-arg name=<span class="hljs-string">&quot;属性名&quot;</span> value=<span class="hljs-string">&quot;属性值&quot;</span>&gt;&lt;/constructor-arg&gt; <br>&lt;constructor-arg name=<span class="hljs-string">&quot;属性名&quot;</span> ref=<span class="hljs-string">&quot;其他bean类型的id&quot;</span>&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt; <br>&lt;bean id=<span class="hljs-string">&quot;其他bean类型的id&quot;</span> class=<span class="hljs-string">&quot;类型&quot;</span>&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><strong>2.使用属性的setter方法注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式<br>涉及的标签：<br>property<br>name：找的是类中 set 方法后面的部分<br>ref：给属性赋值是其他 bean 类型的<br>value：给属性赋值是基本数据类型和 string 类型的<br>实际开发中，此种方式用的较多。<br>--&gt; <br>&lt;bean id=<span class="hljs-string">&quot;类&quot;</span> class=<span class="hljs-string">&quot;类的位置&quot;</span>&gt; <br>&lt;property name=<span class="hljs-string">&quot;属性名&quot;</span> value=<span class="hljs-string">&quot;属性值&quot;</span>&gt;&lt;/property&gt; <br>&lt;property name=<span class="hljs-string">&quot;属性名&quot;</span> ref=<span class="hljs-string">&quot;其他bean类型的id&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt; <br>&lt;bean id=<span class="hljs-string">&quot;其他bean类型的id&quot;</span> class=<span class="hljs-string">&quot;类型&quot;</span>&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><strong>参考文献：[1] 陈恒，楼偶俊，张立杰.Java EE框架整和开发入门到实践[M].清华大学出版社，2018-：.12-16</strong><br><strong>案例来自于黑马程序员Spring教学</strong></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring框架的总结（一、spring的简单概述）</title>
    <link href="/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%E3%80%81spring%E7%9A%84%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/09/22/%E5%85%B3%E4%BA%8ESpring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%E3%80%81spring%E7%9A%84%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>﻿# 关于Spring框架的总结（一、spring的简单概述）</p><h2 id="1-简介概述"><a href="#1-简介概述" class="headerlink" title="1.简介概述"></a>1.简介概述</h2><blockquote><p>关于Spring框架的简单介绍<br>1.1.什么是spring？<br>1.2.spring框架有哪些特点优势？<br>1.3.spring框架的体系结构</p></blockquote><h2 id="1-1-什么是spring"><a href="#1-1-什么是spring" class="headerlink" title="1.1.什么是spring"></a><strong>1.1.什么是spring</strong></h2>   <p>    Spring是一个轻量级Java开发框架，最早由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/EE full-stack(-站式)轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。<font color=red>以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核</font color=red>，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库。Spring 负责基础架构，因此Java开发者可以专注于应用程序的开发。   </p><h2 id="1-2-spring框架有哪些特点优势？"><a href="#1-2-spring框架有哪些特点优势？" class="headerlink" title="1.2.spring框架有哪些特点优势？"></a>1.2.spring框架有哪些特点优势？</h2><p>1.降低组件之间的耦合性，通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。</p><p>2.对AOP编程的支持，方便面向切面编程。</p><p>3.通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</p><p>4.方便集成各种优秀框架，如hibernate,Struts2,JPA等</p><p>5.Spring具有高度可开放性，并不强制依赖于Spring，可以自由选择Spring部分或全部</p><p>6.方便程序的测试，可以用非容器依赖的编程方式进行几乎所有的测试工作。</p><h2 id="1-3-spring框架的体系结构"><a href="#1-3-spring框架的体系结构" class="headerlink" title="1.3.spring框架的体系结构"></a>1.3.spring框架的体系结构</h2><p>Spring框架至今已集成20多个模块，这些模块发布在核心容器（Core Container）、数据访问&#x2F;集成(Data Access&#x2F;Integration) 层. Web层. AOP ( Aspect Oriented Programming,<br>面向切面的编程)模块、植入(Instrumentation) 模块、消息传输(Messaging)和测试(Test)模块中，如下图。</p><p><img src="https://img-blog.csdnimg.cn/20200709115142920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA5MjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>1、核心容器</strong><br>Spring的核心容器是其他模块建立的基础，由Spring core 、Spring beans、 Sping comtext、Spring context-support和Spring expression (Spring 表达式语言)等模块组成。</p><table><thead><tr><th>模块</th><th>功能作用</th></tr></thead><tbody><tr><td>Spring-core 模块</td><td>提供了框架的基本组成部分，包括控制反转(Inversion of Control,IoC)和依赖注入(Dependency Injection, DI)功能。</td></tr><tr><td>Spring-beans模块</td><td>提供了BeanFactory, 是工厂模式的一个经典实现，Spring将管理对象称为Bean。</td></tr><tr><td>Spring-context 模块</td><td>建立在Core和Beans模块的基础之上，提供一个框架式的对象访问方式，是访问定义和配置的任何对象的媒介。ApplicationContext 接口是Context模块的焦点。</td></tr><tr><td>Spring-context-support 模块</td><td>支持整合第三方库到Spring 应用程序上下文，特别是用于高速缓存(EhCache、JCache)和任务调度(CommonJ、Quartz) 的支持。</td></tr><tr><td>Spring-expression 模块</td><td>提供了强大的表达式语言去支持运行时查询和操作对象图。这是对JSP2.1规范中规定的统一表达式语言 (UnifiedEL) 的扩展。该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IoC容器中以名称检索对象。它还支持列表投影、选择以及常见的列表聚合。</td></tr></tbody></table><p><strong>2.AOP和Instrumentation</strong></p><table><thead><tr><th>模块</th><th>功能作用</th></tr></thead><tbody><tr><td>Spring-aop 模块</td><td>提供了一个符合AOP要求的面向切面的编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以便干净地解耦。</td></tr><tr><td>Spring-aspects模块</td><td>提供了与AspectJ的集成功能，AspectJ 是一个功能强大且成熟的AOP框架</td></tr><tr><td>Spring istrument模块</td><td>提供了类植入(nstrumentatonon) 支持和类加载器的实现，可以在特定的应用服务器中使用。</td></tr></tbody></table><p><strong>3.消息</strong></p><blockquote><p>spring 4.0以后新增了消息(Spring messaging)模块，该模块提供了对消息传递体系结构和协议的支持</p></blockquote><p><strong>4数据访问&#x2F;集成</strong></p><blockquote><p>数据访间集成层由JDBC、ORM. OXM. JMS和事务模块组成。</p></blockquote><table><thead><tr><th>模块</th><th>功能作用</th></tr></thead><tbody><tr><td>Spring-jdbc模块</td><td>提供了一个 JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析。</td></tr><tr><td>Spring om模块</td><td>为流行的对象关系映射(Objeet Relational Mapping) API提供集成层，包括JPA和Hibemate.使用Spring orm模块可以将这些O&#x2F;R映射框架与Spring提供的所有其他功能结合使用，例如声明式事务管理功能。</td></tr><tr><td>Spring-oxm 模块</td><td>提供了一个支持对象&#x2F;XML映射的抽象层实现，例如JAXB、Castor、 JiBX和XStream。</td></tr><tr><td>Spring-jms 模块(Java Messaging Serice)</td><td>指Java消息传递服务，包含用于生产和使用消息的功能。自Sping.1以后，提供了与Spring mesgingg模块的集成。</td></tr><tr><td>Sping-tg模块(事务模块)</td><td>支持用于实现特殊接口和所有POIO (普通Java对象)类的编程和事务式声明管理</td></tr></tbody></table><p><strong>5.Web</strong></p><blockquote><p>Web层由Spring-web. Spring webmvc、Spring websocket和Portet模块组成。</p></blockquote><table><thead><tr><th>模块</th><th>功能作用</th></tr></thead><tbody><tr><td>Spring-web模块</td><td>提供了基本的Web开发集成功能， 例如多文件上传功能、使用Servlet监听器初始化一个 loC容器以及Web应用上下文。</td></tr><tr><td>Spring-webmvc模块</td><td>也称为Web-Servlet模块，包含用于Web应用程序的SpringMVC和REST Web Services实现。Spring MVC框架提供了领城模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成</td></tr><tr><td>Spring-websocket 模块</td><td>Spring 4.0以后新增的模块，它提供了WebSocket和SockJS的实现。</td></tr><tr><td>Portler模块</td><td>类似于Serlet模块的功能，提供了Porlet环境下的MVC实现。</td></tr></tbody></table><p><strong>6.测试</strong></p><blockquote><p>Spring-test 模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p></blockquote><p>参考文献：[1] 陈恒，楼偶俊，张立杰.Java EE框架整和开发入门到实践[M].清华大学出版社，2018-：.1-7</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang内存分配与内存逃逸</title>
    <link href="/2022/09/20/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"/>
    <url>/2022/09/20/Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Go内存分配与内存逃逸"><a href="#Go内存分配与内存逃逸" class="headerlink" title="Go内存分配与内存逃逸"></a>Go内存分配与内存逃逸</h1><h2 id="内存为什么需要管理"><a href="#内存为什么需要管理" class="headerlink" title="内存为什么需要管理"></a>内存为什么需要管理</h2><p>当存储的东西越来越多，也就发现物理内存的容量依然是不够用，那么对物理内存的利用率和合理的分配，管理就变得非常的重要。</p><p>（1）操作系统就会对内存进行非常详细的管理。</p><p>（2）基于操作系统的基础上，不同语言的内存管理机制也应允而生，有的一些语言并没有提供自动的内存管理模式，有的语言就已经提供了自身程序的内存管理模式，如表2所示。</p><h6 id="表2-自动与非自动内存管理的语言"><a href="#表2-自动与非自动内存管理的语言" class="headerlink" title="表2 自动与非自动内存管理的语言"></a>表2 自动与非自动内存管理的语言</h6><table><thead><tr><th><strong>内存自动管理的语言（部分）</strong></th><th><strong>内存非自动管理的语言（部分）</strong></th></tr></thead><tbody><tr><td>Golang</td><td>C</td></tr><tr><td>Java</td><td>C++</td></tr><tr><td>Python</td><td>Rust</td></tr></tbody></table><p>所以为了降低内存管理的难度，像C、C++这样的编程语言会完全将分配和回收内存的权限交给开发者，而Rust则是通过生命周期限定开发者对非法权限内存的访问来自动回收，因而并没有提供自动管理的一套机制。但是像Golang、Java、Python这类为了完全让开发则关注代码逻辑本身，语言层提供了一套管理模式。因为Golang编程语言给开发者提供了一套内存管理模式，所以开发者有必要了解一下Golang做了哪些助力的功能。</p><p>在理解Golang语言层内存管理之前，应先了解操作系统针对物理内存做了哪些管理的方式。当插上内存条之后，通过操作系统是如何将软件存放在这个绿色的物理内存条中去的。</p><h2 id="为什么需要关心内存分配问题"><a href="#为什么需要关心内存分配问题" class="headerlink" title="为什么需要关心内存分配问题"></a><strong>为什么需要关心内存分配问题</strong></h2><hr><p>每个工程师的时间都如此宝贵，在继续读这篇文章之前，需要你先回答几个问题，如果得到的答案是否定的，那可能本文章里写的内容对你并没有什么帮助。但是，如果你遇到了因内存分配而导致的性能问题，可能这篇文章能带你理解 Golang 的内存分配的冰山一角，带你入个门。</p><p>问题如下：</p><ul><li>你的程序是性能敏感型吗？</li><li>GC 带来的延迟影响到了你的程序性能吗？</li><li>你的程序有过多的堆内存分配吗？</li></ul><p>如果你命中上面问题的其中一个或两个，那这篇文章适合你继续读下去。或你根本不知道如何回答这些问题，可能去了解下 go 性能观测相关的知识（pprof 的使用等）对你更有帮助。</p><p><strong>下面正文开始。</strong></p><h2 id="Golang-简要内存划分"><a href="#Golang-简要内存划分" class="headerlink" title="Golang 简要内存划分"></a><strong>Golang 简要内存划分</strong></h2><hr><p><img src="https://ask.qcloudimg.com/http-save/5469577/b1e2510bc404791b9a0909da0a0f1a99.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>可以简单的认为 Golang 程序在启动时，会向操作系统申请一定区域的内存，分为栈（Stack）和堆（Heap）。栈内存会随着函数的调用分配和回收；堆内存由程序申请分配，由垃圾回收器（Garbage Collector）负责回收。性能上，栈内存的使用和回收更迅速一些；尽管Golang 的 GC 很高效，但也不可避免的会带来一些性能损耗。因此，Go 优先使用栈内存进行内存分配。在不得不将对象分配到堆上时，才将特定的对象放到堆中。</p><h2 id="内存分配过程分析"><a href="#内存分配过程分析" class="headerlink" title="内存分配过程分析"></a><strong>内存分配过程分析</strong></h2><hr><p>本部分，将以代码的形式，分别介绍栈内存分配、指针作为参数情况下的栈内存分配、指针作为返回值情况下的栈内存分配并逐步引出逃逸分析和几个内存逃逸的基本原则。</p><p>正文开始，Talk is cheap，show me the code。</p><h2 id="栈内存分配"><a href="#栈内存分配" class="headerlink" title="栈内存分配"></a><strong>栈内存分配</strong></h2><p>我将以一段简单的代码作为示例，分析这段代码的内存分配过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;  n := <span class="hljs-number">4</span>  n2 := <span class="hljs-title function_">square</span>(n)  fmt.<span class="hljs-title class_">Println</span>(n2)&#125;<br>func <span class="hljs-title function_">square</span>(n int) int&#123;  <span class="hljs-keyword">return</span> n * n&#125;<br></code></pre></td></tr></table></figure><p>复制</p><p>代码的功能很简单，一个 main 函数作为程序入口，定义了一个变量n，定义了另一个函数 squire ，返回乘方操作后的 int 值。最后，将返回的值打印到控制台。程序输出为16。</p><p>下面开始逐行进行分析，解析调用时，go 运行时是如何对内存进行分配的。</p><p><img src="https://ask.qcloudimg.com/http-save/5469577/479e83aa67b17d920bd71f6625afe1c9.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>当代码运行到第6行，进入 main 函数时，会在栈上创建一个 Stack frame，存放本函数中的变量信息。包括函数名称，变量等。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/h4jok0khik.png?imageView2/2/w/1620" alt="img"></p><p>当代码运行到第7行时，go 会在栈中压入一个新的 Stack Frame，用于存放调用 square 函数的信息；包括函数名、变量 n 的值等。此时，计算4 * 4 的值，并返回。</p><p><img src="https://ask.qcloudimg.com/http-save/5469577/e595bc8e8421e68646c147ea1cb411ab.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>当 square 函数调用完成，返回16到 main 函数后，将16赋值给 n2变量。注意，原来的 stack frame 并不会被 go 清理掉，而是如栈左侧的箭头所示，被标记为不合法。上图夹在红色箭头和绿色箭头之间的横线可以理解为 go 汇编代码中的 SP 栈寄存器的值，当程序申请或释放栈内存时，只需要修改 SP 寄存器的值，这种栈内存分配方式省掉了清理栈内存空间的耗时【1】。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/m6ls2qtdbl.png?imageView2/2/w/1620" alt="img"></p><p>接下来，调用 fmt.Println 时，SP 寄存器的值会进一步增加，覆盖掉原来 square 函数的 stack frame，完成 print 后，程序正常退出。</p><h2 id="指针作为参数情况下的栈内存分配"><a href="#指针作为参数情况下的栈内存分配" class="headerlink" title="指针作为参数情况下的栈内存分配"></a><strong>指针作为参数情况下的栈内存分配</strong></h2><p>还是同样的过程，看如下这段代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;  n := <span class="hljs-number">4</span>  <span class="hljs-title function_">increase</span>(&amp;n)  fmt.<span class="hljs-title class_">Println</span>(n)&#125;<br>func <span class="hljs-title function_">increase</span>(<span class="hljs-params">i *int</span>) &#123;  *i++&#125;<br></code></pre></td></tr></table></figure><p>main 作为程序入口，声明了一个变量 n，赋值为4。声明了一个函数  increase，使用一个 int 类型的指针 i 作为参数，increase 函数内，对指针 i 对应的值进行自增操作。最后 main 函数中打印了 n 的值。程序输出为5。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/7snaopjz26.png?imageView2/2/w/1620" alt="img"></p><p>当程序运行到 main 函数的第6行时，go 在栈上分配了一个 stack frame ，对变量 n 进行了赋值，n 在内存中对应的地址为0xc0008771，此时程序将继续向下执行，调用 increase 函数。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/nzbfzfdkup.png?imageView2/2/w/1620" alt="img"></p><p>这时，increase 函数对应的 stack fream 被创建，i 被赋值为变量 n对应的地址值0xc0008771，然后进行自增操作。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/u14njxdglz.png?imageView2/2/w/1620" alt="img"></p><p>当 increase 函数运行结束后，SP 寄存器会上移，将之前分配的 stack freme 标记为不合法。此时，程序运行正常，并没有因为 SP 寄存器的改动而影响程序的正确性，内存中的值也被正确的修改了。</p><h2 id="指针作为返回值情况下的栈内存分配"><a href="#指针作为返回值情况下的栈内存分配" class="headerlink" title="指针作为返回值情况下的栈内存分配"></a><strong>指针作为返回值情况下的栈内存分配</strong></h2><p>文章之前的部分分别介绍了普通变量作为参数和将指针作为参数情况下的栈内存使用，本部分来介绍将指针作为返回值，返回给调用方的情况下，内存是如何分配的，并引出内存逃逸相关内容。来看这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;  n := <span class="hljs-title function_">initValue</span>()  fmt.<span class="hljs-title class_">Println</span>(*n/<span class="hljs-number">2</span>)&#125;<br>func <span class="hljs-title function_">initValue</span>() *int &#123;  i := <span class="hljs-number">4</span>  <span class="hljs-keyword">return</span> &amp;i&#125;<br></code></pre></td></tr></table></figure><p>main 函数中，调用了 initValue 函数，该函数返回一个 int 指针并赋值给 n，指针对应的值为4。随后，main 函数调用 fmt.Println 打印了指针 n &#x2F; 2对应的值。程序输出为2。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/945gf1ih2a.png?imageView2/2/w/1620" alt="img"></p><p>程序调用 initValue 后，将 i 的地址赋值给变量 n 。注意，如果这时，变量 i 的位置在栈上，则可能会随时被覆盖掉。</p><p><img src="https://ask.qcloudimg.com/developer-images/article/5469577/8ydk3bi2lv.png?imageView2/2/w/1620" alt="img"></p><p>在调用 fmt.Println 时，Stack Frame 会被重新创建，变量 i 被赋值为*n&#x2F;2也就是2，会覆盖掉原来 n 所指向的变量值。这会导致及其严重的问题。在面对 sharing up 场景时，go 通常会将变量分配到堆中，如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/5469577/16ab1617ecd4832e038e07e9a612fd69.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>通过上面的分析，可以看到在面对被调用的函数返回一个指针类型时将对象分配到栈上会带来严重的问题，因此 Go 将变量分配到了堆上。这种分配方式保证了程序的安全性，但也不可避免的增加了堆内存创建，并需要在将来的某个时候，需要 GC 将不再使用的内存清理掉。</p><h2 id="内存分配原则"><a href="#内存分配原则" class="headerlink" title="内存分配原则"></a><strong>内存分配原则</strong></h2><hr><p>经过上述分析，可以简单的归纳几条原则。</p><ul><li>Sharing down typically stays on the stack 在调用方创建的变量或对象，通过参数的形式传递给被调用函数，这时，在调用方创建的内存空间通常在栈上。这种在调用方创建内存，在被调用方使用该内存的“内存共享”方式，称之为 Sharing down。</li><li>Sharing up typically escapes to the heap 在被调用函数内创建的对象，以指针的形式返回给调用方的情况下，通常，创建的内存空间在堆上。这种在被调用方创建，在调用方使用的“内存共享”方式，称之为 Sharing up。</li><li>Only the compiler knows 之所以上面两条原则都加了通常，因为具体的分配方式，是由编译器确定的，一些编译器后端优化，可能会突破这两个原则，因此，具体的分配逻辑，只有编译器（或开发编译器的人）知道。</li></ul><h2 id="使用-go-build-命令确定内存逃逸情况"><a href="#使用-go-build-命令确定内存逃逸情况" class="headerlink" title="使用 go build 命令确定内存逃逸情况"></a><strong>使用 go build 命令确定内存逃逸情况</strong></h2><hr><p>值得注意的是，Go 在判断一个变量或对象是否需要逃逸到堆的操作，是在编译器完成的；也就是说，当代码写好后，经过编译器编译后，会在二进制中进行特定的标注，声明指定的变量要被分配到堆或栈。可以使用如下命令在编译期打印出内存分配逻辑，来具体获知特定变量或对象的内存分配位置。</p><p>查看 go help 可以看到 go build 其实是在调用 go tool compile。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">go help build ... -gcflags <span class="hljs-string">&#x27;[pattern=]arg list&#x27;</span>        <span class="hljs-variable language_">arguments</span> to pass on each go tool compile invocation....<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">go tool compile -h...-m    print optimization decisions...-l    disable inlining...<br></code></pre></td></tr></table></figure><p>其中，需要关心的参数有两个，</p><ul><li>-m 显示优化决策</li><li>-l 禁止使用内联【2】</li></ul><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package main<br>func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;  n := <span class="hljs-title function_">initValue</span>()  <span class="hljs-title function_">println</span>(*n / <span class="hljs-number">2</span>)<br>  o := <span class="hljs-title function_">initObj</span>()  <span class="hljs-title function_">println</span>(o)<br>  f := <span class="hljs-title function_">initFn</span>()  <span class="hljs-title function_">println</span>(f)<br>  num := <span class="hljs-number">5</span>  result := <span class="hljs-title function_">add</span>(num)  <span class="hljs-title function_">println</span>(result)&#125;<br>func <span class="hljs-title function_">initValue</span>() *int &#123;  i := <span class="hljs-number">3</span>                <span class="hljs-comment">// ./main.go:19:2: moved to heap: i  return &amp;i&#125;</span><br>type <span class="hljs-title class_">Obj</span> struct &#123;  i int&#125;<br>func <span class="hljs-title function_">initObj</span>() *<span class="hljs-title class_">Obj</span> &#123;  <span class="hljs-keyword">return</span> &amp;<span class="hljs-title class_">Obj</span>&#123;<span class="hljs-attr">i</span>: <span class="hljs-number">3</span>&#125;      <span class="hljs-comment">// ./main.go:28:9: &amp;Obj literal escapes to heap&#125;</span><br>func <span class="hljs-title function_">initFn</span>() <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">// ./main.go:32:9: func literal escapes to heap    println(&quot;I am a function&quot;)  &#125;&#125;</span><br>func <span class="hljs-title function_">add</span>(i int) int &#123;  <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>完整的构建命令和输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">go build -gcflags=<span class="hljs-string">&quot;-m -l&quot;</span> <br># _/<span class="hljs-title class_">Users</span>/rocket/workspace/stack-or-heap./main.<span class="hljs-property">go</span>:<span class="hljs-number">19</span>:<span class="hljs-number">2</span>: moved to <span class="hljs-attr">heap</span>: i./main.<span class="hljs-property">go</span>:<span class="hljs-number">24</span>:<span class="hljs-number">9</span>: &amp;<span class="hljs-title class_">Obj</span> literal escapes to heap./main.<span class="hljs-property">go</span>:<span class="hljs-number">28</span>:<span class="hljs-number">9</span>: func literal escapes to heap<br></code></pre></td></tr></table></figure><p>可以看到，sharing up 的情况（initValue，initObj，initFn）内存空间被分配到了堆上。sharing down 的情况（add）内存空间在栈上。</p><p>这里给读者留个问题，大家可以研究下 moved to heap 和 escapes to heap 的区别。</p><h1 id="内存逃逸"><a href="#内存逃逸" class="headerlink" title="内存逃逸"></a>内存逃逸</h1><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a><strong>怎么答</strong></h2><p><code>golang程序变量</code>会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在<code>栈上</code>分配。否则就说它 <code>逃逸</code> 了，必须在<code>堆上分配</code>。</p><p>能引起变量逃逸到堆上的<strong>典型情况</strong>：</p><ul><li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 <a href="https://www.zhihu.com/search?q=goroutine&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22145468000%22%7D">goroutine</a> 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li><li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h2><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br> s <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-comment">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> *A &#123;<br> a := <span class="hljs-built_in">new</span>(A) <br> a.s = s<br> <span class="hljs-keyword">return</span> a <span class="hljs-comment">//返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> a := foo(<span class="hljs-string">&quot;hello&quot;</span>)<br> b := a.s + <span class="hljs-string">&quot; world&quot;</span><br> c := b + <span class="hljs-string">&quot;!&quot;</span><br> fmt.Println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -gcflags=-m main.<span class="hljs-keyword">go</span><br># command-line-arguments<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">6</span>: can inline foo<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10</span>: inlining call to foo<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span>:<span class="hljs-number">13</span>: inlining call to fmt.Println<br>/<span class="hljs-keyword">var</span>/folders/<span class="hljs-number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="hljs-keyword">go</span>-build409982591/b001/_gomod_.<span class="hljs-keyword">go</span>:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>: can inline init<span class="hljs-number">.0</span><br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>:<span class="hljs-number">10</span>: leaking param: s<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>:<span class="hljs-number">10</span>: <span class="hljs-built_in">new</span>(A) escapes to heap<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span>:<span class="hljs-number">13</span>: io.Writer(os.Stdout) escapes to heap<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span>:<span class="hljs-number">13</span>: c escapes to heap<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>:<span class="hljs-number">9</span>: b + <span class="hljs-string">&quot;!&quot;</span> escapes to heap<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10</span>: main <span class="hljs-built_in">new</span>(A) does not escape<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>:<span class="hljs-number">11</span>: main a.s + <span class="hljs-string">&quot; world&quot;</span> does not escape<br>./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span>:<span class="hljs-number">13</span>: main []<span class="hljs-keyword">interface</span> &#123;&#125; literal does not escape<br>&lt;autogenerated&gt;:<span class="hljs-number">1</span>: os.(*File).<span class="hljs-built_in">close</span> .this does not escape<br></code></pre></td></tr></table></figure><ul><li><code>./main.go:8:10: new(A) escapes to heap</code> 说明 <code>new(A)</code> 逃逸了,符合上述提到的常见情况中的第一种。</li><li><code>./main.go:14:11: main a.s + &quot; world&quot; does not escape</code> 说明 <code>b</code> 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。</li><li><code>./main.go:15:9: b + &quot;!&quot; escapes to heap</code> 说明 <code>c</code> 变量逃逸，通过<code>fmt.Println(a ...interface&#123;&#125;)</code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。</li><li>以上操作其实就叫<strong>逃逸分析</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><hr><p>1.因为栈比堆更高效，不需要 GC，因此 Go 会尽可能的将内存分配到栈上。</p><p>2.当分配到栈上可能引起非法内存访问等问题后，会使用堆，主要场景有：</p><ol><li>当一个值可能在函数被调用后访问，这个值极有可能被分配到堆上。</li><li>当编译器检测到某个值过大，这个值会被分配到堆上。</li><li>当编译时，编译器不知道这个值的大小（slice、map…）这个值会被分配到堆上。</li></ol><p>3.Sharing down typically stays on the stack</p><p>4.Sharing up typically escapes to the heap</p><p>5.Don’t guess, Only the compiler knows</p><p>6.Golang中一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><p>【1】Go语言设计与实现：<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E5%AF%84%E5%AD%98%E5%99%A8">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E5%AF%84%E5%AD%98%E5%99%A8</a></p><p>【2】Inlining optimisations in Go：<a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go">https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go</a></p><p>【3】Golang FAQ：<a href="https://golang.org/doc/faq#stack_or_heap">https://golang.org/doc/faq#stack_or_heap</a></p><p>【4】知乎：<a href="https://zhuanlan.zhihu.com/p/145468000">https://zhuanlan.zhihu.com/p/145468000</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang为什么不用Java的gc模式</title>
    <link href="/2022/09/12/Golang%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Java%E7%9A%84gc%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/12/Golang%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Java%E7%9A%84gc%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang为什么不用Java的gc模式"><a href="#Golang为什么不用Java的gc模式" class="headerlink" title="Golang为什么不用Java的gc模式"></a>Golang为什么不用Java的gc模式</h1><blockquote><p><strong>为什么Go、Julia 和 Rust 等现代语言不需要像 Java C# 那样复杂的垃圾收集器？</strong></p></blockquote><p>为了解释原因，我们需要了解垃圾收集器是如何工作的，以及不同的语言如何以不同的方式分配内存。我们首先了解为什么 Java 特别需要如此复杂的垃圾收集器。</p><p>以下面几个主题为出发点来做相关介绍：</p><ul><li>为什么 Java 如此依赖快速 GC。介绍 Java 语言本身中对 GC 造成很大压力的一些设计选择。</li><li>内存碎片以及它如何影响 GC 设计。为什么这对 Java 很重要，而对 Go 却没有那么重要。</li><li>值类型以及它们如何改变 GC 。</li><li>分代GC以及为什么 Go 不需要。</li><li>逃逸分析——Go 如何用来减少 GC 压力的技巧。</li><li>分代 垃圾收集器——在 Java 世界中很重要，但 Go 以某种方式避免了对它的需求。为什么？</li><li>Concurrent Garbage Collection — Go 如何通过使用多个线程运行并发垃圾收集器来解决许多 GC 挑战。为什么使用 Java 更难做到这一点。</li><li>对 Go GC 的常见批评以及为什么批评背后的许多假设通常是有缺陷或完全错误的。</li><li>为什么低延迟对 Java 也很重要</li></ul><h2 id="为什么-Java-比其他人更需要快速-GC"><a href="#为什么-Java-比其他人更需要快速-GC" class="headerlink" title="为什么 Java 比其他人更需要快速 GC"></a>为什么 Java 比其他人更需要快速 GC</h2><p><strong>背景：</strong>Java 设计工作开始时。垃圾收集器风靡一时。研究看起来很有希望，Java 的设计者将赌注押在高级垃圾收集器上，这些垃圾收集器能够从根本上解决管理内存方面的所有挑战。</p><p>出于这个原因，Java 中的所有对象都设计为在堆上分配，但整数和浮点值等原始类型除外。在谈到内存分配时，我们一般会区分所谓的堆和栈。堆栈使用起来非常快，但空间有限，只能用于在函数调用的生命周期之后不需要存在的对象。它仅适用于局部变量。堆可用于所有对象。Java 基本上忽略了堆栈并选择在堆上分配所有内容，除了整数和浮点数等原语。每当您<code>new Something()</code>使用 Java 编写代码时，都会消耗堆上的内存。</p><p>然而，这种类型的内存管理在内存使用方面实际上是相当昂贵的。你会认为创建一个只有 32 位整数的对象只需要 4 个字节的内存。</p><p>但是，为了让垃圾收集器工作，Java 会存储一个标头，其中包含以下信息：</p><ul><li>类型 — 标识对象的类别或类型。</li><li>Lock — 用于同步语句。</li><li>标记 - 在垃圾收集器的标记和扫描面期间使用。</li></ul><p>该数据通常为 16 个字节。因此，标题数据与实际数据的比率为 4:1。Java 对象的 C++ 源代码定义为：<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/oop.hpp">OpenJDK Base Class</a>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">oopDesc</span> &#123;<br>    volatile markOop  _mark;   <span class="hljs-comment">// for mark and sweep</span><br>    Klass*           _klass;   <span class="hljs-comment">// the type</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>当 Java 分配一个对象数组时，它真正做的是创建一个引用数组，指向内存中某个其他位置的对象。这些对象最终可能分散在堆内存周围。这对性能不利，因为现代微处理器不读取单个数据字节。因为启动内存传输很慢，微处理器每次尝试访问一个特定的内存位置时总是读取一个大的连续内存块。</p><p><img src="https://cdn.jsdelivr.net/gh/longpi1/blog-img/20220912124051.png"></p><p>这块内存称为高速缓存行。CPU 有自己的高速内存，称为高速缓存。这比主存储器小得多。它用于存储最近访问的对象，因为这些对象很可能会再次被访问。如果主内存是碎片化的，这意味着高速缓存行将被碎片化，CPU 高速缓存将被大量无用数据填满。</p><p><strong>Java如何克服内存碎片</strong></p><p>为了解决这些主要缺点，Java 维护人员在高级垃圾收集器上投入了大量资金。这些做一些称为<em>压缩</em>的事情。压缩涉及在内存中移动对象并将它们收集到内存中的连续块中。这并不便宜。不仅将块从一个内存位置移动到另一个内存位置会消耗 CPU 周期，而且更新对这些对象的每个引用以指向新位置也会消耗 CPU 周期。</p><p>进行这些更新需要冻结所有线程。您不能在使用它们时更新参考。这通常会导致 Java 程序完全冻结数百毫秒，其中对象移动、引用更新和未使用的内存回收。</p><p><strong>增加复杂性</strong></p><p>为了减少这些长时间的停顿，Java 使用了所谓的<em>分代垃圾收集器</em>. 这些都是基于以下前提：</p><blockquote><p>程序中分配的大多数值很快就会被使用，因此 GC 可以花更多时间查看最近分配的对象。</p></blockquote><p>这就是为什么 Java 将它们分配的对象分成两组：</p><ul><li>旧对象——在 GC 的多次标记和清除操作中幸存下来的对象。每次标记和扫描都会更新生成计数器，以跟踪对象的年龄。</li><li>年轻对象——这些对象的生成计数器较低。这意味着它们最近才被分配。</li></ul><p>Java 更积极地调查最近分配的对象并检查它们是否应该被回收或移动。随着对象年龄的增长，它们会被移出年轻代区域。</p><p>所有这些自然会产生更多的复杂性。它需要更多的发展。</p><p><strong>现代语言如何避免与 Java 相同的陷阱</strong></p><p>现代语言不需要像 Java 和 C# 这样的复杂垃圾收集器。这是因为它们没有被设计成同样程度地依赖它们。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">// Go: Make an an<span class="hljs-built_in"> array </span>of 15 000 Point objects in<br>type Point struct &#123;<br>    X, Y<span class="hljs-built_in"> int</span><br><span class="hljs-built_in"></span>&#125;<br>var points [15000]Point<br></code></pre></td></tr></table></figure><p>在上面的 Go 代码示例中，我们分配了 15000 个<code>Point</code>对象。这只是一个单一的分配，产生一个单一的指针。在 Java 中，这需要 15 000 个单独的分配，每个分配都产生一个必须管理的单独引用。每个<code>Point</code>对象都有我之前写过的 16 字节头开销。在 Go、Julia 或 Rust 中，你都不会得到这个开销。这些对象通常是无标题的。</p><p>在 Java 中，GC 获得它必须跟踪和管理的 15000 个单独的对象。Go 只有 1 个要跟踪的对象。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>下面的代码定义了一个矩形，其中一个<code>Min</code>和<code>Max</code>点定义了它的范围。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Rect</span> struct &#123;<br>   <span class="hljs-type">Min</span>, <span class="hljs-type">Max</span> <span class="hljs-type">Point</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这成为一个连续的内存块。在 Java 中，这将变成一个<code>Rect</code>对象，其中引用了两个单独的对象，Min<code>和</code>Max<code>point 对象。因此在 Java 中，一个 的实例</code>Rect&#96;需要 3 次分配，但在 Go、Rust、C&#x2F;C++ 和 Julia 中只需要 1 次分配。</p><p><img src="https://cdn.jsdelivr.net/gh/longpi1/blog-img/image-20220912125744670.png" alt="image-20220912125744670"></p><p>左边是 Java 风格的内存碎片。在 Go、C&#x2F;C++、Julia 等中可能存在正确的连续内存块。</p><p>在将 Git 移植到 Java 时，缺少值类型会产生重大问题。没有值类型，很难获得良好的性能。正如 Shawn O. Pearce<a href="https://marc.info/?l=git&m=124111702609723">在 JGit 开发者邮件列表中所说</a>：</p><blockquote><p>JGit 苦于没有一种有效的方式来表示 SHA-1。C 可以说<code>unsigned char[20]</code>并将其内联到容器的内存分配中。<code>byte[20]</code>Java 中的A将花费<em>额外</em>的16 字节内存，并且访问速度较慢，因为字节本身与容器对象位于不同的内存区域。我们尝试通过从 a 转换为 5 个整数来解决它<code>byte[20]</code>，但这会花费我们的机器指令。</p></blockquote><p>我们在那里谈论什么？在 Go 中，我可以做与 C&#x2F;C++ 相同的事情并定义如下结构：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Sha1</span> struct &#123;<br>   data [20]byte<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这些字节将成为一个内存块的一部分。Java 将创建一个指向内存中其他位置的指针。</p><p>Java 开发人员意识到他们搞砸了，并且您确实需要值类型才能获得良好的性能。您可以称该陈述为夸张，但随后您需要解释<a href="https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language)">Project Valhalla</a>。这是 Oracle 为提供 Java 值类型而带头的一项努力，他们阐明这样做的原因正是我在这里所说的。</p><p><strong>值类型还不够</strong></p><p>那么<em>Project Valhalla</em>会解决Java 的问题吗？并不真地。它只会使 Java 与 C# 处于同等地位。C# 在 Java 之后几年问世，并从那时起意识到垃圾收集器并不是每个人都认为的那样神奇。因此，他们添加了值类型。</p><p>但是，在内存管理灵活性方面，这并没有使 C# 和 Java 与 Go 和 C&#x2F;C++ 等语言处于同等地位。Java 不支持真正的指针。在 Go 中，我可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go 指针用法var </span><br>ptr *Point = &amp;rect.Min <span class="hljs-comment">// 将指向 Min 的指针存储在 ptr </span><br>*ptr = Point(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 替换 rect.Min</span><br></code></pre></td></tr></table></figure><p>您可以在 Go 中获取对象的地址或对象的字段，就像在 C&#x2F;C++ 中一样，并将其存储在指针中。然后，您可以传递此指针并使用它来修改它指向的字段。这意味着您可以在 Go 中创建大值对象并将其作为指向函数的指针传递以优化性能。使用 C#，情况会好一些，因为它对指针的支持<em>有限。</em>前面的 Go 示例可以用 C# 编写为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// C# 指针用法不安全的 void foo() &#123; </span><br>   Rect* ptr = &amp;rect.Min; <br>   *ptr = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>然而，C# 指针支持带有一些不适用于 Go 的警告：</p><ol><li>使用点的代码必须标记为<strong>unsafe</strong>。这会创建安全性较低且更容易崩溃的代码。</li><li>在堆栈上分配的纯值类型（所有结构字段必须是值类型）。</li><li>在已关闭垃圾收集的<strong>固定范围内，使用 fixed 关键字。</strong></li></ol><p>因此，在 C# 中使用值类型的正常且安全的方法是复制它们，因为这不需要定义不安全或固定的代码区域。但是对于较大的值类型，这可能会产生性能问题。Go 没有这些问题。您可以在 Go 中创建指向垃圾收集器管理的对象的指针。您不需要像在 C# 中那样在 Go 中使用指针来隔离代码。</p><h2 id="自定义辅助分配器"><a href="#自定义辅助分配器" class="headerlink" title="自定义辅助分配器"></a>自定义辅助分配器</h2><p>使用正确的指针，您可以做很多只有值类型时无法做到的事情。一个示例是创建辅助分配器。<a href="https://github.com/ordovician/arena">这</a>是使用 Go 泛型创建的 Arena 分配器的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Arena[T any] <span class="hljs-keyword">struct</span> &#123;<br>    blocks Stack[*T]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arena *Arena[T])</span></span> Alloc() *T &#123;<br>    <span class="hljs-keyword">if</span> arena.blocks.IsEmpty() &#123;<br>        <span class="hljs-keyword">var</span> blocks [<span class="hljs-number">32</span>]T     <span class="hljs-comment">// allocate 32 elements at a time</span><br>        <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> blocks &#123;<br>            arena.blocks.Push(&amp;blocks[i])<br>        &#125;<br>    &#125;<br>    b, _ := arena.blocks.Top()<br>    arena.blocks.Pop()<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么这些有用？如果您查看生成二叉树的算法的微基准测试，您通常会发现 Java 比 Go 具有很大优势。这是因为二叉树算法通常用于测试垃圾收集器分配对象的速度。Java 在这方面非常快，因为它使用了我们所说的凹凸指针。它只是增加一个指针，而 Go 将在内存中搜索合适的位置来分配对象。但是，使用 Arena 分配器，您也可以在 Go 中快速构建二叉树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span><br><span class="hljs-keyword">type</span> Tree[K constraints.Ordered, V any] <span class="hljs-keyword">struct</span> &#123;<br>    Root      *TreeNode[K, V]<br>    allocator Arena[TreeNode[K, V]]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tree *Tree[K, V])</span></span> NewNode(key K, value V) *TreeNode[K, V] &#123;<br>    n := tree.allocator.Alloc()<br>    n.Key = key<br>    n.Value = value<br>    n.left = <span class="hljs-literal">nil</span><br>    n.right = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tree *Tree[K, V])</span></span> Insert(key K, value V) &#123;<br>    n := tree.NewNode(key, value)<br>    <span class="hljs-keyword">if</span> tree.Root == <span class="hljs-literal">nil</span> &#123;<br>        tree.Root = n<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tree.Root.Insert(n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是为什么拥有真正的指针有好处的原因。没有它，您无法在连续的内存块中创建指向元素的指针。在该<code>Alloc</code>方法中，我们创建了一个由 32 个元素组成的连续块。然后，我们将指向该块中每个元素的指针存储在一个堆栈上，该堆栈包含一个可用于分配的块列表。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> blocks <span class="hljs-selector-attr">[32]</span>T <br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, _ := range blocks &#123; <br>    arena<span class="hljs-selector-class">.blocks</span><span class="hljs-selector-class">.Push</span>(&amp;blocks<span class="hljs-selector-attr">[i]</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>这只是可能的，因为我可以选择任意元素<code>blocks[i]</code>并获取指向该元素的指针<code>&amp;blocks[i]</code>。Java 没有给你这种可能性。</p><p>Java GC 使用的Bump分配器与 Arena 分配器类似，您只需增加一个指针即可获取下一个值。除非您不必自己构建它。这可能看起来更聪明。但这会导致 Go 中避免的几个问题：</p><ol><li>迟早您需要进行<em>压缩</em>，这涉及移动数据和修复指针。Arena 分配器不必这样做。</li><li>在多线程程序中，凹凸分配器需要锁（除非您使用线程本地存储）。这会扼杀它们的性能优势，因为锁会降低性能，或者线程本地存储会导致碎片，需要稍后进行压缩。</li></ol><p>Go 的创建者之一 Ian Lance Taylor<a href="https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU">阐明了Bump分配器的问题</a>：</p><blockquote><p>一般来说，使用一组每线程缓存分配内存可能会更有效，此时您已经失去了凹凸分配器的优势。所以我要断言，总的来说，有很多警告，今天为多线程程序使用压缩内存分配器并没有真正的优势。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>Java 垃圾收集器还有很多工作要做，因为它分配了更多的对象。为什么？我们刚刚介绍了这一点。如果没有值对象和真正的指针，在分配大型数组或复杂数据结构时总是会以大量对象告终。因此它需要一个分代GC。</p><p>分配更少对象的需求对 Go 有利。但是 Go 还使用了另一个技巧。Go 和 Java在编译函数时都会进行所谓的<em>转义分析。</em></p><p>转义分析涉及查看在函数内部创建的指针并确定该指针是否曾经转义函数范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">escapingPtr</span><span class="hljs-params">()</span></span> []<span class="hljs-type">int</span> &#123; <br>   values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>&#125;<br>   <span class="hljs-keyword">return</span> values<br>&#125; <br><br>fun nonEscapingPtr() <span class="hljs-type">int</span> &#123; <br>    values = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>&#125; <br>    <span class="hljs-keyword">var</span> total <span class="hljs-type">int</span> = addUp(values)<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><p>在第一个示例中，<code>values</code>指向一个切片，它本质上与指向数组的指针相同。它逃脱，因为它被退回。这意味着<code>values</code>必须在堆上分配。</p><p>然而，在第二个例子中，没有指针<code>values</code>离开<code>nonEscapingPtr</code>函数。因此<code>values</code>可以在堆栈上分配，这非常快速且便宜。转义分析本身只是分析指针是否转义。</p><p><strong>Java Escape 分析的局限性</strong></p><p>Java 也确实逃脱了分析，但对其使用有更多限制。来自涵盖 HotSpot VM 的<a href="https://docs.oracle.com/en/java/javase/16/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-6BD8FCB5-995B-4AE9-BFAA-B2C7DE2BA5CD">Java SE 16 Oracle 文档：</a></p><blockquote><p>它不会***将***堆分配替换为未全局转义的对象的堆栈分配。</p></blockquote><p>然而，Java 使用了一种称为<em>标量替换的替代技巧，</em>它避免了将对象放在堆栈上的需要。本质上它会爆炸和对象并将其原始成员放在堆栈上。请记住，Java 已经可以将原始值（例如<code>int</code>和<code>float</code>）放在堆栈上。<a href="https://pkolaczk.github.io/">然而，正如Piotr Kołaczkowski</a>在 2021 年发现的那样，在实践中，即使在非常微不足道的情况下，标量替换也不起作用。</p><p>相反，主要优点是避免锁定。如果您知道指针没有在函数外部使用，您还可以确定它不需要锁。</p><p><strong>Go Escape分析的优势</strong></p><p>然而，Go 使用逃逸分析来确定可以在堆栈上分配哪些对象。这显着减少了可以从分代 GC 中受益的短期对象的数量。请记住，分代 GC 的全部意义在于利用最近分配的对象存活时间短的事实。然而，Go 中的大多数对象可能会长期存在，因为短期对象很可能会被逃逸分析捕获。</p><p>与 Java 不同，这也适用于复杂对象。Java 通常只能成功地对字节数组等简单对象进行转义分析。即使是内置的<code>ByteBuffer</code>也不能使用标量替换在堆栈上分配。</p><h2 id="分代-GC-与并发-GC-暂停"><a href="#分代-GC-与并发-GC-暂停" class="headerlink" title="分代 GC 与并发 GC 暂停"></a>分代 GC 与并发 GC 暂停</h2><p>你可以读到很多关于垃圾收集器的专家声称，由于内存碎片，Go 比 Java 更有可能耗尽内存。争论是这样的：因为 Go 没有分代垃圾收集器，内存会随着时间的推移变得碎片化。当内存碎片化时，您将达到将新对象装入内存变得困难的地步。</p><p>但是，由于两个原因，此问题大大减少：</p><ol><li>Go 分配的小对象没有 Java 那么多。它可以将大型对象数组分配为单个内存块。</li><li>现代内存分配器，如 Google 的 TCMalloc 或 Intel 的 Scalable Malloc 不会对内存进行分段。</li></ol><p>在设计 Java 时，内存碎片是内存分配器的一个大问题。人们不认为它可以解决。但早在 1998 年，Java 出现后不久，研究人员就开始解决这个问题。<a href="https://dl.acm.org/doi/10.1145/286860.286864">这是 Mark S. Johnstone 和 Paul R. Wilson 的论文</a>：</p><blockquote><p>这大大加强了我们之前的结果，即内存碎片问题通常被误解，并且好的分配器策略可以为大多数程序提供良好的内存使用。</p></blockquote><p>因此，为 Java 设计内存分配策略的许多假设根本不再适用</p><p>使用分代 GC 的 Java 策略旨在缩短垃圾收集周期。请记住，Java 必须停止一切来移动数据并修复指针。如果持续时间过长，这会降低性能和响应能力。使用分代 GC，每次缩短此时间时要检查的数据更少。</p><p>然而，Go 用多种替代策略解决了同样的问题：</p><ol><li>因为不需要移动内存，也不需要固定指针，所以在 GC 运行期间要做的工作更少。Go GC 只进行标记和扫描：它通过对象图查找应该释放的对象。</li><li>它同时运行。因此，一个单独的 GC 线程可以在不停止其他线程的情况下寻找要释放的对象。</li></ol><p>为什么 Go 可以同时运行它的 GC 而不是 Java？因为 Go 不会修复任何指针或移动内存中的任何对象。因此，不存在尝试访问指向刚刚移动但该指针尚未更新的对象的指针的风险。由于某些并发线程正在运行，不再有任何引用的对象不会突然获得引用。因此，并行移除死对象是没有危险的。</p><p>这是怎么回事？假设你有 4 个线程在 Go 程序中工作。其中一个线程偶尔会在任意时间段<code>T</code>秒内完成总共 4 秒的 GC 工作。</p><p>现在想象一个带有 GC 的 Java 程序执行 GC 工作仅 2 秒。哪个程序挤出最多的性能？谁在<code>T</code>几秒钟内完成最多？听起来像 Java 程序，对吧？错误的！</p><p>Java 程序中的 4 个工作线程将所有工作停止 2 秒。<code>T</code>这意味着 2×4 &#x3D; 8 秒的工作在间隔中丢失。因此，虽然 Go 停止的时间更长，但每次停止都会影响更少的工作，因为所有线程都没有停止。因此，缓慢的并发 GC 可能会胜过依赖于停止所有线程来完成其工作的更快的 GC。</p><p><strong>如果垃圾的创建速度比 Go 清理它的速度快怎么办？</strong></p><p>反对当前垃圾收集器的一个流行论点是，您可能会遇到一种情况，即活动工作线程产生垃圾的速度比垃圾收集器线程收集垃圾的速度要快。在 Java 世界中，这被称为“并发模式故障”。</p><p>声称在这种情况下，运行时别无选择，只能完全停止您的程序并等待 GC 周期完成。因此，当 Go 声称 GC 暂停非常低时，这种说法仅适用于 GC 有足够的 CPU 时间和余量超过主程序的情况。</p><p>但是 Go 有一个巧妙的技巧来解决<a href="https://blog.golang.org/ismmkeynote">Go GC 大师 Rick Hudson 所描述的</a>这个问题。Go 使用所谓的 Pacer。</p><blockquote><p>如果需要，Pacer 会在加快标记速度的同时减慢分配速度。在高层次上，Pacer 会停止执行大量分配的 Goroutine，并将其投入到标记工作中。工作量与 Goroutine 的分配成正比。这加快了垃圾收集器的速度，同时减慢了 mutator 的速度。</p></blockquote><p>Goroutines 有点像在线程池上多路复用的绿色线程。基本上，Go 接管了正在运行产生大量垃圾的工作负载的线程，并将它们用于帮助 GC 清理这些垃圾。它只会继续接管线程，直到 GC 运行得比产生垃圾的例程快。</p><p><strong>简而言之</strong></p><p>虽然高级垃圾收集器解决了 Java 中的实际问题，但 Go 和 Julia 等现代语言一开始就简单地避免了产生这些问题，因此不再需要劳斯莱斯垃圾收集器。当您拥有值类型、转义分析、指针、多核处理器和现代分配器时，Java 设计背后的许多假设都将不复存在。它们不再适用。</p><h2 id="假定的-GC-权衡不再适用"><a href="#假定的-GC-权衡不再适用" class="headerlink" title="假定的 GC 权衡不再适用"></a>假定的 GC 权衡不再适用</h2><p>Mike Hearn 在 Medium 上有一个非常受欢迎的故事，他批评了有关 Go GC 的说法：<a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">现代垃圾收集。</a>.</p><p>Hearn 的关键信息是在 GC 设计中总是存在权衡。他提出的观点是，因为 Go 的目标是低延迟收集，所以它们会受到许多其他指标的影响。这是一本有趣的读物，因为它涵盖了很多关于 GC 设计权衡的细节。</p><p>首先，我所说的低延迟是什么意思？与可能花费数百毫秒的各种 Java 收集器相比，Go GC 平均仅暂停大约 0.5 毫秒。</p><p>我从 Mike Hearn 的论点中看到的问题是，它们基于一个有缺陷的前提，即所有语言的内存访问模式都是相同的。正如我在本文中介绍的那样，这根本不是真的。Go 将产生更少的对象来由 GC 管理，并且它会使用逃逸分析及早清理大量对象。</p><p><strong>旧技术天生就不好？</strong></p><p>赫恩提出的论点表明，简单的收集在某种程度上天生就不好：</p><blockquote><p>Stop-the-world (STW) 标记&#x2F;扫描是本科计算机科学课程中最常教授的 GC 算法。在进行工作面试时，我有时会要求应聘者谈谈 GC，而且几乎总是，他们要么将 GC 视为一个黑匣子，对此一无所知，要么认为它现在仍在使用这种非常古老的技术。</p></blockquote><p>是的，它可能已经过时了，但是这种技术允许您同时运行 GC，这是“现代”技术所不允许的。在我们拥有多核的现代硬件世界中，这一点更为重要。</p><p><strong>Go 不是 C#</strong></p><p>另一种说法：</p><blockquote><p>由于 Go 是一种具有值类型的相对普通的命令式语言，它的内存访问模式可能与 C# 相当，其中分代假设肯定成立，因此 .NET 使用分代收集器。</p></blockquote><p>情况并非如此。AC# 开发人员会尽量减少对较大值对象的使用，因为与指针相关的代码无法安全使用。我们必须假设 C# 开发人员更喜欢复制值类型而不是使用指针，因为这可以在 CLR 中安全地完成。这自然会带来更高的开销。</p><p>据我所知，C# 也没有利用逃逸分析来减少堆上短期对象的产生。其次，<a href="https://alexyakunin.medium.com/go-vs-c-part-1-goroutines-vs-async-await-ac909c651c11">C# 并不擅长同时运行大量任务</a>。正如 Pacer 所提到的，Go 可以利用它们的协程来加速并发收集。</p><h2 id="为什么低延迟对-Java-也很重要"><a href="#为什么低延迟对-Java-也很重要" class="headerlink" title="为什么低延迟对 Java 也很重要"></a>为什么低延迟对 Java 也很重要</h2><p>我们生活在一个充满 docker 容器和微服务的世界中。这意味着许多较小的程序相互通信并为彼此工作。想象一下工作需要通过几个服务。每当一条链中的这些服务中的一项出现重大暂停时，就会产生涟漪效应。它会导致所有其他进程停止工作。如果管道中的下一个服务正在等待一个忙于进行垃圾收集的服务，它就无法工作。</p><p>因此，延迟&#x2F;吞吐量的权衡不再是 GC 设计中的权衡。当多个服务一起工作时，高延迟会导致吞吐量下降。Java 对高吞吐量和高延迟 GC 的偏好适用于单体应用程序世界。它不再适用于微服务世界。</p><p>这是 Mike Hearn 的论点的一个基本问题，即没有灵丹妙药，只有权衡取舍。它试图给人的印象是 Java 的权衡是同样有效的。但权衡必须适合我们生活的世界。</p><p>简而言之，我认为可以说围棋做出了许多明智的举动和战略选择。挥舞它，好像它只是任何人都可以做出的权衡一样，并没有削减它</p>]]></content>
    
    
    <categories>
      
      <category>golang vs java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>golang</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes网络模型进阶</title>
    <link href="/2022/09/10/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/09/10/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-网络模型进阶"><a href="#Kubernetes-网络模型进阶" class="headerlink" title="Kubernetes 网络模型进阶"></a>Kubernetes 网络模型进阶</h1><h2 id="Underlay-Network-Model"><a href="#Underlay-Network-Model" class="headerlink" title="Underlay Network Model"></a>Underlay Network Model</h2><h3 id="什么是Underlay-Network"><a href="#什么是Underlay-Network" class="headerlink" title="什么是Underlay Network"></a>什么是Underlay Network</h3><p>底层网络 <em>Underlay Network</em> 顾名思义是指网络设备基础设施，如交换机，路由器, <em>DWDM</em> 使用网络介质将其链接成的物理网络拓扑，负责网络之间的数据包传输。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyxjoDlKBvyPVoThkJ42pKhe4t3iaE0U1VgCcn0jybn1TCx6yicMB1efjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                  <strong>图：Underlay network topology</strong></p><p><em>Source：</em><a href="https://community.cisco.com/t5/data-center-switches/understanding-underlay-and-overlay-networks/td-p/4295870">https://community.cisco.com/t5/data-center-switches/understanding-underlay-and-overlay-networks/td-p/4295870</a></p><p><em>underlay network</em> 可以是二层，也可以是三层；二层 <em>underlay network</em> 的典型例子是以太网 <em>Ethernet</em>，三层是 <em>underlay network</em> 的典型例子是互联网 <em>Internet</em>。</p><p>而工作与二层的技术是 <em>vlan</em>，工作在三层的技术是由 <em>OSPF</em>, <em>BGP</em> 等协议组成</p><h3 id="kubernetes中的underlay-network"><a href="#kubernetes中的underlay-network" class="headerlink" title="kubernetes中的underlay network"></a>kubernetes中的underlay network</h3><p>在kubernetes中，<em>underlay network</em> 中比较典型的例子是通过将宿主机作为路由器设备，Pod 的网络则通过学习成路由条目从而实现跨节点通讯。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyqjHDK7dv8WtgBpibmbozUC7wo5zWdEDlIkoK03vxpv5QoR7ciaVNKzTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                  <strong>图：underlay network topology in kubernetes</strong></p><p>这种模型下典型的有 <em>flannel</em> 的 <em>host-gw</em> 模式与 <em>calico</em> <em>BGP</em> 模式。</p><h4 id="flannel-host-gw-1"><a href="#flannel-host-gw-1" class="headerlink" title="flannel host-gw [1]"></a>flannel host-gw [1]</h4><p><em>flannel host-gw</em> 模式中每个Node需要在同一个二层网络中，并将Node作为一个路由器，跨节点通讯将通过路由表方式进行，这样方式下将网络模拟成一个<em>underlay network</em>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyDLPDv7ZTCW14W1wtUs1SbR9yOcibm3ncwCd6dJV7C076XoSovLehaZA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                         <strong>图：layer2 ethernet topology</strong></p><p><em>Source：</em><a href="https://www.auvik.com/franklyit/blog/layer-3-switches-layer-2/">https://www.auvik.com/franklyit/blog/layer-3-switches-layer-2/</a></p><blockquote><p>Notes：因为是通过路由方式，集群的cidr至少要配置16，因为这样可以保证，跨节点的Node作为一层网络，同节点的Pod作为一个网络。如果不是这种用情况，路由表处于相同的网络中，会存在网络不可达</p></blockquote><h4 id="Calico-BGP-2"><a href="#Calico-BGP-2" class="headerlink" title="Calico BGP [2]"></a>Calico BGP [2]</h4><p>BGP（<em>Border Gateway Protocol</em>）是去中心化自治路由协议。它是通过维护IP路由表或’前缀’表来实现AS （<em>Autonomous System</em>）之间的可访问性，属于向量路由协议。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyGwaHm71fY1JAaOyWcdvfX0gjcO0e61aB56kskOgdjsLSmiayBoaLeQg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                  <strong>图：BGP network topology</strong></p><p><em>Source：</em><a href="https://infocenter.nokia.com/public/7705SAR214R1A/index.jsp?topic=/com.sar.routing_protocols%25">https://infocenter.nokia.com/public/7705SAR214R1A/index.jsp?topic=%2Fcom.sar.routing_protocols%</a></p><p>与 <em>flannel</em> 不同的是，<em>Calico</em> 提供了的 <em>BGP</em> 网络解决方案，在网络模型上，<em>Calico</em> 与 <em>Flannel host-gw</em> 是近似的，但在软件架构的实现上，<em>flannel</em> 使用 <em>flanneld</em> 进程来维护路由信息；而 <em>Calico</em> 是包含多个守护进程的，其中 <em>Brid</em> 进程是一个 <em>BGP</em> 的客户端 与路由反射器(<em>Router Reflector</em>)，<em>BGP</em> 客户端负责从 <em>Felix</em> 中获取路由并分发到其他 <em>BGP Peer</em>，而反射器在BGP中起了优化的作用。在同一个IBGP中，BGP客户端仅需要和一个 <em>RR</em> 相连，这样减少了<em>AS</em>内部维护的大量的BGP连接。通常情况下，<em>RR</em> 是真实的路由设备，而 <em>Bird</em> 作为 <em>BGP</em> 客户端工作。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyfEXWkGJTBS8TSt3pksPGe18LTicxXWDvCnTZXPibJrJ5Og5oE1wOHibrQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                       <strong>图：Calico Network Architecture</strong></p><p><em>Source：</em><a href="https://www.cisco.com/c/en/us/td/docs/dcn/whitepapers/cisco-nx-os-calico-network-design.html">https://www.cisco.com/c/en/us/td/docs/dcn/whitepapers/cisco-nx-os-calico-network-design.html</a></p><h4 id="IPVLAN-amp-MACVLAN-4"><a href="#IPVLAN-amp-MACVLAN-4" class="headerlink" title="IPVLAN &amp; MACVLAN [4]"></a>IPVLAN &amp; MACVLAN [4]</h4><p><em>IPVLAN</em> 和 <em>MACVLAN</em> 是一种网卡虚拟化技术，两者之间的区别为， <em>IPVLAN</em> 允许一个物理网卡拥有多个IP地址，并且所有的虚拟接口用同一个MAC地址；而 <em>MACVLAN</em> 则是相反的，其允许同一个网卡拥有多个MAC地址，而虚拟出的网卡可以没有IP地址。</p><p>因为是网卡虚拟化技术，而不是网络虚拟化技术，本质上来说属于 <em>Overlay network</em>，这种方式在虚拟化环境中与<em>Overlay network</em> 相比最大的特点就是可以将Pod的网络拉平到Node网络同级，从而提供更高的性能、低延迟的网络接口。本质上来说其网络模型属于下图中第二个。</p><ul><li>虚拟网桥：创建一个虚拟网卡对(veth pair)，一头栽容器内，一头栽宿主机的root namespaces内。这样一来容器内发出的数据包可以通过网桥直接进入宿主机网络栈，而发往容器的数据包也可以经过网桥进入容器。</li><li>多路复用：使用一个中间网络设备，暴露多个虚拟网卡接口，容器网卡都可以介入这个中间设备，并通过MAC&#x2F;IP地址来区分packet应该发往哪个容器设备。</li><li>硬件交换，为每个Pod分配一个虚拟网卡，这样一来，Pod与Pod之间的连接关系就会变得非常清晰，因为近乎物理机之间的通信基础。如今大多数网卡都支持SR-IOV功能，该功能将单一的物理网卡虚拟成多个VF接口，每个VF接口都有单独的虚拟PCIe通道，这些虚拟的PCIe通道共用物理网卡的PCIe通道。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyXl7hJSbrKicdnPZLbNhads4BrWPwDS78RZJIAtodUb5v8m0mWtkmiaDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                           <strong>图：Virtual networking modes: bridging, multiplexing and SR-IOV</strong></p><p><em>Source：</em><a href="https://thenewstack.io/hackers-guide-kubernetes-networking/">https://thenewstack.io/hackers-guide-kubernetes-networking/</a></p><p>在kubernetes中 <em>IPVLAN</em> 这种网络模型下典型的CNI有，multus 与 danm。</p><h5 id="multus"><a href="#multus" class="headerlink" title="multus"></a>multus</h5><p><em>multus</em> 是 intel 开源的CNI方案，是由传统的 <em>cni</em> 与 <em>multus</em> 组成，并且提供了 SR-IOV CNI 插件使 K8s pod 能够连接到 SR-IOV VF 。这是使用了 <em>IPVLAN&#x2F;MACVLAN</em> 的功能。</p><p>当创建新的Pod后，SR-IOV 插件开始工作。配置 VF 将被移动到新的 CNI 名称空间。该插件根据 CNI 配置文件中的 “name” 选项设置接口名称。最后将VF状态设置为UP。</p><p>下图是一个 Multus 和 SR-IOV CNI 插件的网络环境，具有三个接口的 pod。</p><ul><li><em>eth0</em> 是 <em>flannel</em> 网络插件，也是作为Pod的默认网络</li><li>VF 是主机的物理端口 <em>ens2f0</em> 的实例化。这是英特尔X710-DA4上的一个端口。在Pod端的 VF 接口名称为 <em>south0</em> 。</li><li>这个VF使用了 DPDK 驱动程序，此 VF 是从主机的物理端口 <em>ens2f1</em> 实例化出的。这个是英特尔® X710-DA4上另外一个端口。Pod 内的 VF 接口名称为 <em>north0</em>。该接口绑定到 DPDK 驱动程序 <em>vfio-pci</em> 。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxy1fqm6eakBu9XZT59bervsUvIFp2pF4fteTOULSaV24NIaSTFaTCuYA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                      <strong>图：Mutus networking Architecture overlay and SR-IOV</strong></p><p><em>Source：</em><a href="https://builders.intel.com/docs/networkbuilders/enabling_new_features_in_kubernetes_for_NFV.pdf">https://builders.intel.com/docs/networkbuilders/enabling_new_features_in_kubernetes_for_NFV.pdf</a></p><blockquote><p>Notes：terminology</p><ul><li>NIC：network interface card，网卡</li><li>SR-IOV：single root I&#x2F;O virtualization，硬件实现的功能，允许各虚拟机间共享PCIe设备。</li><li>VF：Virtual Function，基于PF，与PF或者其他VF共享一个物理资源。</li><li>PF：PCIe Physical Function，拥有完全控制PCIe资源的能力</li><li>DPDK：Data Plane Development Kit</li></ul></blockquote><p>于此同时，也可以将主机接口直接移动到Pod的网络名称空间，当然这个接口是必须存在，并且不能是与默认网络使用同一个接口。这种情况下，在普通网卡的环境中，就直接将Pod网络与Node网络处于同一个平面内了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyBpQH5b5UoWxWhM0YKPIVBW25oZLowbR6BuCu8ZGf0zXeiatS7zxudTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                         <strong>图：Mutus networking Architecture overlay and ipvlan</strong></p><p><em>Source：</em><a href="https://devopstales.github.io/kubernetes/multus/">https://devopstales.github.io/kubernetes/multus/</a></p><h5 id="danm"><a href="#danm" class="headerlink" title="danm"></a>danm</h5><p>DANM是诺基亚开源的CNI项目，目的是将电信级网络引入kubernetes中，与multus相同的是，也提供了SR-IOV&#x2F;DPDK 的硬件技术，并且支持IPVLAN.</p><h2 id="Overlay-Network-Model"><a href="#Overlay-Network-Model" class="headerlink" title="Overlay Network Model"></a>Overlay Network Model</h2><h3 id="什么是Overlay"><a href="#什么是Overlay" class="headerlink" title="什么是Overlay"></a>什么是Overlay</h3><p>叠加网络是使用网络虚拟化技术，在 <em>underlay</em> 网络上构建出的虚拟逻辑网络，而无需对物理网络架构进行更改。本质上来说，<em>overlay network</em> 使用的是一种或多种隧道协议 (<em>tunneling</em>)，通过将数据包封装，实现一个网络到另一个网络中的传输，具体来说隧道协议关注的是数据包（帧）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyyGkhSJE7WhbUna4s0mvzghkvGDCgPsPNtmibTUAtIWYfCRLdkGSasGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图：overlay network topology</p><p><em>Source：</em><a href="https://www.researchgate.net/figure/Example-Overlay-Network-built-on-top-of-an-Internet-style-Underlay_fig4_230774628">https://www.researchgate.net/figure/Example-Overlay-Network-built-on-top-of-an-Internet-style-Underlay_fig4_230774628</a></p><h3 id="常见的网络隧道技术"><a href="#常见的网络隧道技术" class="headerlink" title="常见的网络隧道技术"></a>常见的网络隧道技术</h3><ul><li>通用路由封装 ( <em>Generic Routing Encapsulation</em> ) 用于将来自 IPv4&#x2F;IPv6的数据包封装为另一个协议的数据包中，通常工作与L3网络层中。</li><li>VxLAN (<em>Virtual Extensible LAN</em>)，是一个简单的隧道协议，本质上是将L2的以太网帧封装为L4中UDP数据包的方法，使用 4789 作为默认端口。<em>VxLAN</em> 也是 <em>VLAN</em> 的扩展对于 4096（212 位 <em>VLAN ID</em>） 扩展为1600万（224 位 <em>VNID</em> ）个逻辑网络。</li></ul><p>这种工作在 <em>overlay</em> 模型下典型的有 <em>flannel</em> 与 <em>calico</em> 中的的 <em>VxLAN</em>, <em>IPIP</em> 模式。</p><h3 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a>IPIP</h3><p><em>IP in IP</em> 也是一种隧道协议，与 <em>VxLAN</em> 类似的是，<em>IPIP</em> 的实现也是通过Linux内核功能进行的封装。<em>IPIP</em> 需要内核模块 <code>ipip.ko</code> 使用命令查看内核是否加载IPIP模块<code>lsmod | grep ipip</code> ；使用命令<code>modprobe ipip</code> 加载。</p><p><img src="https://cdn.jsdelivr.net/gh/longpi1/blog-img/640" alt="图片"></p><p>图：A simple IPIP network workflow</p><p><em>Source：</em><a href="https://ssup2.github.io/theory_analysis/IPIP_GRE_Tunneling/">https://ssup2.github.io/theory_analysis/IPIP_GRE_Tunneling/</a></p><p>Kubernetes中 <em>IPIP</em> 与 <em>VxLAN</em> 类似，也是通过网络隧道技术实现的。与 <em>VxLAN</em> 差别就是，<em>VxLAN</em> 本质上是一个 UDP包，而 <em>IPIP</em> 则是将包封装在本身的报文包上。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxybmxBiantAKWVD2nlCUNBHAIQkHSOJZcQeM4znchxeRqicRNvh3pcPIMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                         <strong>图：IPIP in kubernetes</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyNfkHJrC9xJw6SzZRFND1XdRacXJ6A7utD0RYvRyj7qOwJPzM60YiaeA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                         <strong>图：IPIP packet with wireshark unpack</strong></p><blockquote><p>Notes：公有云可能不允许IPIP流量，例如Azure</p></blockquote><h3 id="VxLAN"><a href="#VxLAN" class="headerlink" title="VxLAN"></a>VxLAN</h3><p>kubernetes中不管是 <em>flannel</em> 还是 <em>calico</em> VxLAN的实现都是使用Linux内核功能进行的封装，Linux 对 vxlan 协议的支持时间并不久，2012 年 Stephen Hemminger 才把相关的工作合并到 kernel 中，并最终出现在 kernel 3.7.0 版本。为了稳定性和很多的功能，你可以会看到某些软件推荐在 3.9.0 或者 3.10.0 以后版本的 kernel 上使用 <em>VxLAN</em>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyVuvdFPpJgI1QG5U2MHUib3DbBGia1HVB6sicRiadIptJxM0B7nUXaCSqYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                             <strong>图：A simple VxLAN network topology</strong></p><p>在kubernetes中vxlan网络，例如 <em>flannel</em>，守护进程会根据kubernetes的Node而维护 <em>VxLAN</em>，名称为 <code>flannel.1</code> 这是 <em>VNID</em>，并维护这个网络的路由，当发生跨节点的流量时，本地会维护对端 <em>VxLAN</em> 设备的MAC地址，通过这个地址可以知道发送的目的端，这样就可以封包发送到对端，收到包的对端 VxLAN设备 <code>flannel.1</code> 解包后得到真实的目的地址。</p><p>查看 <em>Forwarding database</em> 列表</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>bridge fdb <span class="hljs-number">26</span><span class="hljs-symbol">:</span>5<span class="hljs-symbol">e:</span><span class="hljs-number">87</span><span class="hljs-symbol">:</span><span class="hljs-number">90</span><span class="hljs-symbol">:</span><span class="hljs-number">91</span><span class="hljs-symbol">:fc</span> dev flannel.<span class="hljs-number">1</span> dst <span class="hljs-number">10.0</span>.<span class="hljs-number">0.3</span> <span class="hljs-variable language_">self</span> permanent<br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyib50Tia4cxibibR5uhmL4eO4m158hQFxZsiaWaqYE9vH2Fflee6aEaEACJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                      <strong>图：VxLAN in kubernetes</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxyCSReVTSz26R2z2ibGa2HvNuTjwKI8tQHHv14amJr1eoOTw05gpMc5mg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                       <strong>图：VxLAN packet with wireshark unpack</strong></p><blockquote><p>Notes：VxLAN使用的4789端口，wireshark应该是根据端口进行分析协议的，而flannel在linux中默认端口是8472，此时抓包仅能看到是一个UDP包。</p></blockquote><p>通过上述的架构可以看出，隧道实际上是一个抽象的概念，并不是建立的真实的两端的隧道，而是通过将数据包封装成另一个数据包，通过物理设备传输后，经由相同的设备（网络隧道）进行解包实现网络的叠加。</p><h3 id="weave-vxlan-3"><a href="#weave-vxlan-3" class="headerlink" title="weave vxlan [3]"></a>weave vxlan [3]</h3><p>weave也是使用了 <em>VxLAN</em> 技术完成的包的封装，这个技术在 <em>weave</em> 中称之为 *fastdp (fast data path)*，与 <em>calico</em> 和 <em>flannel</em> 中用到的技术不同的，这里使用的是 Linux 内核中的 <em>openvswitch datapath module</em>，并且weave对网络流量进行了加密。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMOfSoHgRPZfL1ZzWoqxIyxy1r4xqNRVbh6Ua8kaalhWPbicCYYI0CcbC3tLeuoMGHxLX6zLqmEOiawA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                           <strong>图：weave fastdp network topology</strong></p><p><em>Source：</em><a href="https://www.weave.works/docs/net/latest/concepts/fastdp-how-it-works/">https://www.weave.works/docs/net/latest/concepts/fastdp-how-it-works/</a></p><blockquote><p>Notes：fastdp工作在Linux 内核版本 3.12 及更高版本，如果低于此版本的例如CentOS7，weave将工作在用户空间，weave中称之为 <em>sleeve mode</em></p></blockquote><p>Reference</p><p>[1] flannel host-gw</p><p>[2] calico bgp networking</p><p>[3] calico bgp networking</p><p>[4] sriov network</p><p>[5] danm</p><p>作者：Cylon</p><p>出处：<a href="https://www.cnblogs.com/Cylon/p/16595820.html">https://www.cnblogs.com/Cylon/p/16595820.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang对比Java、python为什么要保留指针</title>
    <link href="/2022/09/05/Golang%E5%AF%B9%E6%AF%94Java%E3%80%81python%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E7%95%99%E6%8C%87%E9%92%88/"/>
    <url>/2022/09/05/Golang%E5%AF%B9%E6%AF%94Java%E3%80%81python%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E7%95%99%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang对比Java、python为什么要保留指针"><a href="#Golang对比Java、python为什么要保留指针" class="headerlink" title="Golang对比Java、python为什么要保留指针"></a>Golang对比Java、python为什么要保留指针</h1><h2 id="为什么要用指针？"><a href="#为什么要用指针？" class="headerlink" title="为什么要用指针？"></a>为什么要用指针？</h2><p>平时我们在Golang使用指针一般是为了以下的情况：</p><ul><li><strong>方法直接修改原来对象</strong></li><li><strong>保证参数传递的自由，可以在传递重量级对象时使用指针</strong></li></ul><p>但Go 保留指针不仅仅是为了解决传递参数的问题，还跟它的语言特性有密不可分的联系。</p><h2 id="值语义"><a href="#值语义" class="headerlink" title="值语义"></a>值语义</h2><p>Go 里面的变量是<strong>值语义</strong>，这个跟 C&#x2F;C++是一脉相承的。比如一个结构体变量赋值给另外一个变量就是一次内存拷贝，而不是只拷贝一个指针，因此需要指针来表达引用语义，关于拷贝的具体实现可以了解<a href="https://gfw.go101.org/article/value-part.html">直接值部与间接值部的实现</a>。</p><p>关于值语义(value semantics)：<strong>值语义</strong>指的是对象的拷贝与原对象无关，就像拷贝 int 一样。C++ 的内置类型(bool&#x2F;int&#x2F;double&#x2F;char)都是值语义，标准库里的 complex&lt;&gt; 、pair&lt;&gt;、vector&lt;&gt;、map&lt;&gt;、string 等等类型也都是值语意，拷贝之后就与原对象脱离关系。同样，Java 语言的 primitive types 也是值语义。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>复杂的高级类型占用的内存往往相对较大，存储在 <a href="https://www.zhihu.com/search?q=heap&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1665421830%7D">heap</a> 中，GC 回收频率相对较低，代价也较大，因此传引用&#x2F;指针可以避免进行成本较高的复制操作，并且节省内存，提高程序运行效率。</strong></p><p>为什么要保留值语义，而不是像 Java 或者 Python 一样让复合类型默认都是指针类型呢？因为值语义带来了如下好处：</p><ul><li><strong><a href="https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2242103027%7D">结构体</a>可以直接用来比较相等，而非比较指针，Java 里面的 &#x3D;&#x3D; 操作符除了基本类型有用，其他类型几乎没用。</strong></li><li><strong>与 C 语言更好地交互。Go 可以通过 cgo 与 C 语言无缝交互。Go 里面的结构体基本上不用特殊处理就能传递给 C 的函数使用。主要得益于 Go 的结构体和 C 的一样都是值类型。</strong></li><li><strong>开发者能更好的掌控内存布局。一个结构体数组就是一段连续内存，而不是一个指针数组。</strong></li><li><strong>减轻 GC 压力。紧凑的内存布局减少了 GC 对象的个数，比如一个100w 长度的结构体数组就是一个 GC 对象，而不是100w 个。</strong></li><li><strong>减轻堆内存的分配压力。函数通过传值的方式传递参数后，原变量不会发生逃逸，可以被分配在栈上</strong></li></ul><p>Go 为了内存安全，虽然有指针，但不支持指针算数，但结合 unsafe.Pointer 也可以完成一些非常规情景下的精细内存操作。比如结合 <a href="https://www.zhihu.com/search?q=mmap&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2242103027%7D">mmap</a> 实现堆外内存管理，runtime 里面的内存管理就是这么来的，完全不用另外用 C 语言来实现。 这也是可以使用 Go 语言来写操作系统（<a href="https://link.zhihu.com/?target=https://github.com/icexin/eggos">eggos</a>）的原因。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>Go 的指针一方面提供了引用语义，另一方面像 C 语言一样给了开发者灵活管理内存的能力。</strong></p><p>参考链接：樊冰心：<a href="https://www.zhihu.com/question/399589293/answer/2242103027">https://www.zhihu.com/question/399589293/answer/2242103027</a></p>]]></content>
    
    
    <categories>
      
      <category>golang vs java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>golang</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程范式之泛型编程</title>
    <link href="/2022/09/04/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/09/04/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="编程范式之泛型编程"><a href="#编程范式之泛型编程" class="headerlink" title="编程范式之泛型编程"></a>编程范式之泛型编程</h1><h3 id="C-语言的泛型"><a href="#C-语言的泛型" class="headerlink" title="C 语言的泛型"></a>C 语言的泛型</h3><h3 id="一个泛型的示例-swap-函数"><a href="#一个泛型的示例-swap-函数" class="headerlink" title="一个泛型的示例 - swap 函数"></a>一个泛型的示例 - swap 函数</h3><p>好了，我们再看下，C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用<code>void *</code>关键字或是使用宏定义。</p><p>下面是一个使用了<code>void*</code>泛型版本的 swap 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">void</span>* x, <span class="hljs-type">void</span>* y, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>     <span class="hljs-type">char</span> tmp[size];<br>     <span class="hljs-built_in">memcpy</span>(tmp, y, size);<br>     <span class="hljs-built_in">memcpy</span>(y, x, size);<br>     <span class="hljs-built_in">memcpy</span>(x, tmp, size);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：</p><ul><li><strong>函数接口中增加了一个<code>size</code>参数</strong>。为什么要这么干呢？因为，用了 <code>void*</code> 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。</li><li><strong>函数的实现中使用了<code>memcpy()</code>函数</strong>。为什么要这样干呢？还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。</li><li><strong>函数的实现中使用了一个<code>temp[size]</code>数组</strong>。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。</li></ul><p>于是，新增的<code>size</code>参数，使用的<code>memcpy</code>内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。</p><p>在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：<code>char*</code>，那么，我的<code>swap()</code>函数的<code>x</code>和<code>y</code>参数是不是要用<code>void**</code>了？这样一来，接口就没法定义了。</p><p>除了使用 <code>void*</code> 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> swap(x, y, size) &#123;\</span><br><span class="hljs-meta">char temp[size]; \</span><br><span class="hljs-meta">memcpy(temp, &amp;y, size); \</span><br><span class="hljs-meta">memcpy(&amp;y,   &amp;x, size); \</span><br><span class="hljs-meta">memcpy(&amp;x, temp, size); \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用<code>void*</code>和宏替换来说都可以达到泛型。</p><p>但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(x, y)  （(x)&gt;(y) ? (y) : (x)）</span><br></code></pre></td></tr></table></figure><p>其中一个最大的问题，就是有可能会有<strong>重复执行</strong>的问题。</p><h3 id="C-泛型编程"><a href="#C-泛型编程" class="headerlink" title="C++ 泛型编程"></a>C++ 泛型编程</h3><p>C++ 泛型版的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function">Iter <span class="hljs-title">search</span><span class="hljs-params">(Iter pStart, Iter pEnd, T target)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(Iter p = pStart; p != pEnd; p++) &#123;<br><span class="hljs-keyword">if</span> ( *p == target ) <br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 C++ 的泛型版本中，我们可以看到：</p><ul><li>使用<code>typename T</code>抽象了数据结构中存储数据的类型。</li><li>使用<code>typename Iter</code>，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。</li><li>然后，我们对数据容器的遍历使用了<code>Iter</code>中的<code>++</code>方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</li><li>在函数的入参上使用了<code>pStart</code>和<code>pEnd</code>来表示遍历的起止。</li><li>使用<code>*Iter</code>来取得这个“指针”的内容。这也是通过重载 <code>*</code> 取值操作符来达到的泛型。</li></ul><h3 id="Go-泛型编程"><a href="#Go-泛型编程" class="headerlink" title="Go 泛型编程"></a>Go 泛型编程</h3><p>go1.18开始可以支持泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>] <span class="hljs-params">(arr []T, elem T)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> arr &#123;<br>    <span class="hljs-keyword">if</span>  v == elem &#123;<br>      <span class="hljs-keyword">return</span> i<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言的泛型已基本可用了，只不过，还有三个问题：</p><ul><li>一个是 <code>fmt.Printf()</code>中的泛型类型是 <code>%v</code> 还不够好，不能像c++ <code>iostream</code>重载 <code>&gt;&gt;</code> 来获得程序自定义的输出。</li><li>另外一个是，go不支持操作符重载，所以，你也很难在泛型算法中使用“泛型操作符”如：<code>==</code> 等</li><li>最后一个是，上面的 <code>find()</code> 算法依赖于“数组”，对于hash-table、tree、graph、link等数据结构还要重写。也就是说，没有一个像C++ STL那样的一个泛型迭代器（这其中的一部分工作当然也需要通过重载操作符（如：<code>++</code> 来实现）</li></ul><h3 id="Java泛型编程"><a href="#Java泛型编程" class="headerlink" title="Java泛型编程"></a>Java泛型编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123; <br>    <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定  </span><br>    <span class="hljs-keyword">private</span> T key;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123; <span class="hljs-comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的。</p><p>一般来说，编程语言会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。</p><p>编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的最佳算法。例如，在许多 C 编译器中，“浮点数”数据类型是以 32 比特表示、与 IEEE 754 规格一致的单精度浮点数。因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）。</p><p>类型的约束程度以及评估方法，影响了语言的类型。更进一步，编程语言可能就类型多态性部分，对每一个类型都对应了一个针对于这个类型的算法运算。类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。</p><p>程序语言的类型系统主要提供如下的功能。</p><ul><li><strong>程序语言的安全性</strong>。使用类型可以让编译器侦测一些代码的错误。例如：可以识别出一个错误无效的表达式。如：<code>“Hello, World” + 3</code>这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</li><li><strong>利于编译器的优化</strong>。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 <code>int</code> ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。</li><li><strong>代码的可读性</strong>。有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。</li><li><strong>抽象化</strong>。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。</li></ul><p>但是，正如前面说的，<strong>类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法</strong>。</p><h3 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h3><p>要了解泛型的本质，就需要了解类型的本质。</p><ul><li>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。</li><li>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li></ul><p>所以，要做到泛型，我们需要做下面的事情。</p><ul><li>标准化掉类型的内存分配、释放和访问。</li><li>标准化掉类型的操作。比如：比较操作，I&#x2F;O 操作，复制操作……</li><li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li><li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li></ul><p>所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。</p><ul><li>通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。</li><li>通过重载操作符，可以标准化类型的比较等操作。</li><li>通过 iostream，标准化了类型的输入输出控制。</li><li>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。</li><li>通过迭代器来标准化数据容器的遍历操作。</li><li>通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。</li><li>通过函数式（函数对象），来标准化对于不同类型的特定操作。</li></ul><p>我理解其本质就是 —— <strong>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程范式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>左耳听风</tag>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用操作以及注意事项</title>
    <link href="/2022/09/03/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/09/03/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><blockquote><p>命令：<code>hexo new [layout] title</code>或 <code>hexo n [layout] title</code></p></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo n text1<br></code></pre></td></tr></table></figure><p>当然你还可以指定布局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo n [layout_name] draft1<br></code></pre></td></tr></table></figure><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">text1</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">longpi1</span><br><span class="hljs-attr">tags:</span> <span class="hljs-string">hexo</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">blog</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。比如使<code>author: longpi1</code>，那么渲染后的文章中将显示文章作者为<code>longpi1</code>。</p><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>启动hexo本地服务器<code>hexo server</code> 或 <code>hexo s</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ hexo s INFO  Start processingINFO  Hexo is running <span class="hljs-keyword">at</span> <span class="hljs-keyword">http</span>://localhost:<span class="hljs-number">4000</span>/. Press Ctrl+C <span class="hljs-built_in">to</span> <span class="hljs-built_in">stop</span>.<br></code></pre></td></tr></table></figure><p>在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 进行预览，回到Git Bash输入<code>Ctrl+C</code>关闭本地服务器退出预览。</p><p>指定端口：<br><code>hexo s -p 8080</code></p><p>自定义 IP<br>服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：<br><code>hexo server -i 192.168.1.1</code></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><code>hexo d</code> 或 <code>hexo deploy</code><br><code>hexo d -g</code> 部署之前预先生成静态文件</p><h3 id="关于部署后原来的CNAME文件被覆盖的问题"><a href="#关于部署后原来的CNAME文件被覆盖的问题" class="headerlink" title="关于部署后原来的CNAME文件被覆盖的问题"></a>关于部署后原来的CNAME文件被覆盖的问题</h3><p>解决：CNAME,README,404.html都可以放在Hexo&#x2F;source文件夹下，<code>hexo g</code>生成博客时会被原封不动的拷贝到public文件夹中，部署后自然就到了项目的根目录。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统笔记</title>
    <link href="/2022/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="传统单体架构和分布式服务化架构的区别"><a href="#传统单体架构和分布式服务化架构的区别" class="headerlink" title="传统单体架构和分布式服务化架构的区别"></a>传统单体架构和分布式服务化架构的区别</h2><p><img src="https://static001.geekbang.org/resource/image/8f/91/8fecccec610626a3e348318b1fd17791.png?wh=1084*724" alt="img"></p><p><strong>存在的问题：</strong></p><ul><li>架构设计变得复杂（尤其是其中的分布式事务）。</li><li>部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。</li><li>系统的吞吐量会变大，但是响应时间会变长。</li><li>运维复杂度会因为服务变多而变得很复杂。</li><li>架构复杂导致学习曲线变大。</li><li>测试和查错的复杂度增大。</li><li>技术多元化，这会带来维护和运维的复杂度。</li><li>管理分布式系统中的服务和调度变得困难和复杂。</li></ul><h2 id="分布式系统的目的以及相关技术"><a href="#分布式系统的目的以及相关技术" class="headerlink" title="分布式系统的目的以及相关技术"></a>分布式系统的目的以及相关技术</h2><p><strong>构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。</strong></p><ul><li><strong>大流量处理。</strong>通过集群技术把大规模并发请求的负载分散到不同的机器上。</li><li><strong>关键业务保护。</strong>提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。</li></ul><h3 id="提高架构的性能"><a href="#提高架构的性能" class="headerlink" title="提高架构的性能"></a>提高架构的性能</h3><p><img src="https://static001.geekbang.org/resource/image/a9/17/a9edeae125a80f381003d8d9d0056317.png?wh=863*321" alt="img"></p><ul><li><strong>缓存系统。</strong>加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。</li><li><strong>负载均衡系统。</strong>负载均衡系统是水平扩展的关键技术，它可以使用多台机器来共同分担一部分流量请求。</li><li><strong>异步调用。</strong>异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。</li><li><strong>数据分区和数据镜像。数据分区</strong>是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而<strong>数据镜像</strong>是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</li></ul><h3 id="提高架构的稳定性"><a href="#提高架构的稳定性" class="headerlink" title="提高架构的稳定性"></a>提高架构的稳定性</h3><p><img src="https://static001.geekbang.org/resource/image/be/79/befd21e1b41a257c5028f8c1bc7fa279.png?wh=865*315" alt="img"></p><ul><li><strong>服务拆分。</strong>服务拆分主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。</li><li><strong>服务冗余。</strong>服务冗余是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。</li><li><strong>限流降级。</strong>当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。</li><li><strong>高可用架构。</strong>通常来说高可用架构是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。</li><li><strong>高可用运维。</strong>高可用运维指的是 DevOps 中的 CI&#x2F;CD（持续集成 &#x2F; 持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。</li></ul><h3 id="分布式系统的关键技术"><a href="#分布式系统的关键技术" class="headerlink" title="分布式系统的关键技术"></a>分布式系统的关键技术</h3><ul><li><strong>服务治理。</strong>服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。</li><li><strong>架构软件管理。</strong>服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。</li><li><strong>DevOps。</strong>分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</li><li><strong>自动化运维。</strong>有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</li><li><strong>资源调度管理。</strong>应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</li><li><strong>整体架构监控。</strong>如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</li><li><strong>流量控制</strong>。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。</li></ul><p><img src="https://static001.geekbang.org/resource/image/8e/db/8e92e2dff4f66147c014f930aa678fdb.jpg?wh=2556x1006" alt="img"></p><h3 id="全栈监控"><a href="#全栈监控" class="headerlink" title="全栈监控"></a>全栈监控</h3><p><strong>全栈监控，其实就是三层监控。</strong></p><ul><li><strong>基础层：</strong>监控主机和底层资源。比如：CPU、内存、网络吞吐、硬盘 I&#x2F;O、硬盘使用等。</li><li><strong>中间层：</strong>就是中间件层的监控。比如：Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat 等。应用层：</li><li><strong>监控应用层的使用</strong>。比如：HTTP 访问的吞吐量、响应时间、返回码、调用链路分析、性能瓶颈，还包括用户端的监控。</li></ul><p><img src="https://static001.geekbang.org/resource/image/fe/4f/fe3aaf79df1565505cdac32494078a4f.jpg?wh=2145x1152" alt="img"></p><h4 id="什么才是好的监控系统"><a href="#什么才是好的监控系统" class="headerlink" title="什么才是好的监控系统"></a>什么才是好的监控系统</h4><p><strong>监控系统可能存在的问题：</strong></p><p>1.<strong>监控数据是隔离开来的。</strong>因为公司分工的问题，开发、应用运维、系统运维，各管各的，所以很多公司的监控系统之间都有一道墙，完全串不起来。</p><p><strong>2.监控的数据项太多。</strong>有些公司的运维团队把监控的数据项多作为一个亮点到处讲，比如监控指标达到 5 万多个。老实说，这太丢人了。因为信息太多等于没有信息，抓不住重点的监控才会做成这个样子，完全就是使蛮力的做法。</p><p><strong>好的监控系统有以下几个特征：</strong></p><ol><li><strong>关注于整体应用的 SLA（服务级别协议）。</strong>主要从为用户服务的 API 来监控整个系统。</li><li><strong>关联指标聚合。</strong>把有关联的系统及其指标聚合展示。主要是三层系统数据：基础层、平台中间件层和应用层。其中，最重要的是把服务和相关的中间件以及主机关联在一起，服务有可能运行在 Docker 中，也有可能运行在微服务平台上的多个 JVM 中，也有可能运行在 Tomcat 中。总之，无论运行在哪里，我们都需要把服务的具体实例和主机关联在一起，否则，对于一个分布式系统来说，定位问题犹如大海捞针。</li><li><strong>快速故障定位。</strong>对于现有的系统来说，故障总是会发生的，而且还会频繁发生。故障发生不可怕，可怕的是故障的恢复时间过长。所以，快速地定位故障就相当关键。快速定位问题需要对整个分布式系统做一个用户请求跟踪的 trace 监控，我们需要监控到所有的请求在分布式系统中的调用链，这个事最好是做成没有侵入性的。</li></ol><p><strong>以下两大主要功能实现</strong></p><h5 id="“体检”"><a href="#“体检”" class="headerlink" title="“体检”"></a>“体检”</h5><ul><li><strong>容量管理。</strong>提供一个全局的系统运行时数据的展示，可以让工程师团队知道是否需要增加机器或者其它资源。</li><li><strong>性能管理。</strong>可以通过查看大盘，找到系统瓶颈，并有针对性地优化系统和相应代码。</li></ul><h5 id="“急诊”"><a href="#“急诊”" class="headerlink" title="“急诊”"></a>“急诊”</h5><ul><li><strong>定位问题</strong>。可以快速地暴露并找到问题的发生点，帮助技术人员诊断问题。</li><li><strong>性能分析。</strong>当出现非预期的流量提升时，可以快速地找到系统的瓶颈，并帮助开发人员深入代码。</li></ul><p><strong>如何做出一个好的监控系统</strong></p><ul><li><strong>服务调用链跟踪。</strong>这个监控系统应该从对外的 API 开始，然后将后台的实际服务给关联起来，然后再进一步将这个服务的依赖服务关联起来，直到最后一个服务（如 MySQL 或 Redis），这样就可以把整个系统的服务全部都串连起来了。这个事情的最佳实践是 Google Dapper 系统，其对应于开源的实现是 Zipkin。对于 Java 类的服务，我们可以使用字节码技术进行字节码注入，做到代码无侵入式。</li><li><strong>服务调用时长分布。</strong>使用 Zipkin，可以看到一个服务调用链上的时间分布，这样有助于我们知道最耗时的服务是什么。下图是 Zipkin 的服务调用时间分布。</li><li><strong>服务的 TOP N 视图。</strong>所谓 TOP N 视图就是一个系统请求的排名情况。一般来说，这个排名会有三种排名的方法：a）按调用量排名，b) 按请求最耗时排名，c）按热点排名（一个时间段内的请求次数的响应时间和）。</li><li><strong>数据库操作关联。</strong>对于 Java 应用，我们可以很方便地通过 JavaAgent 字节码注入技术拿到 JDBC 执行数据库操作的执行时间。对此，我们可以和相关的请求对应起来。</li><li><strong>服务资源跟踪。</strong>我们的服务可能运行在物理机上，也可能运行在虚拟机里，还可能运行在一个 Docker 的容器里，Docker 容器又运行在物理机或是虚拟机上。我们需要把服务运行的机器节点上的数据（如 CPU、MEM、I&#x2F;O、DISK、NETWORK）关联起来。</li></ul><p><strong>了这些数据上的关联，我们就可以达到如下的目标。</strong></p><ol><li>当一台机器挂掉是因为 CPU 或 I&#x2F;O 过高的时候，我们马上可以知道其会影响到哪些对外服务的 API。</li><li>当一个服务响应过慢的时候，我们马上能关联出来是否在做 Java GC，或是其所在的计算结点上是否有资源不足的情况，或是依赖的服务是否出现了问题。</li><li>当发现一个 SQL 操作过慢的时候，我们能马上知道其会影响哪个对外服务的 API。</li><li>当发现一个消息队列拥塞的时候，我们能马上知道其会影响哪些对外服务的 API。</li></ol><p><strong>一旦了解了这些信息，我们就可以做出调度。比如：</strong></p><ol><li>一旦发现某个服务过慢是因为 CPU 使用过多，我们就可以做弹性伸缩。</li><li>一旦发现某个服务过慢是因为 MySQL 出现了一个慢查询，我们就无法在应用层上做弹性伸缩，只能做流量限制，或是降级操作了。</li></ol><p><strong>实现效果如下图：</strong></p><p><img src="https://static001.geekbang.org/resource/image/6b/33/6b17dd779cfecd62e02924dc8618e833.png?wh=865*381" alt="img"></p><h3 id="服务调度"><a href="#服务调度" class="headerlink" title="服务调度"></a>服务调度</h3><p><strong>微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要有依赖环。</strong>如果系统架构中有服务依赖环，那么表明你的架构设计是错误的。循环依赖有很多的副作用，最大的问题是这是一种极强的耦合，会导致服务部署相当复杂和难解，而且会导致无穷尽的递归故障和一些你意想不到的问题。</p><h4 id="服务状态和生命周期的管理"><a href="#服务状态和生命周期的管理" class="headerlink" title="服务状态和生命周期的管理"></a>服务状态和生命周期的管理</h4><p>服务的生命周期通常会有以下几个状态：</p><ul><li>Provision，代表在供应一个新的服务；</li><li>Ready，表示启动成功了；</li><li>Run，表示通过了服务健康检查；</li><li>Update，表示在升级中；</li><li>Rollback，表示在回滚中；</li><li>Scale，表示正在伸缩中（可以有 Scale-in 和 Scale-out 两种）；</li><li>Destroy，表示在销毁中；</li><li>Failed，表示失败状态。</li></ul><p>这几个状态需要管理好，不然的话，你将不知道这些服务在什么样的状态下。不知道在什么样的状态下，你对整个分布式架构也就无法控制了。</p><h4 id="整个架构的版本管理"><a href="#整个架构的版本管理" class="headerlink" title="整个架构的版本管理"></a>整个架构的版本管理</h4><p>需要一个架构的 manifest，一个服务清单，这个服务清单定义了所有服务的版本运行环境，其中包括但不限于：</p><ul><li>服务的软件版本；</li><li>服务的运行环境——环境变量、CPU、内存、可以运行的节点、文件系统等；</li><li>服务运行的最大最小实例数。</li></ul><h4 id="资源-x2F-服务调度"><a href="#资源-x2F-服务调度" class="headerlink" title="资源 &#x2F; 服务调度"></a>资源 &#x2F; 服务调度</h4><p>服务和资源的调度有点像操作系统。操作系统一方面把用户进程在硬件资源上进行调度，另一方面提供进程间的通信方式，可以让不同的进程在一起协同工作。服务和资源调度的过程，与操作系统调度进程的方式很相似，主要有以下一些关键技术。</p><ul><li>服务状态的维持和拟合。</li><li>服务的弹性伸缩和故障迁移。</li><li>作业和应用调度。</li><li>作业工作流编排。</li><li>服务编排。</li></ul><h4 id="服务状态的维持"><a href="#服务状态的维持" class="headerlink" title="服务状态的维持"></a>服务状态的维持</h4><p>所谓服务状态不是服务中的数据状态，而是服务的运行状态，换句话说就是服务的 Status，而不是 State。也就是上述服务运行时生命周期中的状态——Provision，Ready，Run，Scale，Rollback，Update，Destroy，Failed……服务运行时的状态是非常关键的。</p><p>服务运行过程中，状态也是会有变化的，这样的变化有两种。</p><ul><li>一种是没有预期的变化。比如，服务运行因为故障导致一些服务挂掉，或是别的什么原因出现了服务不健康的状态。而一个好的集群管理控制器应该能够强行维护服务的状态。在健康的实例数变少时，控制器会把不健康的服务给摘除，而又启动几个新的，强行维护健康的服务实例数。</li><li>另外一种是预期的变化。比如，我们需要发布新版本，需要伸缩，需要回滚。这时，集群管理控制器就应该把集群从现有状态迁移到另一个新的状态。这个过程并不是一蹴而就的，集群控制器需要一步一步地向集群发送若干控制命令。这个过程叫“拟合”——从一个状态拟合到另一个状态，而且要穷尽所有的可能，玩命地不断地拟合，直到达到目的。</li></ul><h4 id="服务的弹性伸缩和故障迁移"><a href="#服务的弹性伸缩和故障迁移" class="headerlink" title="服务的弹性伸缩和故障迁移"></a>服务的弹性伸缩和故障迁移</h4><p>有了上述的服务状态拟合的基础工作之后，我们就能很容易地管理服务的生命周期了，甚至可以通过底层的支持进行便利的服务弹性伸缩和故障迁移。</p><p>对于弹性伸缩，在上面我已经给出了一个服务伸缩所需要的操作步骤。还是比较复杂的，其中涉及到了：</p><ul><li>底层资源的伸缩；</li><li>服务的自动化部署；</li><li>服务的健康检查；</li><li>服务发现的注册；</li><li>服务流量的调度。</li></ul><p>而对于故障迁移，也就是服务的某个实例出现问题时，我们需要自动地恢复它。对于服务来说，有两种模式，一种是宠物模式，一种是奶牛模式。</p><ul><li>所谓宠物模式，就是一定要救活，主要是对于 stateful 的服务。</li><li>而奶牛模式，就是不用救活了，重新生成一个实例。</li></ul><p>对于这两种模式，在运行中也是比较复杂的，其中涉及到了：</p><ul><li>服务的健康监控（这可能需要一个 APM 的监控）。</li><li>如果是宠物模式，需要：服务的重新启动和服务的监控报警（如果重试恢复不成功，需要人工介入）。</li><li>如果是奶牛模式，需要：服务的资源申请，服务的自动化部署，服务发现的注册，以及服务的流量调度。</li></ul><p>把传统的服务迁移到 Docker 和 Kubernetes 上来，再加上更上层的对服务生命周期的控制系统的调度，我们就可以做到一个完全自动化的运维架构了。</p><h4 id="服务工作流和编排"><a href="#服务工作流和编排" class="headerlink" title="服务工作流和编排"></a>服务工作流和编排</h4><p>正如上面和操作系统做的类比一样，一个好的操作系统需要能够通过一定的机制把一堆独立工作的进程给协同起来。在分布式的服务调度中，这个工作叫做 <strong>Orchestration</strong>，国内把这个词翻译成<strong>“编排”</strong>。</p><h3 id="流量与数据调度"><a href="#流量与数据调度" class="headerlink" title="流量与数据调度"></a>流量与数据调度</h3><p>关于流量调度，现在很多人都把这个事和服务治理混为一谈了。但是还是应该分开的。</p><ol><li>一方面，服务治理是内部系统的事，而流量调度可以是内部的，更是外部接入层的事。</li><li>另一方面，服务治理是数据中心的事，而流量调度要做得好，应该是数据中心之外的事，也就是我们常说的边缘计算，是应该在类似于 CDN 上完成的事。</li></ol><p>所以，流量调度和服务治理是在不同层面上的，不应该混在一起，所以在系统架构上应该把它们分开。</p><h4 id="流量调度的主要功能"><a href="#流量调度的主要功能" class="headerlink" title="流量调度的主要功能"></a>流量调度的主要功能</h4><p>对于一个流量调度系统来说，其应该具有的主要功能是：</p><ol><li>依据系统运行的情况，自动地进行流量调度，在无需人工干预的情况下，提升整个系统的稳定性；</li><li>让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。</li></ol><p>这还是为了提高系统架构的稳定性和高可用性。</p><p>此外，这个流量调度系统还可以完成以下几方面的事情。</p><ul><li><strong>服务流控。</strong>服务发现、服务路由、服务降级、服务熔断、服务保护等。</li><li><strong>流量控制。</strong>负载均衡、流量分配、流量控制、异地灾备（多活）等。</li><li><strong>流量管理。</strong>协议转换、请求校验、数据缓存、数据计算等。</li></ul><p>所有的这些都应该是一个 API Gateway 应该做的事。</p><h4 id="流量调度的关键技术"><a href="#流量调度的关键技术" class="headerlink" title="流量调度的关键技术"></a>流量调度的关键技术</h4><p>一个好的 API Gateway 需要具备以下的关键技术。</p><ul><li><strong>高性能。</strong>API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。</li><li><strong>扛流量。</strong>要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。</li><li><strong>业务逻辑。</strong>API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。</li><li><strong>服务化。</strong>一个好的 API Gateway 需要能够通过 Admin API 来不停机地管理配置变更，而不是通过一个.conf 文件来人肉地修改配置。</li></ul><h4 id="状态数据调度"><a href="#状态数据调度" class="headerlink" title="状态数据调度"></a>状态数据调度</h4><p>对于服务调度来说，最难办的就是有状态的服务了。这里的状态是 State，也就是说，有些服务会保存一些数据，而这些数据是不能丢失的，所以，这些数据是需要随服务一起调度的。</p><p>一般来说，我们会通过“转移问题”的方法来让服务变成“无状态的服务”。也就是说，会把这些有状态的东西存储到第三方服务上，比如 Redis、MySQL、ZooKeeper，或是 NFS、Ceph 的文件系统中。</p><p>这些“转移问题”的方式把问题转移到了第三方服务上，于是自己的 Java 或 PHP 服务中没有状态，但是 Redis 和 MySQL 上则有了状态。所以，我们可以看到，现在的分布式系统架构中出问题的基本都是这些存储状态的服务。</p><p>因为数据存储结点在 Scale 上比较困难，所以成了一个单点的瓶颈。</p><h4 id="分布式事务一致性的问题"><a href="#分布式事务一致性的问题" class="headerlink" title="分布式事务一致性的问题"></a>分布式事务一致性的问题</h4><p>要解决数据结点的 Scale 问题，也就是让数据服务可以像无状态的服务一样在不同的机器上进行调度，这就会涉及数据的 replication 问题。而数据 replication 则会带来数据一致性的问题，进而对性能带来严重的影响。</p><p>要解决数据不丢失的问题，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本。当出现某个节点的数据丢失时，可以从副本读到。数据副本是分布式系统解决数据丢失异常的唯一手段。简单来说：</p><ul><li>要想让数据有高可用性，就得写多份数据。</li><li>写多份会引起数据一致性的问题。</li><li>数据一致性的问题又会引发性能问题</li></ul><p>在解决数据副本间的一致性问题时，可以使用以下这些技术方案。</p><ul><li>Master-Slave 方案。</li><li>Master-Master 方案。</li><li>两阶段和三阶段提交方案。</li><li>Paxos 方案。</li></ul><p><strong>关于分布式的事务处理：</strong><a href="https://coolshell.cn/articles/10910.html">https://coolshell.cn/articles/10910.html</a></p><h4 id="状态数据调总结"><a href="#状态数据调总结" class="headerlink" title="状态数据调总结"></a>状态数据调总结</h4><ul><li>对于应用层上的分布式事务一致性，只有两阶段提交这样的方式。</li><li>而底层存储可以解决这个问题的方式是通过一些像 Paxos、Raft 或是 NWR 这样的算法和模型来解决。</li><li>状态数据调度应该是由分布式存储系统来解决的，这样会更为完美。但是因为数据存储的 Scheme 太多，所以，导致我们有各式各样的分布式存储系统，有文件对象的，有关系型数据库的，有 NoSQL 的，有时序数据的，有搜索数据的，有队列的……</li></ul><p>数据调度应该是在 IaaS 层的数据存储解决的问题，而不是在 PaaS 层或者 SaaS 层来解决的。</p><p>在 IaaS 层上解决这个问题，一般来说有三种方案，</p><p>一种是使用比较廉价的开源产品，如：NFS、Ceph、TiDB、CockroachDB、ElasticSearch、InfluxDB、MySQL Cluster 和 Redis Cluster 之类的；另一种是用云计算厂商的方案。当然，如果不差钱的话，可以使用更为昂贵的商业网络存储方案。</p><h3 id="Pass平台的本质"><a href="#Pass平台的本质" class="headerlink" title="Pass平台的本质"></a>Pass平台的本质</h3><p><img src="https://s2.loli.net/2022/08/28/ABQ1nR9wt5opvFY.png" alt="Pass平台.png"></p><p>下面这三件事是 PaaS 跟传统中间件最大的差别。</p><ul><li><strong>服务化是 PaaS 的本质</strong>。软件模块重用，服务治理，对外提供能力是 PaaS 的本质。</li><li><strong>分布式是 PaaS 的根本特性</strong>。多租户隔离、高可用、服务编排是 PaaS 的基本特性。</li><li><strong>自动化是 PaaS 的灵魂</strong>。自动化部署安装运维，自动化伸缩调度是 PaaS 的关键。</li></ul><h2 id="PaaS-平台的总体架构"><a href="#PaaS-平台的总体架构" class="headerlink" title="PaaS 平台的总体架构"></a>PaaS 平台的总体架构</h2><p><img src="https://s2.loli.net/2022/08/28/rTUA9lfnSFjOtqC.png" alt="架构图.png"></p><p>在 Docker+Kubernetes 层之上，我们看到了两个相关的 PaaS 层。一个是 PaaS 调度层，很多人将其称为 iPaaS；另一个是 PaaS 能力层，通常被称为 aPaaS。没有 PaaS 调度层，PaaS 能力层很难被管理和运维，而没有 PaaS 能力层，PaaS 就失去了提供实际能力的业务价值。而本文更多的是在讲 PaaS 调度层上的东西。</p><p>一个完整的 PaaS 平台会包括以下几部分。</p><ul><li>PaaS 调度层 – 主要是 PaaS 的自动化和分布式对于高可用高性能的管理。</li><li>PaaS 能力服务层 – 主要是 PaaS 真正提供给用户的服务和能力。</li><li>PaaS 的流量调度 – 主要是与流量调度相关的东西，包括对高并发的管理。</li><li>PaaS 的运营管理 – 软件资源库、软件接入、认证和开放平台门户。</li><li>PaaS 的运维管理 – 主要是 DevOps 相关的东西。</li></ul><h2 id="PaaS-平台的生产和运维"><a href="#PaaS-平台的生产和运维" class="headerlink" title="PaaS 平台的生产和运维"></a>PaaS 平台的生产和运维</h2><p><img src="https://s2.loli.net/2022/08/28/m2DzoMRpQkUT5Ii.png" alt="image-20220814122700725.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传统的单体架构系统容量显然是有上限的。同时，为了应对有计划和无计划的下线时间，系统的可用性也是有其极限的。分布式系统为以上两个问题提供了解决方案，并且还附带有其他优势。但是，要同时解决这两个问题决非易事。为了构建分布式系统，我们面临的主要问题如下。</p><ul><li>分布式系统的硬件故障发生率更高，故障发生是常态，需要尽可能地将运维流程自动化。</li><li>需要良好地设计服务，避免某服务的单点故障对依赖它的其他服务造成大面积影响。</li><li>为了容量的可伸缩性，服务的拆分、自治和无状态变得更加重要，可能需要对老的软件逻辑做大的修改。</li><li>老的服务可能是异构的，此时需要让它们使用标准的协议，以便可以被调度、编排，且互相之间可以通信。</li><li>服务软件故障的处理也变得复杂，需要优化的流程，以加快故障的恢复。</li><li>为了管理各个服务的容量，让分布式系统发挥出最佳性能，需要有流量调度技术。</li><li>分布式存储会让事务处理变得复杂；在事务遇到故障无法被自动恢复的情况下，手动恢复流程也会变得复杂。</li><li>测试和查错的复杂度增大。</li><li>系统的吞吐量会变大，但响应时间会变长。</li></ul><p>为了解决这些问题，我们深入了解了以下这些解决方案。</p><ul><li>需要有完善的监控系统，以便对服务运行状态有全面的了解。</li><li>设计服务时要分析其依赖链；当非关键服务故障时，其他服务要自动降级功能，避免调用该服务。</li><li>重构老的软件，使其能被服务化；可以参考 SOA 和微服务的设计方式，目标是微服务化；使用 Docker 和 Kubernetes 来调度服务。</li><li>为老的服务编写接口逻辑来使用标准协议，或在必要时重构老的服务以使得它们有这些功能。</li><li>自动构建服务的依赖地图，并引入好的处理流程，让团队能以最快速度定位和恢复故障。</li><li>使用一个 API Gateway，它具备服务流向控制、流量控制和管理的功能。</li><li>事务处理建议在存储层实现；根据业务需求，或者降级使用更简单、吞吐量更大的最终一致性方案，或者通过二阶段提交、Paxos、Raft、NWR 等方案之一，使用吞吐量小的强一致性方案。</li><li>通过更真实地模拟生产环境，乃至在生产环境中做灰度发布，从而增加测试强度；同时做充分的单元测试和集成测试以发现和消除缺陷；最后，在服务故障发生时，相关的多个团队同时上线自查服务状态，以最快地定位故障原因。</li><li>通过异步调用来减少对短响应时间的依赖；对关键服务提供专属硬件资源，并优化软件逻辑以缩短响应时间。</li></ul><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP 定理</a></h2><p>CAP 定理是分布式系统设计中最基础，也是最为关键的理论。它指出，分布式数据存储不可能同时满足以下三个条件。</p><ul><li><strong>一致性（Consistency）</strong>：每次读取要么获得最近写入的数据，要么获得一个错误。</li><li><strong>可用性（Availability）</strong>：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据。</li><li><strong>分区容忍（Partition tolerance）</strong>：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。</li></ul><p>也就是说，CAP 定理表明，在存在网络分区的情况下，一致性和可用性必须二选一。而在没有发生网络故障时，即分布式系统正常运行时，一致性和可用性是可以同时被满足的。这里需要注意的是，CAP 定理中的一致性与 ACID 数据库事务中的一致性截然不同。</p><p>掌握 CAP 定理，尤其是能够正确理解 C、A、P 的含义，对于系统架构来说非常重要。因为对于分布式系统来说，网络故障在所难免，如何在出现网络故障的时候，维持系统按照正常的行为逻辑运行就显得尤为重要。你可以结合实际的业务场景和具体需求，来进行权衡。</p><p>例如，对于大多数互联网应用来说（如门户网站），因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须要保证的，所以只有舍弃一致性来保证服务的 AP。而对于银行等，需要确保一致性的场景，通常会权衡 CA 和 CP 模型，CA 模型网络故障时完全不可用，CP 模型具备部分可用性。</p><p><img src="https://s2.loli.net/2022/08/28/VhY8TjpDHOAs6JX.png" alt="image-20220814124520469.png"></p><ul><li>CA (consistency + availability)，这样的系统关注一致性和可用性，它需要非常严格的全体一致的协议，比如“两阶段提交”（2PC）。CA 系统不能容忍网络错误或节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了，还是只是网络问题。唯一安全的做法就是把自己变成只读的。</li><li>CP (consistency + partition tolerance)，这样的系统关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法（Quorum 类的算法）。这样的系统只需要保证大多数结点数据一致，而少数的结点会在没有同步到最新版本的数据时变成不可用的状态。这样能够提供一部分的可用性。</li><li>AP (availability + partition tolerance)，这样的系统关心可用性和分区容忍性。因此，这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。Dynamo 就是这样的系统。</li></ul><h4 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h4><p>Paxos 算法，是莱斯利·兰伯特（Lesile Lamport）于 1990 年提出来的一种基于消息传递且具有高度容错特性的一致性算法。但是这个算法太过于晦涩，所以，一直以来都属于理论上的论文性质的东西。</p><h4 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h4><p>因为 Paxos 算法太过于晦涩，而且在实际的实现上有太多的坑，并不太容易写对。所以，有人搞出了另外一个一致性的算法，叫 Raft。其原始论文是<a href="https://raft.github.io/raft.pdf"> In search of an Understandable Consensus Algorithm (Extended Version) </a>寻找一种易于理解的 Raft 算法。这篇论文的译文在 InfoQ 上《<a href="http://www.infoq.com/cn/articles/raft-paper">Raft 一致性算法论文译文</a>》</p><p>Raft 算法和 Paxos 的性能和功能是一样的，但是它和 Paxos 算法的结构不一样，这使 Raft 算法更容易理解并且更容易实现。那么 Raft 是怎样做到的呢？</p><p>Raft 把这个一致性的算法分解成了几个部分，一个是领导选举（Leader Selection），一个是日志复制（Log Replication），一个是安全性（Safety），还有一个是成员变化（Membership Changes）。对于一般人来说，Raft 协议比 Paxos 的学习曲线更低，也更平滑。</p><p>Raft 协议中有一个状态机，每个结点会有三个状态，分别是 Leader、Candidate 和 Follower。Follower 只响应其他服务器的请求，如果没有收到任何信息，它就会成为一个 Candidate，并开始进行选举。收到大多数人同意选票的人会成为新的 Leader。</p><p><img src="https://s2.loli.net/2022/08/28/AZdFOXp17fvj2J9.png" alt="image-20220814125128384.png"></p><p>一旦选举出了一个 Leader，它就开始负责服务客户端的请求。每个客户端的请求都包含一个要被复制状态机执行的指令。Leader 首先要把这个指令追加到 log 中形成一个新的 entry，然后通过 AppendEntries RPC 并行地把该 entry 发给其他服务器（server）。如果其他服务器没发现问题，复制成功后会给 Leader 一个表示成功的 ACK。</p><p>Leader 收到大多数 ACK 后应用该日志，返回客户端执行结果。如果 Follower 崩溃 （crash）或者丢包，Leader 会不断重试 AppendEntries RPC。</p><p><img src="https://s2.loli.net/2022/08/28/9EcGBU8KDSrdah5.png" alt="image-20220814125218440.png"></p><p>几个不错的 Raft 算法的动画演示。</p><ul><li><a href="http://thesecretlivesofdata.com/raft/">Raft – The Secret Lives of Data</a></li><li><a href="https://raft.github.io/">Raft Consensus Algorithm</a></li><li><a href="http://kanaka.github.io/raft.js/">Raft Distributed Consensus Algorithm Visualization</a></li></ul><h4 id="逻辑钟和向量钟"><a href="#逻辑钟和向量钟" class="headerlink" title="逻辑钟和向量钟"></a>逻辑钟和向量钟</h4><p>后面，业内又搞出来一些工程上的东西，比如 Amazon 的 DynamoDB，其论文<a href="http://bnrg.eecs.berkeley.edu/~randy/Courses/CS294.F07/Dynamo.pdf">Dynamo: Amazon’s Highly Available Key Value Store</a> 的影响力也很大。这篇论文中讲述了 Amazon 的 DynamoDB 是如何满足系统的高可用、高扩展和高可靠要求的，其中还展示了系统架构是如何做到数据分布以及数据一致性的。</p><p>GFS 采用的是查表式的数据分布，而 DynamoDB 采用的是计算式的，也是一个改进版的通过虚拟结点减少增加结点带来数据迁移的一致性哈希。另外，这篇论文中还讲述了一个 NRW 模式用于让用户可以灵活地在 CAP 系统中选取其中两项，这使用到了 Vector Clock——向量时钟来检测相应的数据冲突。最后还介绍了使用 Handoff 的机制对可用性的提升。</p><p>这篇文章中有几个关键的概念，一个是 Vector Clock，另一个是 Gossip 协议。</p><p>提到向量时钟就需要提一下逻辑时钟。所谓逻辑时间，也就是在分布系统中为了解决消息有序的问题，由于在不同的机器上有不同的本地时间，这些本地时间的同步很难搞，会导致消息乱序。</p><p>于是 Paxos 算法的发明人兰伯特（Lamport）搞了个向量时钟，每个系统维护一个本地的计数器，这就是所谓的逻辑时钟。每执行一个事件（例如向网络发送消息，或是交付到应用层）都对这个计数器做加 1 操作。当跨系统的时候，在消息体上附着本地计算器，当接收端收到消息时，更新自己的计数器（取对端传来的计数器和自己当成计数器的最大值），也就是调整自己的时钟。</p><p>逻辑时钟可以保证，如果事件 A 先于事件 B，那么事件 A 的时钟一定小于事件 B 的时钟，但是返过来则无法保证，因为返过来没有因果关系。所以，向量时钟解释了因果关系。向量时钟维护了数据更新的一组版本号（版本号其实就是使用逻辑时钟）。</p><p>假如一个数据需要存在三个结点上 A、B、C。那么向量维度就是 3，在初始化的时候，所有结点对于这个数据的向量版本是 [A:0, B:0, C:0]。当有数据更新时，比如从 A 结点更新，那么，数据的向量版本变成 [A:1, B:0, C:0]，然后向其他结点复制这个版本，其在语义上表示为我当前的数据是由 A 结果更新的，而在逻辑上则可以让分布式系统中的数据更新的顺序找到相关的因果关系。</p><p>这其中的逻辑关系，你可以看一下<a href="http://lass.cs.umass.edu/~shenoy/courses/spring05/lectures.html"> 马萨诸塞大学课程 Distributed Operating System </a>中第 10 节<a href="http://lass.cs.umass.edu/~shenoy/courses/spring05/lectures/Lec10.pdf"> Clock Synchronization </a>这篇讲议。关于 Vector Clock，你可以看一下<a href="http://basho.com/posts/technical/why-vector-clocks-are-easy/"> Why Vector Clocks are Easy</a>和<a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">Why Vector Clocks are Hard</a> 这两篇文章。</p><h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>另外，DynamoDB 中使用到了 Gossip 协议来做数据同步，这个协议的原始论文是 <a href="https://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">Efficient Reconciliation and Flow Control for Anti-Entropy Protocols</a>。Gossip 算法也是 Cassandra 使用的数据复制协议。这个协议就像八卦和谣言传播一样，可以 “一传十、十传百”传播开来。但是这个协议看似简单，细节上却非常麻烦。</p><p>根据这篇论文，节点之间存在三种通信方式。</p><ul><li>push 方式。A 节点将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。</li><li>pull 方式。A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据 (key,value,version) 推送给 A，A 更新本地。</li><li>push&#x2F;pull 方式。与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。</li></ul><p>如果把两个节点数据同步一次定义为一个周期，那么在一个周期内，push 需通信 1 次，pull 需 2 次，push&#x2F;pull 则需 3 次。从效果上来讲，push&#x2F;pull 最好，理论上一个周期内可以使两个节点完全一致。直观感觉上，也是 push&#x2F;pull 的收敛速度最快。</p><p>另外，每个节点上的又需要一个协调机制，也就是如何交换数据能达到最快的一致性——消除节点的不一致性。上面所讲的 push、pull 等是通信方式，协调是在通信方式下的数据交换机制。</p><p>关于 Gossip 的一些图示化的东西，可以看一下动画<a href="https://rrmoelker.github.io/gossip-visualization/">gossip visualization</a>。</p><h4 id="分布式数据库方面"><a href="#分布式数据库方面" class="headerlink" title="分布式数据库方面"></a>分布式数据库方面</h4><p>数据库方面的一些论文。</p><p>一篇是 AWS Aurora 的论文 <a href="http://www.allthingsdistributed.com/files/p1041-verbitski.pdf">Amazon Aurora: Design Considerations for High Throughput Cloud –Native Relation Databases</a>。</p><p>Aurora 是 AWS 将 MySQL 的计算和存储分离后，计算节点 scale up，存储节点 scale out。并把其 redo log 独立设计成一个存储服务，把分布式的数据方面的东西全部甩给了底层存储系统。从而提高了整体的吞吐量和水平的扩展能力。</p><p>Aurora 要写 6 份拷贝，但是其只需要把一个 Quorum 中的日志写成功就可以了。如下所示。可以看到，将存储服务做成一个跨数据中心的服务，提高数据库容灾，降低性能影响。</p><p><img src="https://s2.loli.net/2022/08/28/G2eINobOhBxMFXu.png" alt="image-20220814125522918.png"></p><p>对于存储服务的设计，核心的原理就是 latency 一定要低，毕竟写 6 个 copy 是一件开销很大的事。所以，基本上来说，Aurora 用的是异步模型，然后拼命地做并行处理，其中用到的也是 Gossip 协议。如下所示。</p><p><img src="https://s2.loli.net/2022/08/28/8jlGWnqfyZHVTFx.png" alt="image-20220814125553446.png"></p><p>在上面这个图中，我们可以看到，完成前两步，就可以 ACK 回调用方。也就是说，只要数据在本地落地了，就可以返回成功了。然后，对于六个副本，这个 log 会同时发送到 6 个存储结点，只需要有大于 4 个成功 ACK，就算写成功了。第 4 步我们可以看到用的是 Gossip 协议。然后，第 5 步产生 cache 页，便于查询。第 6 步在 S3 做 Snapshot，类似于 Checkpoint。</p><h3 id="经典资料"><a href="#经典资料" class="headerlink" title="经典资料"></a>经典资料</h3><ul><li>Distributed systems theory for the distributed systems engineer</li><li>FLP Impossibility Result</li><li>An introduction to distributed systems</li><li>Distributed Systems for fun and profit</li><li>Distributed Systems: Principles and Paradigms</li><li>Scalable Web Architecture and Distributed Systems</li><li>Principles of Distributed Systems</li><li>Making reliable distributed systems in the presence of software errors</li><li>Designing Data Intensive Applications</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>分布式</tag>
      
      <tag>左耳听风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC实战笔记</title>
    <link href="/2022/08/28/RPC%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/28/RPC%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC总结"><a href="#RPC总结" class="headerlink" title="RPC总结"></a>RPC总结</h1><h2 id="RPC-的作用"><a href="#RPC-的作用" class="headerlink" title="RPC 的作用"></a>RPC 的作用</h2><ol><li><p>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</p></li><li><p>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</p></li></ol><h2 id="一个完整的-RPC-会涉及到哪些步骤？"><a href="#一个完整的-RPC-会涉及到哪些步骤？" class="headerlink" title="一个完整的 RPC 会涉及到哪些步骤？"></a>一个完整的 RPC 会涉及到哪些步骤？</h2><p><img src="https://static001.geekbang.org/resource/image/ac/fa/acf53138659f4982bbef02acdd30f1fa.jpg?wh=3846*1377" alt="img"></p><h2 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h2><p><img src="https://static001.geekbang.org/resource/image/30/fb/30f52b433aa5f103114a8420c6f829fb.jpg?wh=2951*2181" alt="img"></p><p>​                                                                                                                      <strong>核心功能体系</strong> </p><p><img src="https://static001.geekbang.org/resource/image/a3/a6/a3688580dccd3053fac8c0178cef4ba6.jpg?wh=3084*2183" alt="img"></p><p>​                                                                                                                  <strong>插件化体系架构</strong> </p><p><strong>插件化体系</strong>整个架构就变成了一个微内核架构，我们将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离并提供接口的默认实现。这样的架构相比之前的架构，有很多优势。首先它的可扩展性很好，实现了开闭原则，用户可以非常方便地通过插件扩展实现自己的功能，而且不需要修改核心功能的本身；其次就是保持了核心包的精简，依赖外部包少，这样可以有效减少开发人员引入 RPC 导致的包版本冲突问题。</p><h2 id="RPC应用场景"><a href="#RPC应用场景" class="headerlink" title="RPC应用场景"></a>RPC应用场景</h2><p><img src="https://static001.geekbang.org/resource/image/50/be/506e902e06e91663334672c29bfbc2be.jpg?wh=3205*1778" alt="img"></p><h2 id="RPC注意点"><a href="#RPC注意点" class="headerlink" title="RPC注意点"></a>RPC注意点</h2><p><img src="https://s2.loli.net/2022/08/28/c19JKY4lWEjf3y7.png" alt="image-20220716134042279.png"></p><h2 id="RPC协议与HTTP的设计区别"><a href="#RPC协议与HTTP的设计区别" class="headerlink" title="RPC协议与HTTP的设计区别"></a>RPC协议与HTTP的设计区别</h2><p>相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以性能要求相对更高。但 HTTP 协议的数据包大小相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等；还有一个更重要的原因是，HTTP 协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接。因此，对于要求高性能的 RPC 来说，HTTP 协议基本很难满足需求，所以 RPC 会选择设计更紧凑的私有协议。</p><h2 id="对象如何在网络中传输"><a href="#对象如何在网络中传输" class="headerlink" title="对象如何在网络中传输"></a>对象如何在网络中传输</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程叫做“序列化”。这时，服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程称之为“反序列化”。</p><p><img src="https://static001.geekbang.org/resource/image/d2/04/d215d279ef8bfbe84286e81174b4e704.jpg" alt="img"></p><h3 id="RPC通信流程"><a href="#RPC通信流程" class="headerlink" title="RPC通信流程"></a>RPC通信流程</h3><p><img src="https://static001.geekbang.org/resource/image/82/59/826a6da653c4093f3dc3f0a833915259.jpg" alt="img"></p><h3 id="常见的序列化方式"><a href="#常见的序列化方式" class="headerlink" title="常见的序列化方式"></a>常见的序列化方式</h3><p><strong>JDK 原生序列化</strong></p><p>JDK序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用。</p><p><img src="https://static001.geekbang.org/resource/image/7e/9f/7e2616937e3bc5323faf3ba4c09d739f.jpg" alt="img"></p><ul><li>头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容</li><li>对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据</li><li>存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑</li></ul><p><strong>JSON序列化</strong></p><p><strong>缺点：</strong></p><p>JSON 进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销；JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好。</p><p>JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好。</p><p>所以如果 RPC 框架选用 JSON 序列化，服务提供者与服务调用者之间传输的数据量要相对较小，否则将严重影响性能。</p><p><strong>Hessian序列化</strong></p><p>Hessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。Hessian 协议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节数也更小。</p><p><strong>Protobuf序列化</strong></p><p>Protobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持 Java、Python、C++、Go 等语言。Protobuf 使用的时候需要定义 IDL（Interface description language），然后使用不同语言的 IDL 编译器，生成序列化工具类；</p><p><strong>优点：</strong></p><ul><li>序列化后体积相比 JSON、Hessian 小很多；</li><li>IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器；</li><li>序列化反序列化速度很快，不需要通过反射获取类型；</li><li>消息格式升级和兼容性不错，可以做到向后兼容。</li></ul><p><strong>缺点：</strong>对于具有反射和动态能力的语言来说，用起来很费劲</p><h4 id="如何选择哪种框架"><a href="#如何选择哪种框架" class="headerlink" title="如何选择哪种框架"></a>如何选择哪种框架</h4><p><img src="https://static001.geekbang.org/resource/image/b4/a5/b42e44968c3fdcdfe2acf96377f5b2a5.jpg" alt="img"></p><h2 id="RPC-框架在使用时要注意哪些问题？"><a href="#RPC-框架在使用时要注意哪些问题？" class="headerlink" title="RPC 框架在使用时要注意哪些问题？"></a>RPC 框架在使用时要注意哪些问题？</h2><p><strong>对象构造得过于复杂：</strong>属性很多，并且存在多层的嵌套，比如 A 对象关联 B 对象，B 对象又聚合 C 对象，C 对象又关联聚合很多其他对象，对象依赖关系过于复杂。序列化框架在序列化与反序列化对象时，对象越复杂就越浪费性能，消耗 CPU，这会严重影响 RPC 框架整体的性能；另外，对象越复杂，在序列化与反序列化的过程中，出现问题的概率就越高。</p><p><strong>对象过于庞大：</strong>我经常遇到业务过来咨询，为啥他们的 RPC 请求经常超时，排查后发现他们的入参对象非常得大，比如为一个大 List 或者大 Map，序列化之后字节长度达到了上兆字节。这种情况同样会严重地浪费了性能、CPU，并且序列化一个如此大的对象是很耗费时间的，这肯定会直接影响到请求的耗时。</p><p><strong>使用序列化框架不支持的类作为入参类：</strong>比如 Hessian 框架，不支持 LinkedHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。</p><p><strong>对象有复杂的继承关系：</strong>大多数序列化框架在序列化对象时都会将对象的属性一一进行序列化，当有继承关系时，会不停地寻找父类，遍历属性。就像问题 1 一样，对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。</p><p><img src="C:\Users\longp\AppData\Roaming\Typora\typora-user-images\image-20220717151659788.png" alt="image-20220717151659788"></p><h2 id="RPC主要实现功能"><a href="#RPC主要实现功能" class="headerlink" title="RPC主要实现功能"></a>RPC主要实现功能</h2><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><strong>一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）要AP还是CP</strong></p><p><img src="https://static001.geekbang.org/resource/image/51/5d/514dc04df2b8b2f3130b7d44776a825d.jpg?wh=2746*1445" alt="img"></p><p>​                                                                                                                                          <strong>服务发现原理</strong></p><p><strong>服务注册：</strong>在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。</p><p><strong>服务订阅：</strong>在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用。</p><h4 id="为什么不使用-DNS？"><a href="#为什么不使用-DNS？" class="headerlink" title="为什么不使用 DNS？"></a>为什么不使用 DNS？</h4><p><img src="https://static001.geekbang.org/resource/image/3b/18/3b6a23f392b9b8d6fcf31803a5b4ef18.jpg?wh=5273*1884" alt="img"></p><p>​                                                                                                             <strong>DNS查询流程</strong></p><p><strong>使用DNS存在的问题：</strong></p><ul><li>如果这个 IP 端口下线了，服务调用者不能及时摘除服务节点；</li><li>如果在之前已经上线了一部分服务节点，这时我突然对这个服务进行扩容，那么新上线的服务节点不能及时接收到流量；</li></ul><h4 id="基于-ZooKeeper-的服务发现"><a href="#基于-ZooKeeper-的服务发现" class="headerlink" title="基于 ZooKeeper 的服务发现"></a>基于 ZooKeeper 的服务发现</h4><p><img src="https://static001.geekbang.org/resource/image/50/75/503fabeeae226a722f83e9fb6c0d4075.jpg?wh=4214*1803" alt="img"></p><p><img src="https://s2.loli.net/2022/08/28/9rWbXJjnkFMGdgL.png" alt="实践.png"></p><h4 id="基于消息总线的最终一致性的注册中心"><a href="#基于消息总线的最终一致性的注册中心" class="headerlink" title="基于消息总线的最终一致性的注册中心"></a>基于消息总线的最终一致性的注册中心</h4><p>ZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。这就好比几个人在玩传递东西的游戏，必须这一轮每个人都拿到东西之后，所有的人才能开始下一轮，而不是说我只要获得到东西之后，就可以直接进行下一轮了。</p><p>而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后（比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，<strong>所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。</strong></p><p>是否有一种简单、高效，并且最终一致的更新机制，能代替 ZooKeeper 那种数据强一致的数据更新机制呢？</p><p>因为要求最终一致性，我们可以考虑采用消息总线机制。注册数据可以全量缓存在每个注册中心内存中，通过消息总线来同步数据。当有一个注册中心节点接收到服务节点注册时，会产生一个消息推送给消息总线，再通过消息总线通知给其它注册中心节点更新数据并进行服务下发，从而达到注册中心间数据最终一致性，具体流程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/73/ff/73b59c7949ebed2903ede474856062ff.jpg?wh=4256*2276" alt="img"></p><ul><li>当有服务上线，注册中心节点收到注册请求，服务列表数据发生变化，会生成一个消息，推送给消息总线，每个消息都有整体递增的版本。</li><li>消息总线会主动推送消息到各个注册中心，同时注册中心也会定时拉取消息。对于获取到消息的在消息回放模块里面回放，只接受大于本地版本号的消息，小于本地版本号的消息直接丢弃，从而实现最终一致性。</li><li>消费者订阅可以从注册中心内存拿到指定接口的全部服务实例，并缓存到消费者的内存里面。</li><li>采用推拉模式，消费者可以及时地拿到服务实例增量变化情况，并和内存中的缓存数据进行合并。</li></ul><p>为了性能，采用两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性。</p><p><img src="https://s2.loli.net/2022/08/28/OfNVTmrCbYEkohq.png" alt="image-20220720220716266.png"><br><img src="https://s2.loli.net/2022/08/28/g4dzHEyWfrpRhDK.png" alt="image-20220720220817173.png"></p><h3 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h3><p><strong>Script Check、HTTP Check、TCP Check、TTL Check等</strong></p><h4 id="consul做法"><a href="#consul做法" class="headerlink" title="consul做法"></a>consul做法</h4><p><strong>TTL&#x2F;TCP？</strong></p><h4 id="etcd做法？"><a href="#etcd做法？" class="headerlink" title="etcd做法？"></a>etcd做法？</h4><p><strong>基于lease租约机制，对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</strong></p><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><p><img src="https://static001.geekbang.org/resource/image/b7/68/b78964a2db3adc8080364e9cfc79ca68.jpg?wh=3900*879" alt="img"></p><p>​                                                                                                                              <strong>调用流程</strong></p><p><img src="https://static001.geekbang.org/resource/image/23/f7/23f24c545d33ec4d6d72fc10e94a0ff7.jpg?wh=2513*1991" alt="img"></p><p>​                                                                                                                              <strong>IP路由调用拓扑</strong></p><h4 id="参数路由："><a href="#参数路由：" class="headerlink" title="参数路由："></a>参数路由：</h4><p><img src="https://static001.geekbang.org/resource/image/78/39/7868289c87ca9de144fe32fac98f8339.jpg?wh=2506*1964" alt="img"></p><p>​                                                                                                                 <strong>参数路由调用拓扑</strong></p><p>相比 IP 路由，参数路由支持的灰度粒度更小，他为服务提供方应用提供了另外一个服务治理的手段。灰度发布功能是 RPC 路由功能的一个典型应用场景，通过 RPC 路由策略的组合使用可以让服务提供方更加灵活地管理、调用自己的流量，进一步降低上线可能导致的风险。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>需求：</strong></p><p><img src="https://s2.loli.net/2022/08/28/vAXShkqrxu8e2pK.png" alt="需求.png"></p><h4 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h4><p>当我们的一个服务节点无法支撑现有的访问量时，我们会部署多个节点，组成一个集群，然后通过负载均衡，将请求分发给这个集群下的每个服务节点，从而达到多个服务节点共同分担请求压力的目的。</p><p><img src="https://static001.geekbang.org/resource/image/f4/b8/f48704443b33df17fc490778c00c71b8.jpg?wh=3345*1443" alt="img"></p><p>​                                                                                                                    <strong>负载均衡示意图</strong></p><p>负载均衡主要分为软负载和硬负载，软负载就是在一台或多台服务器上安装负载均衡的软件，如 LVS、Nginx 等，硬负载就是通过硬件设备来实现的负载均衡，如 F5 服务器等。负载均衡的算法主要有随机法、轮询法、最小连接法等。</p><p>刚才介绍的负载均衡主要还是应用在 Web 服务上，Web 服务的域名绑定负载均衡的地址，通过负载均衡将用户的请求分发到一个个后端服务上。</p><h4 id="RPC-框架中的负载均衡"><a href="#RPC-框架中的负载均衡" class="headerlink" title="RPC 框架中的负载均衡"></a>RPC 框架中的负载均衡</h4><p><strong>RPC使用传统的负载均衡存在的问题？</strong></p><ol><li>搭建负载均衡设备或 TCP&#x2F;IP 四层代理，需要额外成本；</li><li>请求流量都经过负载均衡设备，多经过一次网络传输，会额外浪费一些性能；</li><li>负载均衡添加节点和摘除节点，一般都要手动添加，当大批量扩容和下线时，会有大量的人工操作，“服务发现”在操作上是个问题；</li><li>我们在服务治理的时候，针对不同接口服务、服务的不同分组，我们的负载均衡策略是需要可配的，如果大家都经过这一个负载均衡设备，就不容易根据不同的场景来配置不同的负载均衡策略了。</li></ol><p>RPC 的负载均衡完全由 RPC 框架自身实现，RPC 的服务调用者会与“注册中心”下发的所有服务节点建立长连接，在每次发起 RPC 调用时，服务调用者都会通过配置的负载均衡插件，自主选择一个服务节点，发起 RPC 调用请求。</p><p><img src="https://static001.geekbang.org/resource/image/5e/1c/5e294378a3d86e7d279507f62fe5ee1c.jpg?wh=4175*1969" alt="img"></p><p>​                                                                                                                      RPC框架负载均衡示意图</p><p>RPC 负载均衡策略一般包括随机权重、Hash、轮询。当然，这还是主要看 RPC 框架自身的实现。其中的随机权重策略应该是我们最常用的一种了，通过随机算法，我们基本可以保证每个节点接收到的请求流量是均匀的；同时我们还可以通过控制节点权重的方式，来进行流量控制。比如我们默认每个节点的权重都是 100，但当我们把其中的一个节点的权重设置成 50 时，它接收到的流量就是其他节点的 1&#x2F;2。</p><h4 id="如何设计自适应的负载均衡？"><a href="#如何设计自适应的负载均衡？" class="headerlink" title="如何设计自适应的负载均衡？"></a>如何设计自适应的负载均衡？</h4><p>RPC 的负载均衡完全由 RPC 框架自身实现，服务调用者发起请求时，会通过配置的负载均衡插件，自主地选择服务节点。那是不是只要调用者知道每个服务节点处理请求的能力，再根据服务处理节点处理请求的能力来判断要打给它多少流量就可以了？当一个服务节点负载过高或响应过慢时，就少给它发送请求，反之则多给它发送请求。这就有点像日常工作中的分配任务，要多考虑实际情况。当一位下属身体欠佳，就少给他些工作；若刚好另一位下属状态很好，手头工作又不是很多，就多分给他一点。</p><h5 id="服务调用者节点该如何判定一个服务节点的处理能力呢？"><a href="#服务调用者节点该如何判定一个服务节点的处理能力呢？" class="headerlink" title="服务调用者节点该如何判定一个服务节点的处理能力呢？"></a>服务调用者节点该如何判定一个服务节点的处理能力呢？</h5><p>采用一种打分的策略，服务调用者收集与之建立长连接的每个服务节点的指标数据，如服务节点的负载指标、CPU 核数、内存大小、请求处理的耗时指标（如请求平均耗时、TP99、TP999）、服务节点的状态指标（如正常、亚健康）。通过这些指标，计算出一个分数，比如总分 10 分，如果 CPU 负载达到 70%，就减它 3 分，当然了，减 3 分只是个类比，需要减多少分是需要一个计算策略的。</p><h5 id="该如果根据这些指标来打分呢？"><a href="#该如果根据这些指标来打分呢？" class="headerlink" title="该如果根据这些指标来打分呢？"></a>该如果根据这些指标来打分呢？</h5><p>这就有点像公司对员工进行年终考核。假设我是老板，我要考核专业能力、沟通能力和工作态度，这三项的占比分别是 30%、30%、40%，我给一个员工的评分是 10、8、8，那他的综合分数就是这样计算的：10<em>30%+8</em>30%+8*40%&#x3D;8.6 分。给服务节点打分也一样，我们可以为每个指标都设置一个指标权重占比，然后再根据这些指标数据，计算分数。</p><h5 id="服务调用者给每个服务节点都打完分之后，会发送请求，那这时候我们又该如何根据分数去控制给每个服务节点发送多少流量呢？"><a href="#服务调用者给每个服务节点都打完分之后，会发送请求，那这时候我们又该如何根据分数去控制给每个服务节点发送多少流量呢？" class="headerlink" title="服务调用者给每个服务节点都打完分之后，会发送请求，那这时候我们又该如何根据分数去控制给每个服务节点发送多少流量呢？"></a>服务调用者给每个服务节点都打完分之后，会发送请求，那这时候我们又该如何根据分数去控制给每个服务节点发送多少流量呢？</h5><p>我们可以配合随机权重的负载均衡策略去控制，通过最终的指标分数修改服务节点最终的权重。例如给一个服务节点综合打分是 8 分（满分 10 分），服务节点的权重是 100，那么计算后最终权重就是 80（100*80%）。服务调用者发送请求时，会通过随机权重的策略来选择服务节点，那么这个节点接收到的流量就是其他正常节点的 80%（这里假设其他节点默认权重都是 100，且指标正常，打分为 10 分的情况）。</p><p>整体的设计方案如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/00/af/00065674063f30c98caaa58bb4cd7baf.jpg?wh=4085*2365" alt="img"></p><p>​                                                                                                                      <strong>RPC自适应负载均衡示意图</strong></p><p><strong>关键步骤：</strong></p><ol><li>添加服务指标收集器，并将其作为插件，默认有运行时状态指标收集器、请求耗时指标收集器。</li><li>运行时状态指标收集器收集服务节点 CPU 核数、CPU 负载以及内存等指标，在服务调用者与服务提供者的心跳数据中获取。</li><li>请求耗时指标收集器收集请求耗时数据，如平均耗时、TP99、TP999 等。</li><li>可以配置开启哪些指标收集器，并设置这些参考指标的指标权重，再根据指标数据和指标权重来综合打分。</li><li>通过服务节点的综合打分与节点的权重，最终计算出节点的最终权重，之后服务调用者会根据随机权重的策略，来选择服务节点。</li></ol><p><strong>RPC 框架的负载均衡与 Web 服务的负载均衡的不同之处在于：</strong></p><p>RPC 框架并不是依赖一个负载均衡设备或者负载均衡服务器来实现负载均衡的，而是由 RPC 框架本身实现的，服务调用者可以自主选择服务节点，发起服务调用。这样的好处是，RPC 框架不再需要依赖专门的负载均衡设备，可以节约成本；还减少了与负载均衡设备间额外的网络传输，提升了传输效率；并且均衡策略可配，便于服务治理。</p><h3 id="异常重试与熔断限流"><a href="#异常重试与熔断限流" class="headerlink" title="异常重试与熔断限流"></a>异常重试与熔断限流</h3><h4 id="RPC重试机制"><a href="#RPC重试机制" class="headerlink" title="RPC重试机制"></a>RPC重试机制</h4><p><img src="https://static001.geekbang.org/resource/image/32/81/32441dc643e64a022acfcbe0b4c77e81.jpg?wh=5154*1923" alt="img"></p><p>​                                                                                                                       <strong>RPC异常重试流程</strong></p><p>调用端发起的请求失败时，RPC 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。</p><p>调用端在发起 RPC 调用时，会经过负载均衡，选择一个节点，之后它会向这个节点发送请求信息。当消息发送失败或收到异常消息时，我们就可以捕获异常，根据异常触发重试，重新通过负载均衡选择一个节点发送请求消息，并且记录请求的重试次数，当重试次数达到用户配置的重试次数的时候，就返回给调用端动态代理一个失败异常，否则就一直重试下去。</p><p>RPC 框架的重试机制就是调用端发现请求失败时捕获异常，之后触发重试，那是不是所有的异常都要触发重试呢？当然不是了，因为这个异常可能是服务提供方抛回来的业务异常，它是应该正常返回给动态代理的，所以我们要在触发重试之前对捕获的异常进行判定，只有符合重试条件的异常才能触发重试，比如网络超时异常、网络连接异常等等。</p><p><strong>异常重试需要注意的问题：</strong></p><p>当网络突然抖动了一下导致请求超时了，但这个时候调用方的请求信息可能已经发送到服务提供方的节点上，也可能已经发送到服务提供方的服务节点上，那如果请求信息成功地发送到了服务节点上，那这个节点是不是就要执行业务逻辑了呢？是的。</p><p>如果该业务不是幂等，比如插入数据操作，那触发重试的话会不会引发问题呢？会的。</p><h4 id="如何在约定时间内安全可靠地重试？"><a href="#如何在约定时间内安全可靠地重试？" class="headerlink" title="如何在约定时间内安全可靠地重试？"></a>如何在约定时间内安全可靠地重试？</h4><p>RPC 框架是不会知道哪些业务异常能够去进行异常重试的，我们可以加个重试异常的白名单，用户可以将允许重试的异常加入到这个白名单中。当调用端发起调用，并且配置了异常重试策略，捕获到异常之后，我们就可以采用这样的异常处理策略。如果这个异常是 RPC 框架允许重试的异常，或者这个异常类型存在于可重试异常的白名单中，我们就允许对这个请求进行重试。</p><p><img src="https://static001.geekbang.org/resource/image/5e/81/5e5706e6fc02ef0caaee565ea358f281.jpg?wh=5129*2058" alt="img"></p><p>​                                                                                                                 <strong>可靠的异常重试机制</strong></p><h4 id="为什么需要自我保护"><a href="#为什么需要自我保护" class="headerlink" title="为什么需要自我保护"></a>为什么需要自我保护</h4><p>RPC 是解决分布式系统通信问题的一大利器，而分布式系统的一大特点就是高并发，所以说 RPC 也会面临高并发的场景。在这样的情况下，我们提供服务的每个服务节点就都可能由于访问量过大而引起一系列的问题，比如业务处理耗时过长、CPU 飘高、频繁 Full GC 以及服务进程直接宕机等等。但是在生产环境中，我们要保证服务的稳定性和高可用性，这时我们就需要业务进行自我保护，从而保证在高访问量、高并发的场景下，应用系统依然稳定，服务依然高可用。</p><h5 id="那么在使用-RPC-时，业务又如何实现自我保护呢？"><a href="#那么在使用-RPC-时，业务又如何实现自我保护呢？" class="headerlink" title="那么在使用 RPC 时，业务又如何实现自我保护呢？"></a>那么在使用 RPC 时，业务又如何实现自我保护呢？</h5><p>最常见的方式就是限流了，简单有效，但 RPC 框架的自我保护方式可不只有限流，并且 RPC 框架的限流方式可以是多种多样的。我们可以将 RPC 框架拆开来分析，RPC 调用包括服务端和调用端，调用端向服务端发起调用。下面分享一下服务端与调用端分别是如何进行自我保护的。</p><h4 id="服务端的自我保护"><a href="#服务端的自我保护" class="headerlink" title="服务端的自我保护"></a>服务端的自我保护</h4><p>举个例子，假如我们要发布一个 RPC 服务，作为服务端接收调用端发送过来的请求，这时服务端的某个节点负载压力过高了，我们该如何保护这个节点？</p><p><img src="https://static001.geekbang.org/resource/image/9b/17/9bae10ba8a5b96b03102fb9ef4f30e17.jpg?wh=2560*1315" alt="img"></p><p>那么就是限流吧？是的，<strong>在 RPC 调用中服务端的自我保护策略就是限流</strong>，那你有没有想过我们是如何实现限流的呢？是在服务端的业务逻辑中做限流吗？有没有更优雅的方式？</p><p>限流是一个比较通用的功能，我们可以在 RPC 框架中集成限流的功能，让使用方自己去配置限流阈值；我们还可以在服务端添加限流逻辑，当调用端发送请求过来时，服务端在执行业务逻辑之前先执行限流逻辑，如果发现访问量过大并且超出了限流的阈值，就让服务端直接抛回给调用端一个限流异常，否则就执行正常的业务逻辑。                                                </p><p><img src="https://static001.geekbang.org/resource/image/f8/ad/f8e8a4dd16f2fd2af366f810404057ad.jpg?wh=2563*1313" alt="img">                 </p><h5 id="服务端的限流逻辑该如何实现呢？"><a href="#服务端的限流逻辑该如何实现呢？" class="headerlink" title="服务端的限流逻辑该如何实现呢？"></a>服务端的限流逻辑该如何实现呢？</h5><p>计数器，平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等</p><h4 id="调用端的自我保护"><a href="#调用端的自我保护" class="headerlink" title="调用端的自我保护"></a>调用端的自我保护</h4><p>举个例子，假如发布一个服务 B，而服务 B 又依赖服务 C，当一个服务 A 来调用服务 B 时，服务 B 的业务逻辑调用服务 C，而这时服务 C 响应超时了，由于服务 B 依赖服务 C，C 超时直接导致 B 的业务逻辑一直等待，而这个时候服务 A 在频繁地调用服务 B，服务 B 就可能会因为堆积大量的请求而导致服务宕机。</p><p><img src="https://static001.geekbang.org/resource/image/dc/31/dc2a18f1e2c495380cc4053b92ed3131.jpg?wh=2171*1472" alt="img"></p><p>由此可见，服务 B 调用服务 C，服务 C 执行业务逻辑出现异常时，会影响到服务 B，甚至可能会引起服务 B 宕机。这还只是 A-&gt;B-&gt;C 的情况，试想一下 A-&gt;B-&gt;C-&gt;D-&gt;……呢？在整个调用链中，只要中间有一个服务出现问题，都可能会引起上游的所有服务出现一系列的问题，甚至会引起整个调用链的服务都宕机，这是非常恐怖的。</p><p>所以说，在一个服务作为调用端调用另外一个服务时，为了防止被调用的服务出现问题而影响到作为调用端的这个服务，这个服务也需要进行自我保护。<strong>而最有效的自我保护方式就是熔断。</strong></p><p><strong>熔断机制:</strong></p><p><img src="https://static001.geekbang.org/resource/image/90/64/903fa4374beb753c1db8f1f8b82ff464.jpg?wh=2642*1990" alt="img"></p><p><strong>熔断器的工作机制主要是关闭、打开和半打开这三个状态之间的切换</strong>。</p><ol><li>在正常情况下，熔断器是关闭的；</li><li>当调用端调用下游服务出现异常时，熔断器会收集异常指标信息进行计算，当达到熔断条件时熔断器打开，这时调用端再发起请求是会直接被熔断器拦截，并快速地执行失败逻辑；</li><li>当熔断器打开一段时间后，会转为半打开状态，这时熔断器允许调用端发送一个请求给服务端，如果这次请求能够正常地得到服务端的响应，则将状态置为关闭状态，否则设置为打开。</li></ol><h5 id="在-RPC-框架中，该如何整合熔断器呢？"><a href="#在-RPC-框架中，该如何整合熔断器呢？" class="headerlink" title="在 RPC 框架中，该如何整合熔断器呢？"></a>在 RPC 框架中，该如何整合熔断器呢？</h5><p>熔断机制主要是保护调用端，调用端在发出请求的时候会先经过熔断器。我们可以回想下 RPC 的调用流程：</p><p><img src="https://static001.geekbang.org/resource/image/59/87/59b7479220a415ef034fb6edb589ec87.jpg?wh=3788*1350" alt="img"></p><p><strong>哪个步骤整合熔断器会比较合适呢？</strong></p><p>动态代理，因为在 RPC 调用的流程中，动态代理是 RPC 调用的第一个关口。在发出请求时先经过熔断器，如果状态是闭合则正常发出请求，如果状态是打开则执行熔断器的失败策略。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h5 id="RPC-框架是如何实现业务的自我保护？"><a href="#RPC-框架是如何实现业务的自我保护？" class="headerlink" title="RPC 框架是如何实现业务的自我保护？"></a>RPC 框架是如何实现业务的自我保护？</h5><p><strong>服务端主要是通过限流来进行自我保护</strong>，我们在实现限流时要考虑到应用和 IP 级别，方便我们在服务治理的时候，对部分访问量特别大的应用进行合理的限流；服务端的限流阈值配置都是作用于单机的，而在有些场景下，例如对整个服务设置限流阈值，服务进行扩容时，限流的配置并不方便，我们可以在注册中心或配置中心下发限流阈值配置的时候，将总服务节点数也下发给服务节点，让 RPC 框架自己去计算限流阈值；我们还可以让 RPC 框架的限流模块依赖一个专门的限流服务，对服务设置限流阈值进行精准地控制，但是这种方式依赖了限流服务，相比单机的限流方式，在性能和耗时上有劣势。</p><p><strong>调用端可以通过熔断机制进行自我保护</strong>，防止调用下游服务出现异常，或者耗时过长影响调用端的业务逻辑，RPC 框架可以在动态代理的逻辑中去整合熔断器，实现 RPC 框架的熔断功能。</p><h5 id="服务保护一般就是限流、熔断、降级。"><a href="#服务保护一般就是限流、熔断、降级。" class="headerlink" title="服务保护一般就是限流、熔断、降级。"></a>服务保护一般就是限流、熔断、降级。</h5><p> 限流的落地方式有：Guava RateLimiter、lua+Redis、Sentinel等； 熔断：Hystrix、Resilience4j； 降级：服务降级，就是对不怎么重要的服务进行低优先级的处理。说白了，就是尽可能的把系统资源让给优先级高的服务。资源有限，而请求是无限的。</p><h4 id="业务分组"><a href="#业务分组" class="headerlink" title="业务分组"></a>业务分组</h4><p>通过分组的方式人为地给不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保障我们的核心业务不受非核心业务的干扰。但我们在考虑问题的时候，不能顾此失彼，不能因为新加一个的功能而影响到原有系统的稳定性。</p><h4 id="实践案例："><a href="#实践案例：" class="headerlink" title="实践案例："></a>实践案例：</h4><p><img src="https://s2.loli.net/2022/08/28/KPjgxwin6sIVuby.png" alt="实现.png"></p><h3 id="RPC服务重启的关闭与开启"><a href="#RPC服务重启的关闭与开启" class="headerlink" title="RPC服务重启的关闭与开启"></a>RPC服务重启的关闭与开启</h3><h4 id="在重启服务的过程中，RPC-怎么做到让调用方系统不出问题呢？"><a href="#在重启服务的过程中，RPC-怎么做到让调用方系统不出问题呢？" class="headerlink" title="在重启服务的过程中，RPC 怎么做到让调用方系统不出问题呢？"></a>在重启服务的过程中，RPC 怎么做到让调用方系统不出问题呢？</h4><p>简述下上线的大概流程：当服务提供方要上线的时候，一般是通过部署系统完成实例重启。在这个过程中，服务提供方的团队并不会事先告诉调用方他们需要操作哪些机器，从而让调用方去事先切走流量。而对调用方来说，它也无法预测到服务提供方要对哪些机器重启上线，因此负载均衡就有可能把要正在重启的机器选出来，这样就会导致把请求发送到正在重启中的机器里面，从而导致调用方不能拿到正确的响应结果。</p><p><img src="https://static001.geekbang.org/resource/image/c8/67/c899c36097fd5e3f70bf031f4b2c2167.jpg?wh=3596*1810" alt="img"></p><p><strong>在服务重启的时候，对于调用方来说，这时候可能会存在以下几种情况：</strong></p><ul><li>调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时候调用方可以立马感知到，并且在其健康列表里面会把这个节点挪掉，自然也就不会被负载均衡选中。</li><li>调用方发请求的时候，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接也没断开，所以这个节点还会存在健康列表里面，因此该节点就有一定概率会被负载均衡选中。</li></ul><h4 id="关闭流程"><a href="#关闭流程" class="headerlink" title="关闭流程"></a>关闭流程</h4><p><strong>通常的关闭流程：</strong></p><p><img src="https://static001.geekbang.org/resource/image/a1/50/a15be58b32195422bd5a18dba0e68050.jpg?wh=3195*1277" alt="img"></p><p>如上图所示，整个关闭过程中依赖了两次 RPC 调用，一次是服务提供方通知注册中心下线操作，一次是注册中心通知服务调用方下线节点操作。注册中心通知服务调用方都是异步的，我们在“服务发现”一讲中讲过在大规模集群里面，服务发现只保证最终一致性，并不保证实时性，所以注册中心在收到服务提供方下线的时候，并不能成功保证把这次要下线的节点推送到所有的调用方。</p><p>所以这么来看，通过服务发现并不能做到应用无损关闭。不能强依赖“服务发现”来通知调用方要下线的机器，那服务提供方自己来通知行不行？因为在 RPC 里面调用方跟服务提供方之间是长连接，我们可以在提供方应用内存里面维护一份调用方连接集合，当服务要关闭的时候，挨个去通知调用方去下线这台机器。这样整个调用链路就变短了，对于每个调用方来说就一次 RPC，可以确保调用的成功率很高。大部分场景下，这么做确实没有问题，我们之前也是这么实现的，但是我们发现线上还是会偶尔会出现，因为服务提供方上线而导致调用失败的问题。</p><h4 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h4><p>因为服务提供方已经开始进入关闭流程，那么很多对象就可能已经被销毁了，关闭后再收到的请求按照正常业务请求来处理，肯定是没法保证能处理的。所以我们可以在关闭的时候，设置一个请求“挡板”，挡板的作用就是告诉调用方，我已经开始进入关闭流程了，我不能再处理你这个请求了。</p><p><strong>举例：</strong>如果大家经常去银行办理业务，就会很熟悉这个流程。在交接班或者有其他要事情处理的时候，银行柜台工作人员会拿出一个纸板，放在窗口前，上面写到“该窗口已关闭”。在该窗口排队的人虽然有一万个不愿意，也只能换到其它窗口办理业务，因为柜台工作人员会把当前正在办理的业务处理完后正式关闭窗口。</p><p>基于这个思路，我们可以这么处理：当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）。这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”，然后调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损。</p><p>但如果只是靠等待被动调用，就会让这个关闭过程整体有点漫长。因为有的调用方那个时刻没有业务请求，就不能及时地通知调用方了，所以我们可以加上主动通知流程，这样既可以保证实时性，也可以避免通知失败的情况。</p><p><strong>怎么捕获到关闭事件呢？</strong></p><p>通过捕获操作系统的进程信号来获取，在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子。在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。</p><p><strong>关闭过程中已经在处理的请求会不会受到影响呢？</strong></p><p>如果进程结束过快会造成这些请求还没有来得及应答，同时调用方会也会抛出异常。为了尽可能地完成正在处理的请求，首先我们要把这些请求识别出来。</p><p>这就好比日常生活中，我们经常看见停车场指示牌上提示还有多少剩余车位，这个是如何做到的呢？如果仔细观察一下，你就会发现它是每进入一辆车，剩余车位就减一，每出来一辆车，剩余车位就加一。我们也可以利用这个原理在服务对象加上引用计数器，每开始处理请求之前加一，完成请求处理减一，通过该计数器我们就可以快速判断是否有正在处理的请求。</p><p>服务对象在关闭过程中，会拒绝新的请求，同时根据引用计数器等待正在处理的请求全部结束之后才会真正关闭。但考虑到有些业务请求可能处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以在整个 ShutdownHook 里面，加上超时时间控制，当超过了指定时间没有结束，则强制退出应用。超时时间我建议可以设定成 10s，基本可以确保请求都处理完了。整个流程如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/77/cc/7752081ec658f1d56ac4219f1c07fbcc.jpg?wh=3131*2891" alt="img"></p><h4 id="关闭总结"><a href="#关闭总结" class="headerlink" title="关闭总结"></a>关闭总结</h4><p>在 RPC 里面，关闭虽然看似不属于 RPC 主流程，但如果我们不能处理得很好的话，可能就会导致调用方业务异常，从而需要我们加入很多额外的运维工作。一个好的关闭流程，可以确保使用我们框架的业务实现平滑的上下线，而不用担心重启导致的问题。</p><p>“优雅关闭”这个概念除了在 RPC 里面有，在很多框架里面也都挺常见的，比如像我们经常用的应用容器框架 Tomcat。Tomcat 关闭的时候也是先从外层到里层逐层进行关闭，先保证不接收新请求，然后再处理关闭前收到的请求。</p><h5 id="相关解释："><a href="#相关解释：" class="headerlink" title="相关解释："></a>相关解释：</h5><p><img src="https://s2.loli.net/2022/08/28/qUCtZw2Ps7EdYDu.png" alt="image-20220723212313198.png"></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><h5 id="启动预热"><a href="#启动预热" class="headerlink" title="启动预热"></a>启动预热</h5><p>让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。</p><p><strong>实现：</strong>我们可以先简单地回顾下调用方发起的 RPC 调用流程是怎样的，调用方应用通过服务发现能够获取到服务提供方的 IP 地址，然后每次发送请求前，都需要通过负载均衡算法从连接池中选择一个可用连接。那这样的话，我们是不是就可以让负载均衡在选择连接的时候，区分一下是否是刚启动不久的应用？对于刚启动的应用，我们可以让它被选择到的概率特别低，但这个概率会随着时间的推移慢慢变大，从而实现一个动态增加流量的过程。</p><p>当服务提供方运行时长小于预热时间时，对服务提供方进行降权，减少被负载均衡选择的概率，避免让应用在启动之初就处于高负载状态，从而实现服务提供方在启动后有一个预热的过程。</p><p><img src="https://static001.geekbang.org/resource/image/e7/d4/e796da8cf26f056479a59fd97b43d0d4.jpg?wh=2558*2523" alt="img"></p><p>​                                                                                                                   <strong>预热过程图</strong></p><p>启动预热更多是从调用方的角度出发，去解决服务提供方应用冷启动的问题，让调用方的请求量通过一个时间窗口过渡，慢慢达到一个正常水平，从而实现平滑上线。但对于服务提供方本身来说，有没有相关方案可以实现这种效果呢？</p><h5 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h5><p>举例：spring应用启动的时候都是通过 main 入口，然后顺序加载各种相关依赖的类。以 Spring 应用启动为例，在加载的过程中，Spring 容器会顺序加载 Spring Bean，如果某个 Bean 是 RPC 服务的话，我们不光要把它注册到 Spring-BeanFactory 里面去，还要把这个 Bean 对应的接口注册到注册中心。注册中心在收到新上线的服务提供方地址的时候，会把这个地址推送到调用方应用内存中；当调用方收到这个服务提供方地址的时候，就会去建立连接发请求。</p><p>但这时候可能存在服务提供方并没有启动完成的情况？因为服务提供方应用可能还在加载其它的 Bean。对于调用方来说，只要获取到了服务提供方的 IP，就有可能发起 RPC 调用，但如果这时候服务提供方没有启动完成的话，就会导致调用失败，从而使业务受损。</p><p>解决方案：</p><ul><li><p>在应用启动加载、解析 Bean 的时候，如果遇到了 RPC 服务的 Bean，只先把这个 Bean 注册到 Spring-BeanFactory 里面去，而并不把这个 Bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。这样是可以保证应用在启动完后才开始接入流量的，但其实这样做，我们还是没有实现最开始的目标。因为这时候应用虽然启动完成了，但并没有执行相关的业务代码，所以 JVM 内存里面还是冷的。如果这时候大量请求过来，还是会导致整个应用在高负载模式下运行，从而导致不能及时地返回请求结果。而且在实际业务中，一个服务的内部业务逻辑一般会依赖其它资源的，比如缓存数据。如果我们能在服务正式提供服务前，先完成缓存的初始化操作，而不是等请求来了之后才去加载，我们就可以降低重启后第一次请求出错的概率。</p></li><li><p>利用服务提供方把接口注册到注册中心的那段时间。我们可以在服务提供方应用启动后，接口注册到注册中心前，预留一个 Hook 过程，让用户可以实现可扩展的 Hook 逻辑。用户可以在 Hook 里面模拟调用逻辑，从而使 JVM 指令能够预热起来，并且用户也可以在 Hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才把接口注册到注册中心。整个应用启动过程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/3c/bd/3c84f9cf6745f2d50e34bd8431c84abd.jpg?wh=3374*893" alt="img"></p></li></ul><p>​                                                                                                                <strong>启动顺序图</strong></p><h5 id="相关解释：-1"><a href="#相关解释：-1" class="headerlink" title="相关解释："></a>相关解释：</h5><p><img src="https://s2.loli.net/2022/08/28/HhWuQ9j2KxJ3Ayt.png" alt="image-20220723225147106.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="https://s2.loli.net/2022/08/28/FZ1Tlig6GQbLCvE.png" alt="image-20220724150651258.png"></p><p><img src="https://s2.loli.net/2022/08/28/tT46nkNsdzK9Vmw.png" alt="image-20220724150622961.png"></p><h4 id="分布式场景中如何做到快速定位RPC相关问题？"><a href="#分布式场景中如何做到快速定位RPC相关问题？" class="headerlink" title="分布式场景中如何做到快速定位RPC相关问题？"></a>分布式场景中如何做到快速定位RPC相关问题？</h4><p>在分布式的生产环境中，比如下面这个场景：我们搭建了一个分布式的应用系统，在这个应用系统中，我启动了 4 个子服务，分别是服务 A、服务 B、服务 C 与服务 D，而这 4 个服务的依赖关系是 A-&gt;B-&gt;C-&gt;D，而这些服务又都部署在不同的机器上。在 RPC 调用中，如果服务端的业务逻辑出现了异常，就会把异常抛回给调用端，那么如果现在这个调用链中有一个服务出现了异常，我们该如何定位问题呢？</p><h5 id="方法-1：借助合理封装的异常信息"><a href="#方法-1：借助合理封装的异常信息" class="headerlink" title="方法 1：借助合理封装的异常信息"></a>方法 1：借助合理封装的异常信息</h5><p><img src="https://static001.geekbang.org/resource/image/b8/1b/b8fee37688d39ae7913429f6cbc06f1b.jpg?wh=4498*1228" alt="img"></p><h5 id="方法-2：借助分布式链路跟踪"><a href="#方法-2：借助分布式链路跟踪" class="headerlink" title="方法 2：借助分布式链路跟踪"></a>方法 2：借助分布式链路跟踪</h5><p><img src="https://s2.loli.net/2022/08/28/ldO1BCDz3xqs7ay.png" alt="image-20220724163935463.png"></p><h4 id="流量回放"><a href="#流量回放" class="headerlink" title="流量回放"></a>流量回放</h4><p><img src="https://s2.loli.net/2022/08/28/Cq24cT78wnWaYRz.png" alt="image-20220724170611177.png"></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang内存分配和垃圾回收</title>
    <link href="/2022/08/27/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/08/27/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang内存管理和垃圾回收"><a href="#Golang内存管理和垃圾回收" class="headerlink" title="Golang内存管理和垃圾回收"></a>Golang内存管理和垃圾回收</h1><p>现代高级编程语言管理内存的方式分自动和手动两种。手动管理内存的典型代表是C和C++，编写代码过程中需要主动申请或者释放内存；而PHP、Java 和Go等语言使用自动的内存管理系统，由内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。今天腾讯后台开发工程师汪汇向大家分享 Golang 垃圾回收算法。（当然，Rust 是另一种）</p><p>从Go v1.12版本开始，Go使用了<strong>非分代的、并发的、基于三色标记清除的垃圾回收器</strong>。相关标记清除算法可以参考C&#x2F;C++，而Go是一种静态类型的编译型语言。因此，Go不需要VM，Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime)，可以处理诸如垃圾收集(GC)、调度和并发之类的语言功能。首先让我们看一下Go内部的内存管理是什么样子的。</p><h2 id="一、-Golang内存管理"><a href="#一、-Golang内存管理" class="headerlink" title="一、 Golang内存管理"></a><strong>一、 Golang内存管理</strong></h2><p>这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。</p><ul><li>G: Goroutine 执行的上下文环境。</li><li>M: 操作系统线程。</li><li>P: Processer。进程调度的关键，调度器，也可以认为约等于CPU。</li></ul><p>一个 Goroutine 的运行需要G+P+M三部分结合起来。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpQu2e0dr5z6Za2b2aIw9peb8icIQyc29bC7VNuYfPh81ibaUdoSJg6ibicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p> 图源：《Golang—内存管理(内存分配)》</p><p>(<a href="http://t.zoukankan.com/zpcoding-p-13259943.html">http://t.zoukankan.com/zpcoding-p-13259943.html</a>)</p><h3 id="（一）TCMalloc"><a href="#（一）TCMalloc" class="headerlink" title="（一）TCMalloc"></a><strong>（一）TCMalloc</strong></h3><p>Go将内存划分和分组为页（Page），这和Java的内存结构完全不同，没有分代内存，这样的原因是Go的内存分配器采用了TCMalloc的<strong>设计思想</strong>：</p><h4 id="1-Page"><a href="#1-Page" class="headerlink" title="1.Page"></a><strong>1.Page</strong></h4><p>与TCMalloc中的Page相同，x64下1个Page的大小是8KB。上图的最下方，1个浅蓝色的长方形代表1个Page。</p><h4 id="2-Span"><a href="#2-Span" class="headerlink" title="2.Span"></a><strong>2.Span</strong></h4><p>与TCMalloc中的Span相同，Span是内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。</p><h4 id="3-mcache"><a href="#3-mcache" class="headerlink" title="3.mcache"></a><strong>3.mcache</strong></h4><p>mcache是提供给P（逻辑处理器）的高速缓存，用于存储小对象（对象大小&lt;&#x3D; 32Kb）。尽管这类似于线程堆栈，但它是堆的一部分，用于动态数据。所有类大小的mcache包含scan和noscan类型mspan。Goroutine可以从mcache没有任何锁的情况下获取内存，因为一次P只能有一个锁G。因此，这更有效。mcache从mcentral需要时请求新的span。</p><h4 id="4-mcentral"><a href="#4-mcentral" class="headerlink" title="4.mcentral"></a><strong>4.mcentral</strong></h4><p>mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。每个mcentral包含两个mspanList：</p><ul><li>empty：双向span链表，包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时，它将被移至non-empty span链表。</li><li>non-empty：有空闲对象的span双向链表。当从mcentral请求新的span，mcentral将从该链表中获取span并将其移入empty span链表。</li></ul><h4 id="5-mheap"><a href="#5-mheap" class="headerlink" title="5.mheap"></a><strong>5.mheap</strong></h4><p>mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，也是垃圾回收的重点区域，把从OS申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。</p><h4 id="6-栈"><a href="#6-栈" class="headerlink" title="6.栈"></a><strong>6.栈</strong></h4><p>这是栈存储区，每个Goroutine（G）有一个栈。在这里存储了静态数据，包括函数栈帧，静态结构，原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事。</p><h3 id="7-TCMalloc为什么快："><a href="#7-TCMalloc为什么快：" class="headerlink" title="7.TCMalloc为什么快："></a>7.TCMalloc为什么快：</h3><p>1.使用了thread cache（线程cache），小块的内存分配都可以从cache中分配，这样再多线程分配内存的情况下，可以减少锁竞争。</p><p>2.tcmalloc会为每个线程分配本地缓存，小对象请求可以直接从本地缓存获取，如果没有空闲内存，则从central heap中一次性获取一连串小对象。大对象是直接使用页级分配器（page-level allocator）从Central page Heap中进行分配，即一个大对象总是按页对齐的。tcmalloc对于小内存，按8的整数次倍分配，对于大内存，按4K的整数次倍分配。</p><p>3.当某个线程缓存中所有对象的总大小超过2MB的时候，会进行垃圾收集。垃圾收集阈值会自动根据线程数量的增加而减少，这样就不会因为程序有大量线程而过度浪费内存。</p><p>4.tcmalloc为每个线程分配一个thread-local cache，小对象的分配直接从thread-local cache中分配。根据需要将对象从CentralHeap中移动到thread-local cache，同时定期的用垃圾回收器把内存从thread-local cache回收到Central free list中。</p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><p>ThreadCache（用于小对象分配）：线程本地缓存，每个线程独立维护一个该对象，多线程在并发申请内存时不会产生锁竞争。</p><p>CentralCache（Central free list，用于小对象分配）：全局cache，所有线程共享。当thread cache空闲链表为空时，会批量从CentralCache中申请内存；当thread cache总内存超过阈值，会进行内存垃圾回收，将空闲内存返还给CentralCache。</p><p>Page Heap（小&#x2F;大对象）：全局页堆，所有线程共享。对于小对象，当centralcache为空时，会从page heap中申请一个span；当一个span完全空闲时，会将该span返还给page heap。对于大对象，直接从page heap中分配，用完直接返还给page heap。系统内存：当page cache内存用光后，会通过sbrk、mmap等系统调用向OS申请内存。</p><h3 id="（二）内存分配"><a href="#（二）内存分配" class="headerlink" title="（二）内存分配"></a><strong>（二）内存分配</strong></h3><p>Go 中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。</p><p><strong>核心思想</strong>：把内存分为多级管理，降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型，减少分配产生的内存碎片。</p><ul><li>*<em>*微小对象(Tiny)（size&lt;16B*</em>*<em>）*</em>*</li></ul><p>使用mcache的微小分配器分配小于16个字节的对象，并且在单个16字节块上可完成多个微小分配。</p><ul><li><em><strong>*小对象（尺寸16B〜32KB）*</strong></em></li></ul><p>大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache的对应的mspan size class上。</p><ul><li><em><strong>*大对象（大小&gt;32KB）*</strong></em></li></ul><p>大于32 KB的对象直接分配在mheap的相应大小类上(size class)。</p><ul><li>如果mheap为空或没有足够大的页面满足分配请求，则它将从操作系统中分配一组新的页（至少1MB）。</li><li>如果对应的大小规格在mcache中没有可用的块，则向mcentral申请。</li><li>如果mcentral中没有可用的块，则向mheap申请，并根据BestFit 算法找到最合适的mspan。如果申请到的mspan超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表。</li><li>如果mheap中没有可用span，则向操作系统申请一系列新的页（最小 1MB）。Go 会在操作系统分配超大的页（称作arena）。分配一大批页会减少和操作系统通信的成本。</li></ul><h3 id="（三）内存回收"><a href="#（三）内存回收" class="headerlink" title="（三）内存回收"></a><strong>（三）内存回收</strong></h3><p>go内存会分成堆区（Heap）和栈区（Stack）两个部分，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁。如果只申请和分配内存，内存终将枯竭。Go使用垃圾回收收集不再使用的span，把span释放交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配。<strong>因此，Go堆是Go垃圾收集器管理的主要区域</strong>。</p><h2 id="二、常见的GC算法"><a href="#二、常见的GC算法" class="headerlink" title="二、常见的GC算法"></a>二、常见的GC算法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。</p><ul><li>优点：简单直接，回收速度快</li><li>缺点：需要额外的空间存放计数，无法处理循环引用的情况；</li></ul><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>对象引用链：通过一系列的称为”GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain) ，如果一个对象到GCRoots没有任何引用链相连，或者用图论的话来说，就是，从GCRoots到这个对象不可达时，则证明此对象是不可用的。</p><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><p>1.全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</p><p>2.执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</p><p>3.寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。<br><img src="https://img-blog.csdnimg.cn/20200801163955410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDA5MjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/mark_clean.png" alt="mark_clean"></p><ul><li>优点：简单直接，速度快，适合可回收对象不多的场景</li><li>缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配；</li></ul><h3 id="复制法"><a href="#复制法" class="headerlink" title="复制法"></a>复制法</h3><p>复制法将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/copy_method.png" alt="copy_method"></p><ul><li>优点：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；</li><li>缺点：有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；</li></ul><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/mark_tidy.png" alt="mark_tidy"></p><ul><li>优点：解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用；</li><li>缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；</li></ul><h3 id="分代式"><a href="#分代式" class="headerlink" title="分代式"></a>分代式</h3><p>将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p><h3 id="Golang的垃圾回收（GC）算法"><a href="#Golang的垃圾回收（GC）算法" class="headerlink" title="Golang的垃圾回收（GC）算法"></a>Golang的垃圾回收（GC）算法</h3><p>Golang的垃圾回收（GC）算法使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：</p><ul><li>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于<code>tcmalloc</code>，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于<code>tcmalloc</code>的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。</li><li>分代<code>GC</code>依赖分代假设，即<code>GC</code>将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。</li><li>Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代<code>GC</code>回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当<code>goroutine</code>死亡后栈也会被直接回收，不需要<code>GC</code>的参与，进而分代假设并没有带来直接优势。</li><li>Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。</li></ul><h2 id="三、Go的垃圾回收"><a href="#三、Go的垃圾回收" class="headerlink" title="三、Go的垃圾回收"></a>三、Go的垃圾回收</h2><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，Go V1.3之前的标记-清除(mark and sweep)算法，Go V1.3之前的标记-清扫(mark and sweep)的缺点</p><ul><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li><li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li><li>Go V1.8混合写屏障机制</li><li>Go V1.8混合写屏障机制的全场景分析</li></ul><h3 id="（一）、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#（一）、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="（一）、Go V1.3之前的标记-清除(mark and sweep)算法"></a>（一）、Go V1.3之前的标记-清除(mark and sweep)算法</h3><p>在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><h4 id="1-标记清除算法的具体步骤"><a href="#1-标记清除算法的具体步骤" class="headerlink" title="1 标记清除算法的具体步骤"></a>1 标记清除算法的具体步骤</h4><p><strong>第一步</strong>，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_43,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_44,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p><strong>第三步</strong>,  标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_38,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h4 id="2-标记-清除-mark-and-sweep-的缺点"><a href="#2-标记-清除-mark-and-sweep-的缺点" class="headerlink" title="2 标记-清除(mark and sweep)的缺点"></a>2 标记-清除(mark and sweep)的缺点</h4><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><ul><li>STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；</li><li>标记需要扫描整个heap；</li><li>清除数据会产生heap碎片。</li></ul><p>Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_69,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_69,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><br>上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是<strong>mark-and-sweep 算法会暂停整个程序</strong> 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题.</p><h3 id="（二）、Go-V1-5的三色并发标记法"><a href="#（二）、Go-V1-5的三色并发标记法" class="headerlink" title="（二）、Go V1.5的三色并发标记法"></a>（二）、Go V1.5的三色并发标记法</h3><p>为了解决标记清除算法带来的STW问题，Go和Java都会实现三色可达性分析标记算法的变种以缩短STW的时间。三色可达性分析标记算法按“是否被访问过”将程序中的对象分成白色、黑色和灰色：</p><ul><li><strong>白色对象 — 对象尚未被垃圾收集器访问过，在可达性分析刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍然是白色的对象，即代表不可达。</strong></li><li><strong>黑色对象 — 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过，黑色的对象代表已经被扫描过而且是安全存活的，如果有其他对象只想黑色对象无需再扫描一遍，黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</strong></li><li><strong>灰色对象 — 表示对象已经被垃圾收集器访问过，但是这个对象上至少存在一个引用还没有被扫描过，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。</strong></li></ul><p>三色可达性分析算法大致的流程是（初始状态所有对象都是白色）：</p><p><strong>1.从GC Roots开始枚举，它们所有的直接引用变为灰色（移入灰色集合），GC Roots变为黑色。</strong></p><p><strong>2.从灰色集合中取出一个灰色对象进行分析：</strong></p><ul><li><strong>将这个对象所有的直接引用变为灰色，放入灰色集合中；</strong></li><li><strong>将这个对象变为黑色。</strong></li></ul><p><strong>3.重复步骤2，一直重复直到灰色集合为空。</strong></p><p><strong>4.分析完成，仍然是白色的对象就是GC Roots不可达的对象，可以作为垃圾被清理。</strong></p><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的<strong>STW(stop the world)<strong>，所谓</strong>三色标记法</strong>实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p><strong>第一步</strong> , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_61,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><strong>第二步</strong>, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><br>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><br>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象，如图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。</p><p>以上我们将全部的白色对象进行删除回收，<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img">剩下的就是全部依赖的黑色对象。</p><p>三色标记清除算法本身是不可以并发或者增量执行的，<strong>它需要STW</strong>，<strong>而如果并发执行，用户程序可能在标记执行的过程中修改对象的指针。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpDGBI8liaibcvyXxOjP7kowzG1TnVmgAJefhegPo2IJiabXQ6IxnRdVqPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="没有STW的异常情况一般会有2种："><a href="#没有STW的异常情况一般会有2种：" class="headerlink" title="没有STW的异常情况一般会有2种："></a><strong>没有STW的异常情况一般会有2种：</strong></h3><p>1.一种是把原本应该垃圾回收的死亡对象错误的标记为存活。虽然这不好，但是不会导致严重后果，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以，比如上图所示的三色标记过程中，用户程序取消了从B对象到E对象的引用，但是因为B到E已经被标记完成不会继续执行步骤2，所以E对象最终会被错误的标记成黑色，不会被回收，这个D就是<strong>浮动垃圾</strong>，会在下次垃圾收集中清理。</p><p>2.一种是把原本存活的对象错误的标记为已死亡，导致“对象消失”，这在内存管理中是非常严重的错误。比如上图所示的三色标记过程中，用户程序建立了从B对象到H对象的引用(例如<strong>B.next &#x3D;H</strong>)，接着执行<strong>D.next&#x3D;nil</strong>，但是因为B到H中不存在灰色对象，因此在这之间不会继续执行三色并发标记中的步骤2，D到H之间的链接被断开，所以H对象最终会被标记成白色，会被垃圾收集器错误地回收。我们将这种错误称为<strong>悬挂指针</strong>，即指针没有指向特定类型的合法对象，影响了内存的安全性。</p><h3 id="没有STW的三色标记法情况下-—-悬挂指针的具体介绍"><a href="#没有STW的三色标记法情况下-—-悬挂指针的具体介绍" class="headerlink" title="没有STW的三色标记法情况下  — 悬挂指针的具体介绍"></a>没有STW的三色标记法情况下  — 悬挂指针的具体介绍</h3><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？<br>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>1.我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。<br><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_1.png" alt="no_STW_1"></p><p>2.现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_2.png" alt="no_STW_2"></p><ol start="3"><li>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</li></ol><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_3.png" alt="no_STW_3"></p><p>4.然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。<img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_4.png" alt="no_STW_4"></p><p>5.那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/no_STW_5.png" alt="no_STW_5"><br>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p><strong>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</strong></p><ul><li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**<br>如果当以上两个条件同时满足时，就会出现对象丢失现象!</li></ul><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="四、屏障技术"><a href="#四、屏障技术" class="headerlink" title="四、屏障技术"></a><strong>四、屏障技术</strong></h2><p>为了解决上述的“对象消失”的现象，Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>因此为了我们要解决并发扫描时的对象消失问题，保证垃圾收集算法的正确性，只需破坏这两个条件的任意一个即可，<strong>屏障技术</strong>就是在并发或者增量标记过程中保证<strong>三色不变性</strong>的重要技术。</p><p>内存屏障技术是一种屏障指令，它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。垃圾收集中的屏障技术更像是一个<strong>钩子方法</strong>，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成<strong>读屏障（Read barrier）</strong>和写屏障（Write barrier）两种，<strong>因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</strong></p><p><strong>重点</strong>：</p><ol><li><strong>写屏障的代码在编译期间生成好，之后不会再变化；</strong></li><li>堆上对象赋值才会生成写屏障；</li><li>哪些对象分配在栈上，哪些分配在堆上？也是编译期间由编译器决定，这个过程叫做“逃逸分析”；</li></ol><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>下面的例子使用的是 go1.13.3。</p><h5 id="示例分析代码"><a href="#示例分析代码" class="headerlink" title="示例分析代码"></a>示例分析代码</h5><p>写屏障是编译器生成的，先形象看下代码样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-number">1</span> <span class="hljs-keyword">package</span> main<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-keyword">type</span> BaseStruct <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-number">4</span>     name <span class="hljs-type">string</span><br> <span class="hljs-number">5</span>     age  <span class="hljs-type">int</span><br> <span class="hljs-number">6</span> &#125;<br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span> <span class="hljs-keyword">type</span> Tstruct <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-number">9</span>     base   *BaseStruct<br><span class="hljs-number">10</span>     field0 <span class="hljs-type">int</span><br><span class="hljs-number">11</span> &#125;<br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcAlloc0</span> <span class="hljs-params">(a *Tstruct)</span></span> &#123;<br><span class="hljs-number">14</span>     a.base = <span class="hljs-built_in">new</span>(BaseStruct)    <span class="hljs-comment">// new 一个BaseStruct结构体，赋值给 a.base 字段</span><br><span class="hljs-number">15</span> &#125;<br><span class="hljs-number">16</span> <br><span class="hljs-number">17</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcAlloc1</span> <span class="hljs-params">(b *Tstruct)</span></span> &#123;<br><span class="hljs-number">18</span>     <span class="hljs-keyword">var</span> b0 Tstruct<br><span class="hljs-number">19</span>     b0.base = <span class="hljs-built_in">new</span>(BaseStruct)  <span class="hljs-comment">// new 一个BaseStruct结构体，赋值给 b0.base 字段</span><br><span class="hljs-number">20</span> &#125;<br><span class="hljs-number">21</span> <br><span class="hljs-number">22</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-number">23</span>     a := <span class="hljs-built_in">new</span>(Tstruct)    <span class="hljs-comment">// new 一个Tstruct 结构体</span><br><span class="hljs-number">24</span>     b := <span class="hljs-built_in">new</span>(Tstruct)   <span class="hljs-comment">// new 一个Tstruct 结构体</span><br><span class="hljs-number">25</span>     <br><span class="hljs-number">26</span>     <span class="hljs-keyword">go</span> funcAlloc0(a)<br><span class="hljs-number">27</span>     <span class="hljs-keyword">go</span> funcAlloc1(b)<br><span class="hljs-number">28</span> &#125;<br></code></pre></td></tr></table></figure><p>这里例子，可以用来观察两个东西：</p><ol><li>逃逸分析</li><li>编译器插入内存屏障的时机</li></ol><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>只有堆上对象的写才会可能有写屏障，因为如果对栈上的写做拦截，那么流程代码会非常复杂，并且性能下降会非常大，得不偿失。根据局部性的原理来说，其实我们程序跑起来，大部分的其实都是操作在栈上，函数参数啊、函数调用导致的压栈出栈啊、局部变量啊，协程栈，这些如果也弄起写屏障，那么可想而知了，根本就不现实，复杂度和性能就是越不过去的坎。</p><p>继续看逃逸什么意思？就是内存分配到堆上。golang 可以在编译的时候使用 <code>-m</code> 参数支持把这个可视化出来：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> build -gcflags <span class="hljs-string">&quot;-N -l -m&quot;</span> ./test_writebarrier0.<span class="hljs-keyword">go</span> <br># <span class="hljs-keyword">command</span>-<span class="hljs-built_in">line</span>-arguments<br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>:<span class="hljs-number">18</span>: funcAlloc0 <span class="hljs-keyword">a</span> does not <span class="hljs-built_in">escape</span><br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>:<span class="hljs-number">17</span>: <span class="hljs-keyword">new</span>(BaseStruct) escapes <span class="hljs-keyword">to</span> heap<br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">17</span>:<span class="hljs-number">18</span>: funcAlloc1 <span class="hljs-keyword">b</span> does not <span class="hljs-built_in">escape</span><br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">19</span>:<span class="hljs-number">18</span>: funcAlloc1 <span class="hljs-keyword">new</span>(BaseStruct) does not <span class="hljs-built_in">escape</span><br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span>:<span class="hljs-number">13</span>: <span class="hljs-keyword">new</span>(Tstruct) escapes <span class="hljs-keyword">to</span> heap<br>./test_writebarrier0.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span>:<span class="hljs-number">13</span>: <span class="hljs-keyword">new</span>(Tstruct) escapes <span class="hljs-keyword">to</span> heap<br></code></pre></td></tr></table></figure><p><strong>先说逃逸分析两点原则</strong>：</p><ol><li>在保证程序正确性的前提下，尽可能的把对象分配到栈上，这样性能最好；<ol><li>栈上的对象生命周期就跟随 goroutine ，协程终结了，它就没了</li></ol></li><li>明确一定要分配到堆上对象，或者不确定是否要分配在堆上的对象，那么就全都分配到堆上；<ol><li>这种对象的生命周期始于业务程序的创建，终于垃圾回收器的回收</li></ol></li></ol><p>我们看到源代码，有四次 new 对象的操作，经过编译器的“逃逸分析”之后，实际分配到堆上的是三次：</p><ol><li><p>14 行 —— 触发逃逸（分配到堆上）</p><ol><li>这个必须得分配到堆上，因为除了这个 goroutine 还要存活呢</li></ol></li><li><p>19 行 —— 无 （分配到栈上）</p><ol><li>这个虽然也是 new，单就分配到栈上就行，因为 b0 这个对象就是一个纯粹的栈对象</li></ol></li><li><p>23 行 —— 触发逃逸 （分配到堆上）</p><ol><li>这个需要分配到堆上，因为分配出来的对象需要传递到其他协程使用</li></ol></li><li><p>24 行 —— 触发逃逸 （分配到堆上）</p><p>  1.这次必须注意下，其实站在我们上帝视角，这次的分配其实也可以分配到栈上。这种情况编译器就简单处理了，直接给分配到堆上。这种就属于编译器它摸不准的，那么分配到堆上就对了，反正也就性能有点影响，功能不会有问题，不然的话你真分配到栈上了，一旦栈被回收就出问题了</p></li></ol><h5 id="写屏障真实的样子"><a href="#写屏障真实的样子" class="headerlink" title="写屏障真实的样子"></a>写屏障真实的样子</h5><p>再看下编译器汇编的代码：</p><p>![汇编后]<img src="https://cdn.jsdelivr.net/gh/longpi1/blog-img/20220919223939.png"></p><p>从这个地方我们需要知道一个事情，go 的关键字语法呀，其实在编译的时候，都会对应到一个特定的函数，比如 new 这个关键字就对应了 <code>newobject</code> 函数，go 这个关键字对应的是 <code>newproc</code> 函数。贴一张比较完整的图：</p><p><img src="https://cdn.jsdelivr.net/gh/longpi1/blog-img/20220919224028.png"></p><p>从这个汇编代码我们也确认了，23，24行的对象分配确实是在堆上。我们再看下函数 <code>funcAlloc0</code> 和 <code>funcAlloc1</code> 这两个。</p><p><strong><code>main.funcAlloc0</code></strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span>func funcAlloc0 (a *Tstruct) &#123;<br><span class="hljs-symbol">14 </span>    a.<span class="hljs-keyword">base</span> = <span class="hljs-keyword">new</span>(BaseStruct)    // <span class="hljs-keyword">new</span> 一个BaseStruct结构体，赋值给 a.<span class="hljs-keyword">base</span> 字段<br><span class="hljs-symbol">15 </span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/liqingqiya/liqingqiya.github.io/images/posts/2020-07-11-gc2/23DEE999-886F-4298-BCAE-EDB4F7A0B454.png"></p><p>简单的注释解析：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(gdb) disassemble <br>Dump of assembler code for function main<span class="hljs-number">.</span>funcAlloc0:<br>   <span class="hljs-number">0x0000000000456b10</span> &lt;+<span class="hljs-number">0</span>&gt;:     <span class="hljs-keyword">mov</span>    %fs:<span class="hljs-number">0xfffffffffffffff8</span>,%rcx<br>   <span class="hljs-number">0x0000000000456b19</span> &lt;+<span class="hljs-number">9</span>&gt;:     <span class="hljs-keyword">cmp</span>    <span class="hljs-number">0x10</span>(%rcx),%rsp<br>   <span class="hljs-number">0x0000000000456b1d</span> &lt;+<span class="hljs-number">13</span>&gt;:    <span class="hljs-keyword">jbe</span>    <span class="hljs-number">0x456b6f</span> &lt;main<span class="hljs-number">.</span>funcAlloc0+<span class="hljs-number">95</span>&gt;<br>   <span class="hljs-number">0x0000000000456b1f</span> &lt;+<span class="hljs-number">15</span>&gt;:    <span class="hljs-keyword">sub</span>    <span class="hljs-number">$0</span>x20,%rsp<br>   <span class="hljs-number">0x0000000000456b23</span> &lt;+<span class="hljs-number">19</span>&gt;:    <span class="hljs-keyword">mov</span>    %rbp,<span class="hljs-number">0x18</span>(%rsp)<br>   <span class="hljs-number">0x0000000000456b28</span> &lt;+<span class="hljs-number">24</span>&gt;:    <span class="hljs-keyword">lea</span>    <span class="hljs-number">0x18</span>(%rsp),%rbp<br>   <span class="hljs-number">0x0000000000456b2d</span> &lt;+<span class="hljs-number">29</span>&gt;:    <span class="hljs-keyword">lea</span>    <span class="hljs-number">0x1430c</span>(%rip),%rax        # <span class="hljs-number">0x46ae40</span><br>   <span class="hljs-number">0x0000000000456b34</span> &lt;+<span class="hljs-number">36</span>&gt;:    <span class="hljs-keyword">mov</span>    %rax,(%rsp)<br>   <span class="hljs-number">0x0000000000456b38</span> &lt;+<span class="hljs-number">40</span>&gt;:    callq  <span class="hljs-number">0x40b060</span> &lt;runtime<span class="hljs-number">.</span>newobject&gt;<br>   # newobject的返回值在 <span class="hljs-number">0x8</span>(%rsp) 里，golang 的参数和返回值都是通过栈传递的。这个跟 c 程序不同，c 程序是溢出才会用到栈，这里先把返回值放到寄存器 <span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x0000000000456b3d</span> &lt;+<span class="hljs-number">45</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x8</span>(%rsp),%rax           <br>   <span class="hljs-number">0x0000000000456b42</span> &lt;+<span class="hljs-number">50</span>&gt;:    <span class="hljs-keyword">mov</span>    %rax,<span class="hljs-number">0x10</span>(%rsp)<br>   # <span class="hljs-number">0x28</span>(%rsp) 就是 a 的地址：<span class="hljs-number">0xc0000840b0</span><br>=&gt; <span class="hljs-number">0x0000000000456b47</span> &lt;+<span class="hljs-number">55</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x28</span>(%rsp),%rdi         <br>   <span class="hljs-number">0x0000000000456b4c</span> &lt;+<span class="hljs-number">60</span>&gt;:    <span class="hljs-keyword">test</span>   %al,(%rdi)<br>   # 这里判断是否开启了屏障（垃圾回收的扫描并发过程，才会把这个标记打开，没有打开的情况，对于堆上的赋值只是多走一次判断开销）<br>   <span class="hljs-number">0x0000000000456b4e</span> &lt;+<span class="hljs-number">62</span>&gt;:    cmpl   <span class="hljs-number">$0</span>x0,<span class="hljs-number">0x960fb</span>(%rip)        # <span class="hljs-number">0x4ecc50</span> &lt;runtime<span class="hljs-number">.</span>writeBarrier&gt;<br>   <span class="hljs-number">0x0000000000456b55</span> &lt;+<span class="hljs-number">69</span>&gt;:    <span class="hljs-keyword">je</span>     <span class="hljs-number">0x456b59</span> &lt;main<span class="hljs-number">.</span>funcAlloc0+<span class="hljs-number">73</span>&gt;<br>   <span class="hljs-number">0x0000000000456b57</span> &lt;+<span class="hljs-number">71</span>&gt;:    <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x456b68</span> &lt;main<span class="hljs-number">.</span>funcAlloc0+<span class="hljs-number">88</span>&gt;<br>   # 赋值 a<span class="hljs-number">.</span>base = xxxx<br>   <span class="hljs-number">0x0000000000456b59</span> &lt;+<span class="hljs-number">73</span>&gt;:    <span class="hljs-keyword">mov</span>    %rax,(%rdi)<br>   <span class="hljs-number">0x0000000000456b5c</span> &lt;+<span class="hljs-number">76</span>&gt;:    <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x456b5e</span> &lt;main<span class="hljs-number">.</span>funcAlloc0+<span class="hljs-number">78</span>&gt;<br>   <span class="hljs-number">0x0000000000456b5e</span> &lt;+<span class="hljs-number">78</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x18</span>(%rsp),%rbp<br>   <span class="hljs-number">0x0000000000456b63</span> &lt;+<span class="hljs-number">83</span>&gt;:    <span class="hljs-keyword">add</span>    <span class="hljs-number">$0</span>x20,%rsp<br>   <span class="hljs-number">0x0000000000456b67</span> &lt;+<span class="hljs-number">87</span>&gt;:    retq   <br>   # 如果是开启了屏障，那么完成 a<span class="hljs-number">.</span>base = xxx 的赋值就是在 gcWriteBarrier 函数里面了<br>   <span class="hljs-number">0x0000000000456b68</span> &lt;+<span class="hljs-number">88</span>&gt;:    callq  <span class="hljs-number">0x44d170</span> &lt;runtime<span class="hljs-number">.</span>gcWriteBarrier&gt;<br>   <span class="hljs-number">0x0000000000456b6d</span> &lt;+<span class="hljs-number">93</span>&gt;:    <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x456b5e</span> &lt;main<span class="hljs-number">.</span>funcAlloc0+<span class="hljs-number">78</span>&gt;<br>   <span class="hljs-number">0x0000000000456b6f</span> &lt;+<span class="hljs-number">95</span>&gt;:    callq  <span class="hljs-number">0x44b370</span> &lt;runtime<span class="hljs-number">.</span>morestack_noctxt&gt;<br>   <span class="hljs-number">0x0000000000456b74</span> &lt;+<span class="hljs-number">100</span>&gt;:   <span class="hljs-keyword">jmp</span>    <span class="hljs-number">0x456b10</span> &lt;main<span class="hljs-number">.</span>funcAlloc0&gt;<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p><strong>所以，从上面简单的汇编代码，我们印证得出几个小知识点</strong>：</p><ol><li>golang 传参和返回参数都是通过栈来传递的（可以思考下优略点，有点是逻辑简单了，也能很好的支持多返回值的实现，缺点是比寄存器的方式略慢，但是这种损耗在程序的运行下可以忽略）；</li><li>写屏障是一段编译器插入的特殊代码，在编译期间插入，代码函数名字叫做 <code>gcWriteBarrier</code> ；</li><li>屏障代码并不是直接运行，也是要条件判断的，并不是只要是堆上内存赋值就会运行gcWriteBarrier 代码，而是要有一个条件判断。这里提前透露下，这个条件判断是垃圾回收器扫描开始前，stw 程序给设置上去的；<ol><li>所以平时对于堆上内存的赋值，多了一次写操作；</li></ol></li></ol><p>伪代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> runtime.writeBarrier.enabled &#123;<br>    runtime.gc<span class="hljs-constructor">WriteBarrier(<span class="hljs-params">ptr</span>, <span class="hljs-params">val</span>)</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    *ptr = <span class="hljs-keyword">val</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>runtime·gcWriteBarrier</code> 函数干啥的，这个函数是用纯汇编写的，举一个特定cpu集合的例子，在 asm_amd64.s 里的实现。这个函数只干两件事：</p><ol><li>执行写请求</li><li>处理 GC 相关的逻辑</li></ol><p>下面简单理解下 <code>runtime·gcWriteBarrier</code> 这个函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">TEXT runtime·gcWriteBarrier(SB),<span class="hljs-built_in">NOSPLIT</span>,<span class="hljs-number">$120</span><br><br>        get_tls(<span class="hljs-built_in">R13</span>)<br>        <span class="hljs-keyword">MOVQ</span>    g(<span class="hljs-built_in">R13</span>), <span class="hljs-built_in">R13</span><br>        <span class="hljs-keyword">MOVQ</span>    g_m(<span class="hljs-built_in">R13</span>), <span class="hljs-built_in">R13</span><br>        <span class="hljs-keyword">MOVQ</span>    m_p(<span class="hljs-built_in">R13</span>), <span class="hljs-built_in">R13</span><br>        <span class="hljs-keyword">MOVQ</span>    (p_wbBuf+wbBuf_next)(<span class="hljs-built_in">R13</span>), <span class="hljs-built_in">R14</span><br><br>        LEAQ    <span class="hljs-number">16</span>(<span class="hljs-built_in">R14</span>), <span class="hljs-built_in">R14</span><br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">R14</span>, (p_wbBuf+wbBuf_next)(<span class="hljs-built_in">R13</span>)<br>    // 检查 buffer 队列是否满？<br>        CMPQ    <span class="hljs-built_in">R14</span>, (p_wbBuf+wbBuf_end)(<span class="hljs-built_in">R13</span>)<br><br>    // 赋值的前后两个值都会被入队<br><br>        // 把 value 存到指定 buffer 位置<br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">AX</span>, -<span class="hljs-number">16</span>(<span class="hljs-built_in">R14</span>)   // Record value<br><br>    // 把 *slot 存到指定 buffer 位置<br>        <span class="hljs-keyword">MOVQ</span>    (<span class="hljs-built_in">DI</span>), <span class="hljs-built_in">R13</span><br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">R13</span>, -<span class="hljs-number">8</span>(<span class="hljs-built_in">R14</span>)<br><br>    // 如果 wbBuffer 队列满了，那么就下刷处理，比如置灰，置黑等操作<br>        JEQ     flush<br><span class="hljs-symbol">ret:</span><br>    // 赋值：*slot = val <br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-number">104</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">R14</span><br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-number">112</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">R13</span><br>        <span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">AX</span>, (<span class="hljs-built_in">DI</span>)<br>        <span class="hljs-keyword">RET</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">flush:</span><br>    。。。<br><br>        //  队列满了，统一处理，这个其实是一个批量优化手段<br>        <span class="hljs-keyword">CALL</span>    runtime·wbBufFlush(SB)<br><br>    。。。<br><br>        <span class="hljs-keyword">JMP</span>     <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p><strong>思考下：不是说把 <code>\*slot = value</code> 直接置灰色，置黑色，就完了嘛，这里搞得这么复杂？</strong></p><p>最开始还真不是这样的，这个也是一个优化的过程，这里是利用批量的一个思想做的一个优化。我们再理解下最本质的东西，触发了写屏障之后，我们的核心目的是为了能够把赋值的前后两个值记录下来，以便 GC 垃圾回收器能得到通知，从而避免错误的回收。记录下来是最本质的，但是并不是要立马处理，所以这里做的优化就是，攒满一个 buffer ，然后批量处理，这样效率会非常高的。</p><p>wbBuf 结构如下： |————————————-| | 8 | 8 | 8 * 512 | 4 | |————————————-|</p><p>每个 P 都有这么个 wbBuf 队列。</p><p>我们看到 <code>CALL runtime·wbBufFlush(SB)</code> ，这个函数 wbBufFlush 是 golang 实现的，本质上是调用 <code>wbBufFlush1</code> 。这个函数才是 hook 写操作想要做的事情，精简了下代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">wbBufFlush1</span>(_p_ *p) &#123;<br>        start := <span class="hljs-built_in">uintptr</span>(unsafe<span class="hljs-selector-class">.Pointer</span>(&amp;_p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.buf</span><span class="hljs-selector-attr">[0]</span>))<br>        n := (_p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.next</span> - start) / unsafe<span class="hljs-selector-class">.Sizeof</span>(_p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.buf</span><span class="hljs-selector-attr">[0]</span>)<br>        ptrs := _p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.buf</span><span class="hljs-selector-attr">[:n]</span><br><br>        _p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.next</span> = <span class="hljs-number">0</span><br><br>        gcw := &amp;_p_<span class="hljs-selector-class">.gcw</span><br>        pos := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 循环批量处理队列里的值，这个就是之前在 gcWriteBarrier 赋值的</span><br>        <span class="hljs-keyword">for</span> _, ptr := range ptrs &#123;<br>                <span class="hljs-keyword">if</span> ptr &lt; minLegalPointer &#123;<br>                        continue<br>                &#125;<br>                obj, <span class="hljs-selector-tag">span</span>, objIndex := <span class="hljs-built_in">findObject</span>(ptr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> obj == <span class="hljs-number">0</span> &#123;<br>                        continue<br>                &#125;<br><br>                mbits := <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.markBitsForIndex</span>(objIndex)<br>                <span class="hljs-keyword">if</span> mbits<span class="hljs-selector-class">.isMarked</span>() &#123;<br>                        continue<br>                &#125;<br>                mbits<span class="hljs-selector-class">.setMarked</span>()<br>                <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.spanclass</span><span class="hljs-selector-class">.noscan</span>() &#123;<br>                        gcw<span class="hljs-selector-class">.bytesMarked</span> += <span class="hljs-built_in">uint64</span>(<span class="hljs-selector-tag">span</span>.elemsize)<br>                        continue<br>                &#125;<br>                ptrs<span class="hljs-selector-attr">[pos]</span> = obj<br>                pos++<br>        &#125;<br><br>        <span class="hljs-comment">// 置灰色（投入灰色的队列），这就是我们的目的，对象在这里面我们就不怕了，我们要扫描的就是这个队列；</span><br>        gcw<span class="hljs-selector-class">.putBatch</span>(ptrs<span class="hljs-selector-attr">[:pos]</span>)<br><br>        _p_<span class="hljs-selector-class">.wbBuf</span><span class="hljs-selector-class">.reset</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们总结下，写屏障到底做了什么：</p><ol><li>hook 写操作</li><li>hook 住了写操作之后，把赋值语句的前后两个值都记录下来，投入 buffer 队列</li><li>buffer 攒满之后，批量刷到扫描队列（置灰）（这是 GO 1.10 左右引入的优化）</li></ol><p><strong><code>main.funcAlloc1</code></strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">17 </span>func funcAlloc1 (b *Tstruct) &#123;<br><span class="hljs-symbol">18 </span>    var b0 Tstruct<br><span class="hljs-symbol">19 </span>    b0.<span class="hljs-keyword">base</span> = <span class="hljs-keyword">new</span>(BaseStruct)  // <span class="hljs-keyword">new</span> 一个BaseStruct结构体，赋值给 b0.<span class="hljs-keyword">base</span> 字段<br><span class="hljs-symbol">20 </span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/liqingqiya/liqingqiya.github.io/images/posts/2020-07-11-gc2/FB0B964D-0A0F-4650-8700-45C4278E704E.png"></p><p>最后，再回顾看下 <code>main.funcAlloc1</code> 函数，这个函数是只有栈操作，非常简单。</p><h4 id="“强-弱”-三色不变式"><a href="#“强-弱”-三色不变式" class="headerlink" title="“强-弱” 三色不变式"></a>“强-弱” 三色不变式</h4><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是<strong>“强三色不变式”和“ 弱三色不变式”</strong>。</p><ul><li>强三色不变式</li></ul><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>弱三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><ul><li>弱三色不变式</li></ul><p>所有被黑色对象引用的白色对象都处于灰色保护状态（允许黑色对象指向白色对象，但必须保证一个前提，这个白色对象必须处于灰色对象的保护下）。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们<strong>“插入写屏障”, “删除写屏障”</strong>。</p><p><strong>插入写屏障：</strong></p><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p><strong>删除写屏障：</strong></p><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p><h3 id="（一）插入写屏障"><a href="#（一）插入写屏障" class="headerlink" title="（一）插入写屏障"></a><strong>（一）插入写屏障</strong></h3><p>Dijkstra在1978年提出了插入写屏障，也被叫做增量更新，通过如下所示的写屏障，破坏上述第一个条件（赋值器插入了一条或多条从黑色对象到白色对象的新引用）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) <br>     shade(ptr)  <span class="hljs-regexp">//</span>先将新下游对象 ptr 标记为灰色<br>     *slot = ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>说明：<br>添加下游对象(当前下游对象slot, 新下游对象ptr) &#123; <br> <span class="hljs-regexp">//</span>step <span class="hljs-number">1</span><br> 标记灰色(新下游对象ptr) <br> <br> <span class="hljs-regexp">//</span>step <span class="hljs-number">2</span><br> 当前下游对象slot = 新下游对象ptr <br>&#125;<br><br><span class="hljs-regexp">//</span>场景：<br>A.添加下游对象(nil, B) <span class="hljs-regexp">//</span>A 之前没有下游， 新添加一个下游对象B， B被标记为灰色<br>A.添加下游对象(C, B) <span class="hljs-regexp">//</span>A 将下游对象C 更换为B， B被标记为灰色<br></code></pre></td></tr></table></figure><p>上述伪代码非常好理解，当黑色对象（slot）插入新的指向白色对象（ptr）的引用关系时，就尝试使用shade函数将这个新插入的引用（ptr）标记为灰色。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpj99S1E3KkyG9kbgAWz9mcJeJthjrVDZZ47DHBs3IgiaicSxjVvhlKUsw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>假设我们上图的例子并发可达性分析中使用插入写屏障：</p><p>1.GC 将根对象Root2指向的B对象标记成黑色并将B对象指向的对象D标记成灰色；</p><p>2.用户程序修改指针，<strong>B.next&#x3D;H</strong>这时触发写屏障将H对象标记成灰色；</p><p>3.用户程序修改指针<strong>D.next&#x3D;null</strong>；</p><p>4.GC依次遍历程序中的H和D将它们分别标记成黑色。</p><h3 id="关于栈没有写屏障的原因"><a href="#关于栈没有写屏障的原因" class="headerlink" title="关于栈没有写屏障的原因"></a>关于栈没有写屏障的原因</h3><p> 黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是<strong>容量小</strong>,但是<strong>要求响应速度快,因为函数调用弹出频繁使用</strong>, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p><p><strong>由于栈上的对象在垃圾回收中被认为是根对象，并没有写屏障，那么导致黑色的栈可能指向白色的堆对象。为了保障内存安全，Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之前做出权衡。</strong></p><p>​接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>​但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><p>​最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h3 id="（二）删除写屏障"><a href="#（二）删除写屏障" class="headerlink" title="（二）删除写屏障"></a><strong>（二）删除写屏障</strong></h3><p>Yuasa在1990年的论文Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达。起始时STW扫描所有的goroutine栈，保证所有堆上在用的对象都处于灰色保护下，所以也被称作<strong>快照垃圾收集或者原始快照</strong>（Snapshot GC），这是破坏了“对象消失”的第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用）</p><p>原始快照(Snapshot At The Beginning，SATB)。当某个时刻 的 GC Roots 确定后，当时的对象图就已经确定了。当赋值器（业务线程）从灰色或者白色对象中删除白色指针时候，写屏障会捕捉这一行为，将这一行为通知给回收器。这样，基于起始快照的解决方案保守地将其目标对象当作存活的对象，这样就绝对不会有被误回收的对象，但是有扫描工作量浮动放大的风险。术语叫做追踪波面的回退。这个操作在「修改操作前」进行，JVM中 的 G1 垃圾回收器用的也是这个思路。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 黑色赋值器 Yuasa 屏障<br><span class="hljs-keyword">func</span> YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) &#123;<br>    shade(*slot) 先将*slot标记为灰色<br>    *slot = ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>说明：<br>添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;<br>  <span class="hljs-regexp">//</span>step <span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;<br>          标记灰色(当前下游对象slot)     <span class="hljs-regexp">//</span>slot为被删除对象， 标记为灰色<br>  &#125;  <br>  <span class="hljs-regexp">//</span>step <span class="hljs-number">2</span><br>  当前下游对象slot = 新下游对象ptr<br>&#125;<br><br><span class="hljs-regexp">//</span>场景<br>A.添加下游对象(B, nil)   <span class="hljs-regexp">//</span>A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)<br>A.添加下游对象(B, C)     <span class="hljs-regexp">//</span>A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)<br></code></pre></td></tr></table></figure><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p>但是这样也会导致一个问题，由于会将<strong>有存活可能的对象都标记成灰色</strong>，因此最后可能会导致应该回收的对象未被回收，这个对象只有在下一个循环才会被回收，比如下图的D对象。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpTuHVXfE7fSIbu8yNpJt877FyhAQuBB96eYr2wH7QcxKBIVxNrssIyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>由于原始快照的原因，起始也是执行STW，删除写屏障不适用于栈特别大的场景，栈越大，STW扫描时间越长。</strong></p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_1.png" alt="delete_barrier_1"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_2.png" alt="delete_barrier_2"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_3.png" alt="delete_barrier_3"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_4.png" alt="delete_barrier_4"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_5.png" alt="delete_barrier_5"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_6.png" alt="delete_barrier_6"></p><p><img src="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/delete_barrier_7.png" alt="delete_barrier_7"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><p><img src="C:\Users\longp\AppData\Roaming\Typora\typora-user-images\image-20220821132611515.png" alt="image-20220821132611515"></p><p><strong>插入写屏障和删除写屏障的短板：</strong></p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li></ul><h3 id="（三）混合写屏障"><a href="#（三）混合写屏障" class="headerlink" title="（三）混合写屏障"></a><strong>（三）混合写屏障</strong></h3><p>在 Go 语言 v1.7版本之前，运行时会使用Dijkstra插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个Goroutine的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在v1.8结合上述2种写屏障构成了混合写屏障，实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描。</p><p>Go 语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">writePointer</span><span class="hljs-params">(slot, ptr)</span></span>:<br>    <span class="hljs-built_in">shade</span>(*slot)<br>    <span class="hljs-keyword">if</span> current stack is grey:<br>        <span class="hljs-built_in">shade</span>(ptr)<br>    *slot = ptr<br></code></pre></td></tr></table></figure><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。总结来说主要有这几点：</p><ul><li><p>GC开始将栈上的对象全部扫描并标记为黑色；</p></li><li><p>GC期间，任何在栈上创建的新对象，均为黑色；</p></li><li><p>被删除的堆对象标记为灰色；</p></li><li><p>被添加的堆对象标记为灰色。</p></li></ul><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><p>最本质的区别就是：<strong>内存屏障其实就是编译器帮你生成的一段 hook 代码</strong>，这三个屏障的本质区别就是 hook 的时机不同而已。</p><hr><h4 id="1-混合写屏障规则"><a href="#1-混合写屏障规则" class="headerlink" title="(1) 混合写屏障规则"></a>(1) 混合写屏障规则</h4><p><code>具体操作</code>:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p><code>满足</code>: 变形的<strong>弱三色不变式</strong>.</p><p>伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;<br>  <span class="hljs-comment">//1 </span><br>标记灰色(当前下游对象slot)    <span class="hljs-comment">//只要当前下游对象被移走，就标记灰色</span><br>  <br>  <span class="hljs-comment">//2 </span><br>  标记灰色(新下游对象ptr)<br>  <br>  <span class="hljs-comment">//3</span><br>  当前下游对象slot = 新下游对象ptr<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><h4 id="2-混合写屏障的具体场景分析"><a href="#2-混合写屏障的具体场景分析" class="headerlink" title="(2) 混合写屏障的具体场景分析"></a>(2) 混合写屏障的具体场景分析</h4><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><h5 id="GC开始：扫描栈区，将可达对象全部标记为黑"><a href="#GC开始：扫描栈区，将可达对象全部标记为黑" class="headerlink" title="GC开始：扫描栈区，将可达对象全部标记为黑"></a>GC开始：扫描栈区，将可达对象全部标记为黑</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><hr><h5 id="场景一：-对象被一个堆对象删除引用，成为栈对象的下游"><a href="#场景一：-对象被一个堆对象删除引用，成为栈对象的下游" class="headerlink" title="场景一： 对象被一个堆对象删除引用，成为栈对象的下游"></a>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span><br>栈对象<span class="hljs-number">1</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；  <span class="hljs-comment">//将堆对象7 挂在 栈对象1 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；    <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景二：-对象被一个栈对象删除引用，成为另一个栈对象的下游"><a href="#场景二：-对象被一个栈对象删除引用，成为另一个栈对象的下游" class="headerlink" title="场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游"></a>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span> 栈对象<span class="hljs-number">9</span>；<br>对象<span class="hljs-number">8</span>-&gt;对象<span class="hljs-number">3</span> = 对象<span class="hljs-number">3</span>；      <span class="hljs-comment">//将栈对象3 挂在 栈对象9 下游</span><br>对象<span class="hljs-number">2</span>-&gt;对象<span class="hljs-number">3</span> = null；      <span class="hljs-comment">//对象2 删除引用 对象3</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"><a href="#场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"></a>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h5 id="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"><a href="#场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"></a>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h5><p>伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">堆对象<span class="hljs-number">10</span>-&gt;对象<span class="hljs-number">7</span> = 堆对象<span class="hljs-number">7</span>；       <span class="hljs-comment">//将堆对象7 挂在 堆对象10 下游</span><br>堆对象<span class="hljs-number">4</span>-&gt;对象<span class="hljs-number">7</span> = null；         <span class="hljs-comment">//对象4 删除引用 对象7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p>​Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="五、GC演进过程"><a href="#五、GC演进过程" class="headerlink" title="五、GC演进过程"></a><strong>五、GC演进过程</strong></h2><p>v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；</p><p>v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段；</p><p>v1.3 — 运行时<strong>基于只有指针类型的值包含指针</strong>的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集；将unsafe.Pointer类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；</p><p>v1.5 — 实现了基于<strong>三色标记清扫的并发</strong>垃圾收集器（插入写屏障）：</p><ul><li>大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下；</li><li>计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；</li></ul><p>v1.6 — 实现了去中心化的垃圾收集协调器：</p><ul><li>基于显式的状态机使得任意Goroutine都能触发垃圾收集的状态迁移；</li><li>使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的CPU占用;</li></ul><p>v1.7 — 通过<strong>并行栈收缩</strong>将垃圾收集的时间缩短至2ms以内；</p><p>v1.8 — 使用<strong>混合写屏障</strong>将垃圾收集的时间缩短至0.5ms以内；</p><p>v1.9 — 彻底移除暂停程序的重新扫描栈的过程；</p><p>v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标；</p><p>v1.12 — 使用<strong>新的标记终止算法</strong>简化垃圾收集器的几个阶段；</p><p>v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题；</p><p>v1.14 — 使用全新的页分配器<strong>优化内存分配的速度</strong>；</p><p>v1.15 — 改进编译器和运行时内部的CL 226367，它使编译器可以将更多的x86寄存器用于垃圾收集器的写屏障调用；</p><p>v1.16 — Go runtime默认使用MADV_DONTNEED更积极的将不用的内存释放给OS。</p><h2 id="六、GC过程"><a href="#六、GC过程" class="headerlink" title="六、GC过程"></a><strong>六、GC过程</strong></h2><p>Golang GC 相关的代码在<strong>runtime&#x2F;mgc.go</strong>文件下，可以看见GC总共分为4个阶段(翻译自Golang v1.16版本源码)：</p><p><strong>1.sweep termination（清理终止）</strong></p><ul><li><p>暂停程序，触发STW。所有的P（处理器）都会进入safe-point（安全点）；</p></li><li><p>清理未被清理的 span 。如果当前垃圾收集是强制触发的，需要处理还未被清理的内存管理单元；</p></li></ul><p><strong>2.the mark phase（标记阶段）</strong></p><ul><li>将<strong>GC状态gcphase从_GCoff改成_GCmark</strong>、开启写屏障、启用协助线程（mutator assists）、将根对象入队；</li><li>恢复程序执行，标记进程（mark workers）和协助程序会开始并发标记内存中的对象，写屏障会覆盖的重写指针和新指针（标记成灰色），而所有新创建的对象都会被直接标记成黑色；</li><li>GC执行根节点的标记，这包括扫描所有的栈、全局对象以及不在堆中的运行时数据结构。扫描goroutine栈会导致goroutine停止，并对栈上找到的所有指针加置灰，然后继续执行goroutine；</li><li>GC遍历灰色对象队列，会将灰色对象变成黑色，并将该指针指向的对象置灰；</li><li>由于GC工作分布在本地缓存中，GC会使用分布式终止算法（distributed termination algorithm）来检测何时不再有根标记作业或灰色对象，如果没有了GC会转为mark termination（标记终止）。</li></ul><p><strong>3. mark termination（标记终止）</strong></p><ul><li>STW；</li><li>将GC状态gcphase切换至_GCmarktermination，关闭gc工作线程和协助程序；</li><li>执行housekeeping，例如刷新mcaches。</li></ul><p><strong>4. the sweep phase（清理阶段）</strong></p><ul><li>将GC状态gcphase切换至_GCoff来准备清理阶段，初始化清理阶段并关闭写屏障；</li><li>恢复用户程序，从现在开始，所有新创建的对象会标记成白色；如果有必要，在使用前分配清理spans；</li><li>后台并发清理所有的内存管理类单元。</li></ul><p><strong>GC过程代码示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcfinished</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>  p := <span class="hljs-number">1</span><br>  runtime.SetFinalizer(&amp;p, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;gc finished&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> &amp;p<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span></span> &#123;<br>  _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-type">int</span>((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)*<span class="hljs-number">0.25</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  f, _ := os.Create(<span class="hljs-string">&quot;trace.out&quot;</span>)<br>  <span class="hljs-keyword">defer</span> f.Close()<br>  trace.Start(f)<br>  <span class="hljs-keyword">defer</span> trace.Stop()<br>  gcfinished()<br>  <span class="hljs-comment">// 当完成 GC 时停止分配</span><br>  <span class="hljs-keyword">for</span> n := <span class="hljs-number">1</span>; n &lt; <span class="hljs-number">50</span>; n++ &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;#allocate: &quot;</span>, n)<br>    allocate()<br>  &#125;<br>  <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;terminate&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">hewittwang@HEWITTWANG-MB0 rtx % <span class="hljs-attr">GODEBUG=</span><span class="hljs-attr">gctrace=</span><span class="hljs-number">1</span> go run new1.go  <br>gc <span class="hljs-number">1</span> @<span class="hljs-number">0.015s</span> <span class="hljs-number">0</span>%: <span class="hljs-number">0.015</span>+<span class="hljs-number">0.36</span>+<span class="hljs-number">0.043</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span>, <span class="hljs-number">0.18</span>+<span class="hljs-number">0.55</span>/<span class="hljs-number">0.64</span>/<span class="hljs-number">0.13</span>+<span class="hljs-number">0.52</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span>, <span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB, <span class="hljs-number">5</span> MB goal, <span class="hljs-number">12</span> P<br>gc <span class="hljs-number">2</span> @<span class="hljs-number">0.024s</span> <span class="hljs-number">1</span>%: <span class="hljs-number">0.045</span>+<span class="hljs-number">0.19</span>+<span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span>, <span class="hljs-number">0.54</span>+<span class="hljs-number">0.37</span>/<span class="hljs-number">0.31</span>/<span class="hljs-number">0.041</span>+<span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span>, <span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB, <span class="hljs-number">5</span> MB goal, <span class="hljs-number">12</span> P<br>....<br></code></pre></td></tr></table></figure><p>栈分析</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">gc <span class="hljs-number">2</span>      : 第一个GC周期<br>@<span class="hljs-number">0.024s</span>   : 从程序开始运行到第一次GC时间为<span class="hljs-number">0.024</span> 秒<br><span class="hljs-number">1</span>%        : 此次GC过程中CPU 占用率<br><br>wall clock<br><span class="hljs-number">0.045</span>+<span class="hljs-number">0.19</span>+<span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">clock</span><br><span class="hljs-number">0.045</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: STW</span>，Marking <span class="hljs-literal">Start</span>, 开启写屏障<br><span class="hljs-number">0.19</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: Marking</span>阶段<br><span class="hljs-number">0.018</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: STW</span>，Marking终止，关闭写屏障<br><br>CPU time<br><span class="hljs-number">0.54</span>+<span class="hljs-number">0.37</span>/<span class="hljs-number">0.31</span>/<span class="hljs-number">0.041</span>+<span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">cpu</span><br><span class="hljs-number">0.54</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: STW</span>，Marking <span class="hljs-literal">Start</span><br><span class="hljs-number">0.37</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: 辅助标记时间</span><br><span class="hljs-title">0</span>.<span class="hljs-number">31</span> <span class="hljs-keyword">ms</span>  <span class="hljs-title">: 并发标记时间</span><br><span class="hljs-title">0</span>.<span class="hljs-number">041</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: GC</span> 空闲时间<br><span class="hljs-number">0.22</span> <span class="hljs-keyword">ms</span>   <span class="hljs-title">: Mark</span> 终止时间<br><br><span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> MB， <span class="hljs-number">5</span> MB goal<br><span class="hljs-number">4</span> MB      ：标记开始时，堆大小实际值<br><span class="hljs-number">4</span> MB      ：标记结束时，堆大小实际值<br><span class="hljs-number">0</span> MB      ：标记结束时，标记为存活对象大小<br><span class="hljs-number">5</span> MB      ：标记结束时，堆大小预测值<br><br><span class="hljs-number">12</span> P      ：本次GC过程中使用的goroutine 数量<br></code></pre></td></tr></table></figure><h2 id="七、GC触发条件"><a href="#七、GC触发条件" class="headerlink" title="七、GC触发条件"></a><strong>七、GC触发条件</strong></h2><p>运行时会通过runtime.gcTrigger.test方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件（即满足_GCoff阶段的退出条件）时——允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//mgc.go 文件 runtime.gcTrigger.test</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t gcTrigger)</span></span> test() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">//测试是否满足触发垃圾手机的基本条件</span><br>    <span class="hljs-keyword">if</span> !memstats.enablegc || panicking != <span class="hljs-number">0</span> || gcphase != _GCoff &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">switch</span> t.kind &#123;<br>      <span class="hljs-keyword">case</span> gcTriggerHeap:    <span class="hljs-comment">//堆内存的分配达到达控制器计算的触发堆大小</span><br>         <span class="hljs-comment">// Non-atomic access to gcController.heapLive for performance. If</span><br>         <span class="hljs-comment">// we are going to trigger on this, this thread just</span><br>         <span class="hljs-comment">// atomically wrote gcController.heapLive anyway and we&#x27;ll see our</span><br>         <span class="hljs-comment">// own write.</span><br>         <span class="hljs-keyword">return</span> gcController.heapLive &gt;= gcController.trigger<br>      <span class="hljs-keyword">case</span> gcTriggerTime:      <span class="hljs-comment">//如果一定时间内没有触发，就会触发新的循环，该出发条件由 `runtime.forcegcperiod`变量控制，默认为 2 分钟；</span><br>         <span class="hljs-keyword">if</span> gcController.gcPercent &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>         lastgc := <span class="hljs-type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))<br>         <span class="hljs-keyword">return</span> lastgc != <span class="hljs-number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod<br>      <span class="hljs-keyword">case</span> gcTriggerCycle:      <span class="hljs-comment">//如果当前没有开启垃圾收集，则触发新的循环；</span><br>         <span class="hljs-comment">// t.n &gt; work.cycles, but accounting for wraparound.</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-type">int32</span>(t.n-work.cycles) &gt; <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;<br></code></pre></td></tr></table></figure><p>用于开启垃圾回收的方法为runtime.gcStart，因此所有调用该函数的地方都是触发GC的代码：</p><ul><li>runtime.mallocgc申请内存时根据堆大小触发GC</li><li>runtime.GC用户程序手动触发GC</li><li>runtime.forcegchelper后台运行定时检查触发GC</li></ul><p><strong>（一）申请内存触发runtime.mallocgc</strong></p><p>Go运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的GC。</p><p>1.当前线程的内存管理单元中不存在空闲空间时，创建微对象(noscan &amp;&amp;size&lt;maxTinySize)和小对象需要调用 runtime.mcache.nextFree从中心缓存或者页堆中获取新的管理单元，这时如果span满了就会导致返回的shouldhelpgc&#x3D;true，就可能触发垃圾收集；</p><p>2.当用户程序申请分配32KB以上的大对象时，一定会构建 runtime.gcTrigger结构体尝试触发垃圾收集。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>, typ *_type, needzero <span class="hljs-type">bool</span>)</span></span> unsafe.Pointer &#123;<br>    省略代码 ...<br>    shouldhelpgc := <span class="hljs-literal">false</span>  <br>  dataSize := size<br>  c := getMCache()       <span class="hljs-comment">//尝试获取mCache。如果没启动或者没有P,返回nil；</span><br> <br>    省略代码 ...<br>    <span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;  <br>       <span class="hljs-keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123; <span class="hljs-comment">// 微对象分配</span><br>  省略代码 ...<br>          v := nextFreeFast(span)<br>          <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>             v, span, shouldhelpgc = c.nextFree(tinySpanClass)<br>          &#125;<br>      省略代码 ...<br>      &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//小对象分配</span><br>         省略代码 ...<br>          <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>             v, span, shouldhelpgc = c.nextFree(spc)<br>          &#125;<br>        省略代码 ...<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       shouldhelpgc = <span class="hljs-literal">true</span><br>       省略代码 ...<br>    &#125;<br>  省略代码 ...<br>    <span class="hljs-keyword">if</span> shouldhelpgc &#123;      <span class="hljs-comment">//是否应该触发gc</span><br>      <span class="hljs-keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;   <span class="hljs-comment">//如果满足gc触发条件就调用gcStart()</span><br>          gcStart(t)<br>      &#125;<br>    &#125;<br>  省略代码 ...<br>    <span class="hljs-keyword">return</span> x<br> &#125;<br></code></pre></td></tr></table></figure><p>这个时候调用t.test()执行的是gcTriggerHeap情况，只需要判断gcController.heapLive &gt;&#x3D; gcController.trigger的真假就可以了。 heapLive表示垃圾收集中存活对象字节数，trigger表示触发标记的堆内存大小的；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。</p><p>1.heapLive — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；</p><p>2.trigger — 在标记终止阶段调用runtime.gcSetTriggerRatio更新触发下一次垃圾收集的堆大小，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集CPU利用率确定触发垃圾收集的时机。</p><p><strong>（二）手动触发runtime.GC</strong></p><p>用户程序会通过runtime.GC函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过STW暂停整个程序：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> GC() &#123;<br>    <span class="hljs-regexp">//</span>在正式开始垃圾收集前，运行时需要通过runtime.gcWaitOnMark等待上一个循环的标记终止、标记和清除终止阶段完成；<br>    n := atomic.Load(&amp;work.cycles)<br>    gcWaitOnMark(n)<br> <br>  <span class="hljs-regexp">//</span>调用 `runtime.gcStart` 触发新一轮的垃圾收集<br>    gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="hljs-number">1</span>&#125;)<br> <br>    <span class="hljs-regexp">//</span>`runtime.gcWaitOnMark` 等待该轮垃圾收集的标记终止阶段正常结束；<br>    gcWaitOnMark(n + <span class="hljs-number">1</span>)<br> <br>    <span class="hljs-regexp">//</span> 持续调用 `runtime.sweepone` 清理全部待处理的内存管理单元并等待所有的清理工作完成<br>    <span class="hljs-keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="hljs-number">1</span> &amp;&amp; sweepone() != ^uintptr(<span class="hljs-number">0</span>) &#123;<br>        sweep.nbgsweep++<br>        Gosched()  <span class="hljs-regexp">//</span>等待期间会调用 `runtime.Gosched` 让出处理器<br>    &#125;<br> <br>    <span class="hljs-regexp">//</span><br>    <span class="hljs-keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="hljs-number">1</span> &amp;&amp; !isSweepDone() &#123;<br>        Gosched()<br>    &#125;<br> <br>    <span class="hljs-regexp">//</span> 完成本轮垃圾收集的清理工作后，通过 `runtime.mProf_PostSweep` 将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态<br>    mp := acquirem()<br>    cycle := atomic.Load(&amp;work.cycles)<br>    <span class="hljs-keyword">if</span> cycle == n+<span class="hljs-number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="hljs-number">2</span>) &#123;   <span class="hljs-regexp">//</span>仅限于没有启动其他标记终止过程<br>        mProf_PostSweep()<br>    &#125;<br>    releasem(mp)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（三）后台运行定时检查触发runtime.forcegchelper</strong></p><p>运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的Goroutine，该Goroutine调用runtime.gcStart尝试启动新一轮的垃圾收集：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// start forcegc helper goroutine</span><br>func <span class="hljs-built_in">init</span>() &#123;<br>   go <span class="hljs-built_in">forcegchelper</span>()<br>&#125;<br> <br>func <span class="hljs-built_in">forcegchelper</span>() &#123;<br>   forcegc<span class="hljs-selector-class">.g</span> = <span class="hljs-built_in">getg</span>()<br>   <span class="hljs-built_in">lockInit</span>(&amp;forcegc<span class="hljs-selector-class">.lock</span>, lockRankForcegc)<br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-built_in">lock</span>(&amp;forcegc.lock)<br>      <span class="hljs-keyword">if</span> forcegc<span class="hljs-selector-class">.idle</span> != <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-built_in">throw</span>(<span class="hljs-string">&quot;forcegc: phase error&quot;</span>)<br>      &#125;<br>      atomic<span class="hljs-selector-class">.Store</span>(&amp;forcegc<span class="hljs-selector-class">.idle</span>, <span class="hljs-number">1</span>)<br>      <br>     <span class="hljs-comment">//该 Goroutine 会在循环中调用runtime.goparkunlock主动陷入休眠等待其他 Goroutine 的唤醒</span><br>      <span class="hljs-built_in">goparkunlock</span>(&amp;forcegc<span class="hljs-selector-class">.lock</span>, waitReasonForceGCIdle, traceEvGoBlock, <span class="hljs-number">1</span>)<br>       <br>      <span class="hljs-keyword">if</span> debug<span class="hljs-selector-class">.gctrace</span> &gt; <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;GC forced&quot;</span>)<br>      &#125;<br>      <span class="hljs-comment">// Time-triggered, fully concurrent.</span><br>      <span class="hljs-built_in">gcStart</span>(gcTrigger&#123;kind: gcTriggerTime, n<br>      ow: <span class="hljs-built_in">nanotime</span>()&#125;)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、问题思考"><a href="#八、问题思考" class="headerlink" title="八、问题思考"></a>八、问题思考</h2><p>1.为什么删除写屏障的时候要原始快照？</p><p>2.删除写屏障出现已扫描黑色对象新增白色对象的怎么处理？</p><p>3.关于内存管理，gc整体流程，go如何将代码转化为二进制？</p><p><strong>参考文献</strong></p><p>  1.《Go语言设计与实现》</p><p>(<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</a>)</p><p>  2.《一个专家眼中的Go与Java垃圾回收算法大对比》</p><p>(<a href="https://blog.csdn.net/u011277123/article/details/53991572">https://blog.csdn.net/u011277123/article/details/53991572</a>)</p><p>  3.《Go语言问题集》</p><p>(<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.19.GC-GC.md">https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.19.GC-GC.md</a>)</p><p>   4.《CMS垃圾收集器》</p><p>(<a href="https://juejin.cn/post/6844903782107578382">https://juejin.cn/post/6844903782107578382</a>)</p><p>  5.《Golang v 1.16版本源码》</p><p>(<a href="https://github.com/golang/go">https://github.com/golang/go</a>)</p><p>  6.《Golang—内存管理(内存分配)》</p><p>(<a href="http://t.zoukankan.com/zpcoding-p-13259943.html">http://t.zoukankan.com/zpcoding-p-13259943.html</a>)</p><p>  7.《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》—机械工业出版社</p><p>  8.《腾讯妹子图解Golang内存分配和垃圾回收》](<a href="https://mp.weixin.qq.com/s/iAy9ReQhnmCYUFvwYroGPA">https://mp.weixin.qq.com/s/iAy9ReQhnmCYUFvwYroGPA</a>)</p><p>  9.<a href="https://www.yuque.com/aceld/golang/zhzanb">《Golang修养之路》</a></p><ol start="10"><li><p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/</a></p></li><li><p><a href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/02/gc2.html">https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/02/gc2.html</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 网络基础</title>
    <link href="/2022/08/27/Kubernetes-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/08/27/Kubernetes-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-网络模型基础"><a href="#Kubernetes-网络模型基础" class="headerlink" title="Kubernetes 网络模型基础"></a>Kubernetes 网络模型基础</h1><p>github对应地址：<a href="https://github.com/longpi1/Reading-notes/blob/main/kuberneters/%E7%BD%91%E7%BB%9C/Kubernetes%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.md">https://github.com/longpi1/Reading-notes/blob/main/kuberneters/%E7%BD%91%E7%BB%9C/Kubernetes%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.md</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。</p><p><img src="https://s2.loli.net/2022/08/27/OlUZo4yNiTAPgmC.png" alt="网络模型.png"></p><p>网络是非常复杂的，拥有许多概念，对于不熟悉这个领域的用户来说，这可能会有一定的难度，这里面有很多概念需要理解，并且还需要把这些概念整合起来形成一个连贯的整体，比如网络命名空间、虚拟接口、IP 转发、NAT 等概念。</p><p>Kubernetes 中对任何网络实现都规定了以下的一些要求：</p><ul><li>所有 Pod 都可以在不使用 NAT 的情况下与所有其他 Pod 进行通信</li><li>所有节点都可以在没有 NAT 的情况下与所有 Pod 进行通信</li><li>Pod 自己的 IP 与其他 Pod 看到的 IP 是相同的</li></ul><p>鉴于这些限制，我们需要解决几个不同的网络问题：</p><ol><li>容器到容器的网络</li><li>Pod 到 Pod 的网络</li><li>Pod 到 Service 的网络</li><li>互联网到 Service 的网络</li></ol><p>接下来我们将来讨论这些问题及其解决方案。</p><h2 id="容器到容器网络"><a href="#容器到容器网络" class="headerlink" title="容器到容器网络"></a>容器到容器网络</h2><p>通常情况下我们将虚拟机中的网络通信视为直接与以太网设备进行交互，如图1所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgCV9T9zxQ7pfMHEiauW3V6z9TiaUIrm4TfdVibb5hNJMJO7OticAOK1v6Ng/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                <strong>图1.网络设备的理想视图</strong></p><p>实际的情况肯定比这要复杂，在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间提供了一个具有自己的路由、防火墙规则和网络设备的逻辑网络栈，从本质上讲，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。</p><p>Linux 用户可以使用 <code>ip</code> 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的网络命名空间。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$<span class="hljs-built_in"> ip </span>netns <span class="hljs-built_in">add</span> ns1 <br></code></pre></td></tr></table></figure><p>命名空间创建后，会在 <code>/var/run/netns</code> 下面为其创建一个挂载点，即使没有附加任何进程，命名空间也是可以保留的。</p><p>你可以通过列出 <code>/var/run/netns</code> 下的所有挂载点或使用 <code>ip</code> 命令来列出可用的命名空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/run/netns</span><br>ns1<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns</span><br>ns1<br></code></pre></td></tr></table></figure><p>默认情况下，Linux 将为每个进程分配到 root network namespace，以提供访问外部的能力，如图2所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgoTjJmceqShbEoZ6ibwMOA1VZOV2yYQmN6z9BovoSiafExusQt9dpyu0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                <strong>图2.root network namespace</strong></p><p>对于 Docker 而言，一个 Pod 会被构建成一组共享网络命名空间的 Docker 容器，Pod 中的容器都有相同的 IP 地址和端口空间，它们都是通过分配给 Pod 的网络命名空间来分配的，并且可以通过 localhost 访问彼此，因为它们位于同一个命名空间中。这是使用 Docker 作为 Pod 容器来实现的，它持有网络命名空间，而应用容器则通过 Docker 的 <code>-net=container:sandbox-container</code> 功能加入到该命名空间中，图3显示了每个 Pod 如何由共享网络命名空间内的多个 Docker 容器（<code>ctr*</code>）组成的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgx14N89bgPKjXwqTDV2ia9FbbLyLP2fGEvBrMUT5U4ibvq87nySmZ1xTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                               <strong>图3.每个 Pod 的网络命名空间</strong></p><p>此外 Pod 中的容器还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个容器的文件系统中。</p><h2 id="Pod-到-Pod-网络"><a href="#Pod-到-Pod-网络" class="headerlink" title="Pod 到 Pod 网络"></a>Pod 到 Pod 网络</h2><p>在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，每个 Pod 都使用该 IP 地址与其他 Pod 进行通信。接下来我们将来了解 Kubernetes 如何使用真实的 IP 来实现 Pod 与 Pod 之间的通信的。我们先来讨论同一节点上的 Pod 通信的方式。</p><p>从 Pod 的角度来看，它存在于自己的网络命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的时候，命名空间可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 <code>veth</code> 对进行连接，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的的一侧分配给 root network namespace，将另一侧分配给 Pod 的网络命名空间。每个 veth 对就像一根网线，连接两侧并允许流量在它们之间流动。这种设置可以复制到节点上的任意数量的 Pod。图4显示了连接虚拟机上每个 Pod 的 root network namespace 的 veth 对。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgiav7goAhdM2Fg40BpBNia6OmnP1yZJ0O2aD9ajK98r46EfkGxIfMYJzQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                  <strong>图4.Pod 的 veth 对</strong></p><p>现在 Pod 都有自己的网络命名空间，这样它们就有自己的网络设备和 IP 地址，并且它们连接到节点的 root 命名空间，现在我们希望 Pod 能够通过 root 命名空间进行通信，那么我们将要使用一个网络 <em>bridge（网桥）</em>来实现。</p><p>Linux bridge 是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC 地址学习等。因此我们可以把 veth pair 等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。bridge 的工作方式是通过检查通过它的数据包目的地，并决定是否将数据包传递给连接到网桥的其他网段，从而在源和目的地之间维护一个转发表。bridge 通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。</p><p>Bridges 实现了 ARP 协议来发现与指定 IP 地址关联的链路层 MAC 地址。当 bridge 接收到数据帧的时候，bridge 将该帧广播给所有连接的设备（原始发送者除外），响应该帧的设备被存储在一个查找表中，未来具有相同 IP 地址的通信使用查找表来发现正确的 MAC 地址来转发数据包。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgaC5x2L2NGESEDibAC2J9Y4cSics1zvr3vlQEubR88po8icKdIZnzVDGag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                          <strong>图5.使用桥接连接命名空间</strong></p><h3 id="同节点-Pod-通信"><a href="#同节点-Pod-通信" class="headerlink" title="同节点 Pod 通信"></a>同节点 Pod 通信</h3><p>网络命名空间将每个 Pod 隔离到自己的网络堆栈中，虚拟以太网设备将每个命名空间连接到根命名空间，以及一个将命名空间连接在一起的网桥，这样我们就准备好在同一节点上的 Pod 之间发送流量了，如下图6所示。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgbMZZruJE0xAuacLiaia0y3HtN4ic5QJWsCEEpHgfoWsQMboak31eaeXOg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                   <strong>图6.同节点上的Pod间的数据包移动</strong></p><p>这上图中，pod1 向自己的网络设备 <code>eth0</code> 发送了一个数据包，对于 pod1 来说，<code>eth0</code> 通过虚拟网络设备连接到 root netns 的 <code>veth0(1)</code>，网桥 <code>cbr0</code> 被配置为与 <code>veth0</code> 一端相连，一旦数据包到达网桥，网桥就会使用 ARP 协议将数据包发送到 <code>veth1(3)</code>。当数据包到达虚拟设备 <code>veth1</code> 时，它被直接转发到 pod2 的命名空间内的 <code>eth0(4)</code> 设备。这整个过程中，每个 Pod 仅与 <code>localhost</code> 上的 <code>eth0</code> 进行通信，流量就会被路由到正确的 Pod。</p><p>Kubernetes 的网络模型决定了 Pod 必须可以通过其 IP 地址跨节点访问，也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 是可见的，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式是相同的。接下来我们来看看不同节点上的 Pod 之间的流量路由问题。</p><h3 id="跨节点-Pod-通信"><a href="#跨节点-Pod-通信" class="headerlink" title="跨节点 Pod 通信"></a>跨节点 Pod 通信</h3><p>在研究了如何在同一节点上的 Pod 之间路由数据包之后，接下来我们来看下不同节点上的 Pod 之间的通信。Kubernetes 网络模型要求 Pod 的 IP 是可以通过网络访问的，但它并没有规定必须如何来实现。</p><p>通常集群中的每个节点都分配有一个 <code>CIDR</code>，用来指定该节点上运行的 Pod 可用的 IP 地址。一旦以 <code>CIDR</code> 为目的地的流量到达节点，节点就会将流量转发到正确的 Pod。图7展示了两个节点之间的网络通信，假设网络可以将 <code>CIDR</code> 中的流量转发到正确的节点。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgvHLovL3sZSEtEia3tKWIDCS43V6PLN4kxIjdLnMugfW32fl4ZfHmwSg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                   <strong>图7.不同节点上的Pod间通信</strong></p><p>上图一样和图6相同的地方开始请求，但是这次目标 Pod（绿色标注）与源 Pod（蓝色标注）位于不同的节点上。数据包首先通过 pod1 的网络设备发送，该设备与 root netns（1）中的虚拟网络设备配对，最终数据包到达 root netns 的网桥（2）上。</p><p>这个时候网桥上的 ARP 会失败，因为与网桥相连的没有正确的数据包 MAC 地址。一旦失败，网桥会将数据包发送到默认路由上 - root netns 的 <code>eth0</code> 设备，此时就会路由离开节点，进入网络（3）。我们现在假设网络可以根据分配给节点的 <code>CIDR</code> 将数据包路由到正确的节点（4）。数据包进入目标节点的 root netns（VM2 上的 eth0），这那里它通过网桥路由到正确的虚拟设备（5）。最后，路由通过位于 pod4 的命名空间（6）中的虚拟设备 <code>eth0</code> 来完成。一般来说，每个节点都知道如何将数据包传递给其内部运行的 Pod，一旦数据包到达目标节点，数据包的流动方式与同一节点上的 Pod 间通信方式一样。</p><p>我们这里没有介绍如何配置网络来将 Pod IPs 的流量路由到负责这些 IP 的正确节点，这和特定的网络有关系，比如 AWS 就维护了一个 Kubernetes 容器网络插件，该插件允许在 AWS 的 VPC 环境中使用 [容器网络接口（<code>CNI</code>）插件]（<a href="https://github.com/aws/amazon-vpc-cni-k8s%EF%BC%89%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%8A%82%E7%82%B9%E5%88%B0%E8%8A%82%E7%82%B9%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%82">https://github.com/aws/amazon-vpc-cni-k8s）来进行节点到节点的网络通信。</a></p><p>在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内 —— ENI 无需额外操作即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但你可以创建多个 ENI 并将它们部署到 EC2 实例上。Kubernetes 的 AWS CNI 插件会为节点上的每个 Pod 创建一个新的 ENI，因为 VPC 中的 ENI 已经连接到了现有 AWS 基础设施中，这使得每个 Pod 的 IP 地址可以在 VPC 内自然寻址。当 CNI 插件被部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口，并为这些实例分配 IP 地址，从而为每个节点形成了一个 <code>CIDR</code> 块。当部署 Pod 时，有一个小的二进制文件会作为 DaemonSet 部署到 Kubernetes 集群中，从节点本地的 <code>kubelet</code> 进程接收任何添加 Pod 到网络的请求，这个二进制文件会从节点的可用 ENI 池中挑选一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟网络设备和网桥将其分配给 Pod，和在同一节点内容的 Pod 通信一样，有了这个，Pod 的流量就可以跨集群内的节点进行通信了。</p><h2 id="Pod-到-Service"><a href="#Pod-到-Service" class="headerlink" title="Pod 到 Service"></a>Pod 到 Service</h2><p>上面我们已经介绍了如何在 Pod 和它们相关的 IP 地址之间的通信。但是 Pod 的 IP 地址并不是固定不变的，会随着应用的扩缩容、应用崩溃或节点重启而出现或消失，这些都可能导致 Pod IP 地址发生变化，Kubernetes 中可以通过 <em>Service</em> 对象来解决这个问题。</p><p>Kubernetes Service 管理一组 Pod，允许你跟踪一组随时间动态变化的 Pod IP 地址，Service 作为对 Pod 的抽象，为一组 Pod 分配一个虚拟的 VIP 地址，任何发往 Service VIP 的流量都会被路由到与其关联的一组 Pod。这就允许与 Service 相关的 Pod 集可以随时变更 - 客户端只需要知道 Service VIP 即可。</p><p>创建 Service 时候，会创建一个新的虚拟 IP（也称为 clusterIP），这集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与 Service 关联的一组 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内的负载均衡器，将流量分配到 Service 相关联的健康 Pod 上。接下来让我们仔细看看它是如何工作的。</p><h3 id="netfilter-与-iptables"><a href="#netfilter-与-iptables" class="headerlink" title="netfilter 与 iptables"></a>netfilter 与 iptables</h3><p>为了在集群中执行负载均衡，Kubernetes 会依赖于 Linux 内置的网络框架 - <code>netfilter</code>。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作，Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。</p><p><code>iptables</code> 是一个用户空间程序，它提供了一个基于 table 的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器会 watch kube-apiserver 的变更，当对 Service 或 Pod 的变化更新了 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会被自动更新，以便正确地将指向 Service 的流量路由到支持 Pod。iptables 规则会监听发往 Service VIP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的 VIP 更改为所选的 Pod IP。当 Pod 启动或关闭时，iptables 规则集也会更新以反映集群的变化状态。换句话说，iptables 已经在节点上做了负载均衡，以将指向 Service VIP 的流量路由到实际的 Pod 的 IP 上。</p><p>在返回路径上，IP 地址来自目标 Pod，在这种情况下，iptables 再次重写 IP 头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>Kubernetes 新版本已经提供了另外一个用于集群负载均衡的选项：IPVS， IPVS 也是构建在 netfilter 之上的，并作为 Linux 内核的一部分实现了传输层的负载均衡。IPVS 被合并到了 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载均衡器，IPVS 可以将基于 TCP 和 UDP 的服务请求定向到真实服务器，并使真实服务器的服务作为虚拟服务出现在一个 IP 地址上。这使得 IPVS 非常适合 Kubernetes 服务。</p><p>这部署 kube-proxy 时，可以指定使用 iptables 或 IPVS 来实现集群内的负载均衡。IPVS 专为负载均衡而设计，并使用更高效的数据结构（哈希表），与 iptables  相比允许更大的规模。在使用 IPVS 模式的 Service 时，会发生三件事：在 Node 节点上创建一个虚拟 IPVS 接口，将 Service 的 VIP 地址绑定到虚拟 IPVS 接口，并为每个 Service VIP 地址创建 IPVS 服务器。</p><h3 id="Pod-到-Service-通信"><a href="#Pod-到-Service-通信" class="headerlink" title="Pod 到 Service 通信"></a>Pod 到 Service 通信</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgO80nIibbUc6npiblqjuW8RAqlU6MhtBDUSRCwf4D1K81Wc9jdzwhnr8w/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                     <strong>图8. Pod 与 Service 之间通信</strong></p><p>当这 Pod 和 Service 之间路由一个数据包时，流量和以前开始的方式一样，数据包首先通过连接到 Pod 的网络命名空间（1）的 <code>eth0</code> 离开 Pod，。然后它通过虚拟网络设备到达网桥（2）。网桥上运行的 ARP 是不知道 Service 地址的，所以它通过默认路由 <code>eth0</code>（3）将数据包传输出去。到这里会有一些不同的地方了，在 <code>eth0</code> 接收之前，该数据包会被 iptables 过滤，在收到数据包后，iptables 使用 kube-proxy 在节点上安装的规则来响应 Service 或 Pod 事件，将数据包的目的地从 Service VIP 改写为特定的 Pod IP（4）。该数据包现在就要到达 pod4 了，而不是 Service 的 VIP，iptables 利用内核的 <code>conntrack</code> 工具来记录选择的 Pod，以便将来的流量会被路由到相同的 Pod。从本质上讲，iptables 直接从节点上完成了集群内的负载均衡，然后流量流向 Pod，剩下的就和前面的 Pod 到 Pod 通信一样的了（5）。</p><h3 id="Service-到-Pod-通信"><a href="#Service-到-Pod-通信" class="headerlink" title="Service 到 Pod 通信"></a>Service 到 Pod 通信</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgtV3KndqR2yoKUjoRlicMAwVOAnRzQn1lzibNE7ndyQpNHQ3UoeF0toiag/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                              <strong>图9.在 Service 和 Pod 之间通信</strong></p><p>相应的回包的时候，收到该数据包的 Pod 将响应，将源 IP 标记为自己的 IP，将目标 IP 标记为最初发送数据包的 Pod(1)。进入节点后，数据包流经 iptables，它使用 <code>conntrack</code> 记住它之前所做的选择，并将数据包的源重写为 Service 的 VIP 而不是现在 Pod 的 IP(2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟网络设备 (3)，然后流向我们之前看到的 Pod 的虚拟网络设备 (4)。</p><h2 id="外网到-Service-通信"><a href="#外网到-Service-通信" class="headerlink" title="外网到 Service 通信"></a>外网到 Service 通信</h2><p>到这里我们已经了解了 Kubernetes 集群内的流量是如何路由的，但是更多的时候我们需要将服务暴露到外部去。这个时候会涉及到两个主要的问题：</p><ul><li>将流量从 Kubernetes 服务路由到互联网上去</li><li>将流量从互联网传到你的 Kubernetes 服务</li></ul><p>接下来我们就来讨论这些问题。</p><h3 id="出流量"><a href="#出流量" class="headerlink" title="出流量"></a>出流量</h3><p>从节点到公共 Internet 的路由流量也是和特定的网络有关系的，这取决于你的网络如何配置来发布流量的。这里我们以 AWS VPC 为例来进行说明。</p><p>在 AWS 中，Kubernetes 集群在 VPC 中运行，每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问服务，你可以在 VPC 上附加一个外网网关。外网网关有两个用途：在你的 VPC 路由表中为可路由到外网的流量提供目标，以及为已分配公共 IP 地址的实例执行网络地址转换 (NAT)。NAT 转换负责将集群节点的内部 IP 地址更改为公网中可用的外部 IP 地址。</p><p>有了外网网关，VM 就可以自由地将流量路由到外网。不过有一个小问题，Pod 有自己的 IP 地址，与运行 Pod 的节点 IP 地址不同，并且外网网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道哪些 Pod 在哪些 VM 上运行 —— 网关不支持容器。让我们看看 Kubernetes 是如何使用 iptables 来解决这个问题的。</p><p>在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的网络设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，外网网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是<strong>让 iptables 执行源 NAT</strong> —— 更改数据包源，使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达外网网关 (5) 了。外网网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为公网IP。最后，数据包将到达互联网上 (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 的修改都会被取消，这样系统的每一层都会接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgGaUDVlu2VesbE999GjqtA1WthWLBRF47ZDQ6XttQMqkjq9fc1YE3kg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                       <strong>图10.从Pod到互联网通信</strong></p><h3 id="入流量"><a href="#入流量" class="headerlink" title="入流量"></a>入流量</h3><p>让流量进入你的集群是一个非常难以解决的问题。同样这也和特定的网络环境有关系，但是一般来说入流量可以分为两种解决方案：</p><ul><li>Service LoadBalancer</li><li>Ingress 控制器</li></ul><p><strong>LoadBalancer</strong></p><p>当你创建一个 Kubernetes Service时，你可以选择指定一个 LoadBalancer 来使用它。LoadBalancer 有为你提供服务的云供应商负责创建负载均衡器，创建服务后，它将暴露负载均衡器的 IP 地址。终端用户可以直接通过该 IP 地址与你的服务进行通信。</p><p><strong>LoadBalancer 到 Service</strong></p><p>在部署了 Service 后，你使用的云提供商将会为你创建一个新的 LoadBalancer（1）。因为 LoadBalancer 不支持容器，所以一旦流量到达 LoadBalancer，它就会分布在集群的各个节点上（2）。每个节点上的 iptables 规则会将来自 LoadBalancer 的传入流量路由到正确的 Pod 上（3）。从 Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有 LoadBalancer 的 IP 地址。正如我们之前看到的，iptables 和 conntrack 被用来在返回路径上正确重写 IP 地址。</p><p>下图展示的就是托管 Pod 的三个节点前面的负载均衡器。传入流量（1）指向 Service 的 LoadBalancer，一旦 LoadBalancer 接收到数据包（2），它就会随机选择一个节点。我们这里的示例中，我们选择了没有运行 Pod 的节点 VM2（3）。在这里，运行在节点上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载均衡规则，将数据包转发到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod（4）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgjicHYRZia3uYzyTenTbsnsCcUaKZYt1PeIj69MYh8uNic3oziaicIZeFKmQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                      <strong>图11.外网访问 Service</strong></p><p><strong>Ingress 控制器</strong></p><p>在七层网络上 Ingress 在 HTTP&#x2F;HTTPS 协议范围内运行，并建立在 Service 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 类型的 Service，如果你将 Service 设置成 NodePort 类型，Kubernetes master 将从你指定的范围内分配一个端口，并且每个节点都会将该端口代理到你的 Service，也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到 Service。</p><p>将节点的端口暴露在外网，可以使用一个 Ingress 对象，Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes Service。根据控制器的实现方式，Ingress 的使用方式会有所不同。HTTP 负载均衡器，和四层网络负载均衡器一样，只了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。</p><p>在 AWS 环境中，ALB Ingress 控制器使用 AWS 的七层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件，它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgdr38KkXPhd9AKtGnrYhn2SxGDKy0fbjFWIrfrgzXaXCzjicEIjrWzRg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​                                                                                                                   <strong>图12.Ingress 控制器</strong></p><p>创建后，(1) Ingress Controller 会 watch 来自 Kubernetes APIServer 的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的 TargetGroup一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes Service 创建 TargetGroup。(4) Listener 是一个 ALB 进程，它使用你配置的协议和端口检查连接请求。Listener 由 Ingress 控制器为你的 Ingress 资源中描述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建 TargetGroup 规则。这可以保证到特定路径的流量被路由到正确的 Kubernetes 服务上 (5)。</p><p><strong>Ingress 到 Service</strong></p><p>流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（可以根据路径将流量路由到 Service）Ingress 和节点之间的初始连接是通过节点上为每个服务暴露的端口。</p><p>部署 Service 后，你使用的云提供商将为你创建一个新的 Ingress 负载均衡器 (1)。因为负载均衡器不支持容器，一旦流量到达负载均衡器，它就会通过为你的服务端口分布在组成集群 (2) 的整个节点中。每个节点上的 iptables 规则会将来自负载均衡器的传入流量路由到正确的 Pod (3)。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/z9BgVMEm7YtugibqBH8vj7OvmDx0O2fwgB6f7ZsmsiamnMF10mxPp1NvlmMw5sHGfqAQ0MKnkYTxlMKpjkI6Gctg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><p>​                                                                                                                                               <strong>图13.从 Ingress 到 Service</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Kubernetes 网络模型以及如何实现常见网络任务。网络知识点既广泛又很深，所以我们这里不可能涵盖所有的内容，但是你可以以本文为起点，然后去深入了解你感兴趣的主题。</p><blockquote><p>原文链接：<a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model">https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服内推</title>
    <link href="/2022/08/27/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%86%85%E6%8E%A8/"/>
    <url>/2022/08/27/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%86%85%E6%8E%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果-简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。"><a href="#帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果-简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。" class="headerlink" title="帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果 - 简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。"></a>帮忙社招、校招、实习内推，可帮忙查询最新进展、面试结果 - 简历优先处理、可以帮忙看简历以及回答力所能及的问题，欢迎大家来投，想要帮忙看简历或者问问题可以私聊加微信或者发送邮箱，由于内推岗位选择数量有限制，存在部分岗位没有显示，可以私聊我直接投递或者上官网公众号投递。</h3><h3 id="招聘网址-https-app-mokahr-com-recommendation-apply-sangfor-5369-recommendCode-NTAEMbl-jobs-isCampusJob-1-amp-commitment-E5-85-A8-E8-81-8C"><a href="#招聘网址-https-app-mokahr-com-recommendation-apply-sangfor-5369-recommendCode-NTAEMbl-jobs-isCampusJob-1-amp-commitment-E5-85-A8-E8-81-8C" class="headerlink" title="招聘网址:   https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C"></a>招聘网址:   <a href="https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C">https://app.mokahr.com/recommendation-apply/sangfor/5369?recommendCode=NTAEMbl#/jobs?isCampusJob=1&amp;commitment=%E5%85%A8%E8%81%8C</a></h3><h3 id="内推码：NTAEMbl-投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！"><a href="#内推码：NTAEMbl-投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！" class="headerlink" title="内推码：NTAEMbl   投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！"></a>内推码：NTAEMbl   投递时直接官网投递时填内推码即可，后续进展等问题可直接私信我！</h3><p><img src="https://s2.loli.net/2022/08/27/aR4mNMEGDWwsHfT.jpg" alt="a3a7bad9b480bd23d69abd81723f366.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>内推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
